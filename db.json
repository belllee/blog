{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner1.jpg","path":"css/images/banner1.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1515298617959},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1515298617959},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1515298617959},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1515298617959},{"_id":"themes/landscape/_config.yml","hash":"fc70da4edc5f128187e289ad348c02e98b78bc5c","modified":1515590099165},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1515298617959},{"_id":"source/_posts/关于我.md","hash":"90fbc2f9baa2aabbff893f71681fef0f72d73fe2","modified":1515592585300},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1515298617990},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1515298617974},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1515298617990},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1515298617990},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1515298617990},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1515298617990},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1515298617990},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1515298617990},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1515298618006},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1515298618006},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1515298618037},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1515298618006},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1515298618006},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1515298618006},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1515298617990},{"_id":"source/_posts/db/mongodb的internalQueryExecMaxBlockingSortBytes异常修复.md","hash":"f4afc62b19c341afd0e7165f8f9fea2f8464b851","modified":1515592715229},{"_id":"source/_posts/java/EffectiveJava--创建和销毁对象.md","hash":"ea16a6f78430d189ee603b0a4e67e447003d2deb","modified":1515593049315},{"_id":"source/_posts/java/EffectiveJava--对象的通用方法.md","hash":"c8fbb77f35cfbc32e8f119d521b85d30465e2d5b","modified":1515592935452},{"_id":"source/_posts/java/非maven的jar包怎么引入maven工程.md","hash":"a47feee7d2b42285c1c2ed7915487087bb9332d7","modified":1515591759363},{"_id":"source/_posts/swe/也谈TDD.md","hash":"775e18bfab65fa0e21a541660ed9fc25878643a5","modified":1515591377525},{"_id":"source/_posts/tool/hexo.md","hash":"77a72700d43e8dd69084652a3e29875bfdf75a5b","modified":1515591505874},{"_id":"source/_posts/tool/编码新利器--Visual-Studio-Code.md","hash":"4299fbf1f2dd68c80ffac561d131c813b56fd0ee","modified":1515591607178},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"3dd3cce330a388acc04c9bdb10a7b5033e260bc3","modified":1515330038098},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1515298618052},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1515298618068},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1515298618068},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1515298618052},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1515298618068},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1515298618084},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1515298618084},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1515298618084},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1515298618099},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1515298618037},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1515298618084},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1515298618084},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1515298618099},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1515298618084},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1515298618037},{"_id":"themes/landscape/source/css/_variables.styl","hash":"9e9355c777354c3757c1bcbbd28211f19070e8d2","modified":1515593354456},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1515298618084},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1515298618037},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1515298618099},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1515298618131},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1515298618162},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1515298618131},{"_id":"source/_posts/FE/js/高性能JavaScript-JS加载和执行.md","hash":"00f4ee49ffaf1575854a80423d8468a2b391430b","modified":1515591099574},{"_id":"source/_posts/FE/js/高性能JavaScript-作用域链.md","hash":"f961aad016d65681ce2a614d18b6f0ace9504952","modified":1515591149919},{"_id":"source/_posts/FE/js/高性能JavaScript-原型链.md","hash":"818aec9df0f0f0647aa9b8bb2c34791b51f6b66b","modified":1515591176463},{"_id":"source/_posts/FE/test/使用Protractor进行web功能测试.md","hash":"e057f5bbe42be34392c8497acf950661f0f5f172","modified":1515591024104},{"_id":"source/_posts/FE/test/基于karma-jasmine的web前端自动化测试.md","hash":"39bdbb067d51a787ff64fb1d9959d9651e11a6d5","modified":1515591025848},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1515298618146},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1515298618146},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1515298618146},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1515298618146},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1515298618162},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1515298618162},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1515298618162},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1515298618193},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1515298618177},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1515298618177},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1515298618162},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1515298618193},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1515298618177},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1515298618209},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1515298618193},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1515298618162},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1515298618193},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1515298618193},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1515298618209},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1515298618193},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1515298618224},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1515298618209},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1515298618224},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1515298618209},{"_id":"themes/landscape/source/css/images/banner1.jpg","hash":"238aab19872b63b857fd1607f853bc75bd26ab92","modified":1515593239777},{"_id":"public/2018/01/10/db/mongodb的internalQueryExecMaxBlockingSortBytes异常修复/index.html","hash":"3375c25dc5cdece778e5fed4ba208b95a4bd0695","modified":1520777716981},{"_id":"public/2018/01/10/java/非maven的jar包怎么引入maven工程/index.html","hash":"7c4d01e135bb75bbf2e5b1794f6783b0a810b3bf","modified":1520777716981},{"_id":"public/2018/01/10/swe/也谈TDD/index.html","hash":"d29c89d3746214774ef2955e8811c66a69f8b29f","modified":1520777716981},{"_id":"public/2018/01/10/FE/js/高性能JavaScript-JS加载和执行/index.html","hash":"fb891534e43e21cf9f213c3c3c8566bdcf3bdab9","modified":1520777716989},{"_id":"public/2018/01/10/tool/编码新利器--Visual-Studio-Code/index.html","hash":"5bc96cb284d9ad0c1f1cc4ba6cda1f16ed4eacbc","modified":1520777716989},{"_id":"public/2018/01/07/tool/hexo/index.html","hash":"44df99687f9569aa2bb528c59c5190d43b9edc31","modified":1520777716981},{"_id":"public/2018/01/01/关于我/index.html","hash":"8258215f89fca0232ef9249d29c7dd4f59c2895b","modified":1520777716981},{"_id":"public/archives/index.html","hash":"f899c4fb5d2ced02f150cf9a11a8e20e0d428c52","modified":1520777716981},{"_id":"public/archives/page/2/index.html","hash":"ba828f293d875b9e260b4ab106f2df194c179fc5","modified":1520777716981},{"_id":"public/archives/2018/index.html","hash":"c445d8390e29bc4c915bbba87ba3203d88200831","modified":1520777716985},{"_id":"public/archives/2018/page/2/index.html","hash":"e12e347cc88bc6b50dc66cb3da8cb120e0418640","modified":1520777716985},{"_id":"public/archives/2018/01/index.html","hash":"2031a1dddd0d0dde802e455645d5ef29bb9e88ba","modified":1520777716985},{"_id":"public/archives/2018/01/page/2/index.html","hash":"36f618c81173690aac265c7f8f6e541d96a77f38","modified":1520777716985},{"_id":"public/tags/db/index.html","hash":"ebdde06e382e052f1a8f8e9d175b352b6d3053c0","modified":1520777716985},{"_id":"public/tags/mongodb/index.html","hash":"3f2c6631679bb5d546c2187da8bbd2e3954f6069","modified":1520777716985},{"_id":"public/tags/java/index.html","hash":"78d66286e27556531a8638f816b968bd08e0acee","modified":1520777716985},{"_id":"public/tags/敏捷/index.html","hash":"729835e57e88a39f92b5605adec2df8443e0e2f6","modified":1520777716985},{"_id":"public/tags/工具/index.html","hash":"db22d4335610f3509f36400cbb54c83c00247048","modified":1520777716985},{"_id":"public/tags/JS/index.html","hash":"34f6caec21a9dac570d2df751e45f6dc524992c7","modified":1520777716985},{"_id":"public/tags/性能/index.html","hash":"1b8be4d92995720b2ab9bca0183529dfebac8d99","modified":1520777716985},{"_id":"public/tags/自动化/index.html","hash":"daf78371e5ef44ce4c5c29da271b4857238322ce","modified":1520777716985},{"_id":"public/tags/测试/index.html","hash":"0c91e295a92489b827840e59c05a3e4cb5e7452f","modified":1520777716985},{"_id":"public/2018/01/10/java/EffectiveJava--创建和销毁对象/index.html","hash":"2480abdbbe69b487202771273fe6622e3d1669f4","modified":1520777716989},{"_id":"public/2018/01/10/java/EffectiveJava--对象的通用方法/index.html","hash":"91bdcf2c3d3b6f7d9a8d7b99beaaa69922508687","modified":1520777716989},{"_id":"public/2018/01/10/FE/js/高性能JavaScript-原型链/index.html","hash":"cf0f98b12a2ddedfb46cb68ae5d309be2c615fed","modified":1520777716989},{"_id":"public/2018/01/10/FE/js/高性能JavaScript-作用域链/index.html","hash":"8d2d469958e26edc4cbf4583d8600f24870a8a72","modified":1520777716989},{"_id":"public/2018/01/10/FE/test/基于karma-jasmine的web前端自动化测试/index.html","hash":"dc8e8fe56f690b4a365c5b640cacfa75034a4be2","modified":1520777716989},{"_id":"public/2018/01/10/FE/test/使用Protractor进行web功能测试/index.html","hash":"94f9ebf85c7d15992ff305a70d6734b1b11d279a","modified":1520777716989},{"_id":"public/index.html","hash":"b5e31793390a27cf1f80b9265a4ad630aa701ba3","modified":1520777716989},{"_id":"public/page/2/index.html","hash":"ded0a60da5dac7340fd2b5f5ef50cd89ea25e07f","modified":1520777716989},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520777717009},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520777717009},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520777717009},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520777717009},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520777717009},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520777717009},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1520777717009},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1520777717009},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1520777717009},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520777717009},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1520777717713},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1520777717713},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1520777717713},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1520777717713},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1520777717713},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1520777717713},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1520777717713},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1520777717713},{"_id":"public/css/style.css","hash":"0606d9f7d56d4ac872fca4633d2fc3bff764ec9a","modified":1520777717713},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1520777717713},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1520777717713},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1520777717812},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1520777717812},{"_id":"public/css/images/banner1.jpg","hash":"238aab19872b63b857fd1607f853bc75bd26ab92","modified":1520777717828},{"_id":"source/_posts/FE/web前端介绍.md","hash":"c005c763d78f17d3b323a5375115f2b95f183375","modified":1520777281392},{"_id":"source/_posts/db/centos安装mysql过程记录.md","hash":"050c6d6990f2bd74488f10be24abe060e539bc89","modified":1520751491498},{"_id":"source/_posts/java/ZUUL路由服务遇到的坑.md","hash":"d54c45d773e4e91e0d90c70ac6d8e3b9983442a4","modified":1520752450381},{"_id":"source/_posts/java/spring boot开发经验汇总.md","hash":"e25c83d415e50a9b81a54ab9548a539607903975","modified":1520752774672},{"_id":"source/_posts/tool/BeyongCompare跨操作系统比较文件.md","hash":"5d6c9f02dcca2640966879c6b0dfcd03412b907f","modified":1520603934295},{"_id":"source/_posts/tool/Chrome无法搜索和安装插件的解决办法.md","hash":"9dea8822c5d0276925188273a26a150004218f82","modified":1520753343714},{"_id":"source/_posts/tool/JConsole的远程连接.md","hash":"7e10cd57c795bdb9a97bf3ac7916fd9132a70944","modified":1520597974731},{"_id":"source/_posts/tool/Jenkins脚本调用firefox失败的解决办法.md","hash":"c5e1d0fbffbe7e613fe0e74f5701fcd1444bcf62","modified":1520597974747},{"_id":"source/_posts/tool/代码量统计存在的问题和对策.md","hash":"d4073343328745d38dc0b57365d0a7c7cfc405b4","modified":1520603716760},{"_id":"source/_posts/tool/linux上使用publickey访问gerrit异常.md","hash":"0bca0b34aa7cdfd045d8dc30b64f1b5abb2a8d97","modified":1520597974755},{"_id":"source/_posts/tool/sublime如何设置不同语言的缩进.md","hash":"68724afc30b4b0c494d114bea245238acea75376","modified":1520777686625},{"_id":"source/_posts/other/企业知识管理.md","hash":"a78fd2b3b53dddda0a036383a2463a6654231e4f","modified":1520603821473},{"_id":"source/_posts/other/微信公众号开发.md","hash":"6d7a49b6f7fc92ae956f3a2f0c4ed4620da60b23","modified":1520603829851},{"_id":"source/_posts/tool/重复代码检测工具.md","hash":"e6d3f2d7243052c9f30f468271bc407477cf4eae","modified":1520602878025},{"_id":"source/_posts/FE/engineering/Grunt--web前端构建工具.md","hash":"d15e95e61d45fbfd14948a8e6eb72e21c8fbb99b","modified":1520752665140},{"_id":"source/_posts/FE/js/高性能JavaScript--DOM操作.md","hash":"f686a36e513179671ff8a9e2cf8e0b41a1c02ac4","modified":1520597974723},{"_id":"source/_posts/FE/ng/AngularJS学习--Directives.md","hash":"7e71562c4ce9e73d5031949806f7addb81f7df98","modified":1520665839744},{"_id":"source/_posts/FE/ng/AngularJS学习--Resource.md","hash":"cadd78a836d0fbb48a336443827faf8a9102a055","modified":1520749172141},{"_id":"source/_posts/FE/ng/AngularJS学习--Services.md","hash":"1e7154ba9cce1ea4a5ab3fa6a1d8a70063acbde4","modified":1520667671480},{"_id":"source/_posts/FE/ng/AngularJS学习--UI-Route.md","hash":"c233d1d8c7e016944a10bb182f0c3bb7c55ed543","modified":1520751388384},{"_id":"public/2018/01/30/tool/JConsole的远程连接/index.html","hash":"3b75d3656bef43ea10cb16f3b324308daaf2fac9","modified":1520777716977},{"_id":"public/2018/01/17/tool/linux上使用publickey访问gerrit异常/index.html","hash":"900fc51be5b47ced47499f064db01e2e41dcb09d","modified":1520777716977},{"_id":"public/2018/01/08/tool/Jenkins脚本调用firefox失败的解决办法/index.html","hash":"8d99cd8a2bd36176456834244fcae5e95b597793","modified":1520777716981},{"_id":"public/2017/01/10/db/centos安装mysql过程记录/index.html","hash":"cf773e89d0127328fc1e4ce6c6bb41218a9be912","modified":1520777716981},{"_id":"public/2016/07/10/tool/BeyongCompare跨操作系统比较文件/index.html","hash":"42b20b173e37cb0ad57876d67dd8d082c9e6429d","modified":1520777716981},{"_id":"public/2016/07/10/tool/Chrome无法搜索和安装插件的解决办法/index.html","hash":"326ac096624d705083a3be7fd344caef63ff2c5f","modified":1520777716981},{"_id":"public/2015/12/09/tool/sublime如何设置不同语言的缩进/index.html","hash":"c8286913f68e653e70d50788fee6e0018e2edd04","modified":1520777716981},{"_id":"public/2015/05/19/tool/代码量统计存在的问题和对策/index.html","hash":"d5e5d9b6d55136cc8f07c982ffd6d362d4a6c188","modified":1520777716981},{"_id":"public/2015/05/10/tool/重复代码检测工具/index.html","hash":"32deab97bdc1401ad57704c776a9f2879e5239bf","modified":1520777716981},{"_id":"public/archives/page/3/index.html","hash":"1e9ec5080e567f066d66d1cb62c929d4f55bed6c","modified":1520777716981},{"_id":"public/archives/page/4/index.html","hash":"d90127f5b4774209ce19068baeba4588b9e90577","modified":1520777716981},{"_id":"public/archives/2015/index.html","hash":"780e5ab019c77299892191b0cec61f4307d8a0e1","modified":1520777716981},{"_id":"public/archives/2015/05/index.html","hash":"6b2186d59f9baf9a7ddac0294c05daeedd207df0","modified":1520777716981},{"_id":"public/archives/2015/12/index.html","hash":"6c1290b24ca1cec878c4ef2b4608ef5c683d72e2","modified":1520777716981},{"_id":"public/archives/2016/index.html","hash":"11f5186fcc3c1a2de8904f1e5121810bb05169e3","modified":1520777716981},{"_id":"public/archives/2016/04/index.html","hash":"5cdef3e825ac7bf6e2d3f11fdf92bf7d3d476bdb","modified":1520777716981},{"_id":"public/archives/2016/05/index.html","hash":"c79596f69ab60cd2f037523d51e10193610c5c29","modified":1520777716981},{"_id":"public/archives/2016/07/index.html","hash":"289d60a03a6d4a07cdb706f40114c51c9fe52c4c","modified":1520777716981},{"_id":"public/archives/2016/09/index.html","hash":"15456b80327ee45d1801e11f91604decf9610c56","modified":1520777716981},{"_id":"public/archives/2016/10/index.html","hash":"db6515f0a9e327c62590f83d2196bd9bdedc9c05","modified":1520777716981},{"_id":"public/archives/2017/index.html","hash":"5dd214f9d092169dce4c1d96b98206abee206d30","modified":1520777716985},{"_id":"public/archives/2017/01/index.html","hash":"0f3a8f2b036d6e9e7f4247e95c934c1dd5f81da9","modified":1520777716985},{"_id":"public/archives/2017/12/index.html","hash":"05827ab40ca1981d4145242c4d18361ac2861b09","modified":1520777716985},{"_id":"public/archives/2018/02/index.html","hash":"79384c74c1c8e5cd13d8739a7097a5e538bf964c","modified":1520777716985},{"_id":"public/tags/工具/page/2/index.html","hash":"3533316a8ca67920bd7db087b09ae9dbeb0809e9","modified":1520777716985},{"_id":"public/tags/前端/index.html","hash":"b0ea4126afd3c5c10660e2a83429dc8e71994cf8","modified":1520777716985},{"_id":"public/tags/spring/index.html","hash":"dce108d68dd1e47628503976384166c0eabece10","modified":1520777716985},{"_id":"public/tags/MySQL/index.html","hash":"7929bc8122473ed23c7753f8bb711a1d4e0ee0ba","modified":1520777716985},{"_id":"public/tags/zuul/index.html","hash":"0ca0f08c276da51e620046118ae8bad12ce50055","modified":1520777716985},{"_id":"public/tags/linux/index.html","hash":"2bad41be49fc51e3e382044532eb30fdd3e41b83","modified":1520777716985},{"_id":"public/tags/linux，java/index.html","hash":"a214053916be92b2bb6d5f15ca6b71757660af00","modified":1520777716985},{"_id":"public/tags/gerrit/index.html","hash":"12dd8c5910091e6b3827cc5199fec0da539b6be9","modified":1520777716989},{"_id":"public/tags/AngularJS/index.html","hash":"4941b5e5bbe86409f921875992eae0ec660477a8","modified":1520777716989},{"_id":"public/2018/02/26/java/ZUUL路由服务遇到的坑/index.html","hash":"c793c45f2b24a433aa06272857bc77af35f5c3bf","modified":1520777716989},{"_id":"public/2017/12/12/FE/js/高性能JavaScript--DOM操作/index.html","hash":"7280984ade063325fb4b23928d6d26bd76dbeaad","modified":1520777716989},{"_id":"public/2016/10/16/FE/web前端介绍/index.html","hash":"02f4650d46d990ff18fea3b76434af367cd25776","modified":1520777716989},{"_id":"public/2016/10/10/other/微信公众号开发/index.html","hash":"d9f52fa0ada4cc08cc84dea450503316fc157d2a","modified":1520777716989},{"_id":"public/2016/09/10/FE/engineering/Grunt--web前端构建工具/index.html","hash":"ffac1ab73e94df5ae194fc150177f32378ed2729","modified":1520777716989},{"_id":"public/2016/07/09/java/spring boot开发经验汇总/index.html","hash":"32f1f5ec123573d611796f43b9c90a85e07ef030","modified":1520777716989},{"_id":"public/2016/05/09/FE/ng/AngularJS学习--Resource/index.html","hash":"88472f5b168318a68aaaa6fa2bd9c5ee46d13fc0","modified":1520777716989},{"_id":"public/2016/05/09/FE/ng/AngularJS学习--UI-Route/index.html","hash":"4b6e3f6e531906e9e140e84d0c1feaeed4c639d0","modified":1520777716989},{"_id":"public/2016/04/02/FE/ng/AngularJS学习--Directives/index.html","hash":"a8751cf28bc148e297ce921a66ea2cc0c73ef703","modified":1520777716989},{"_id":"public/2016/04/02/FE/ng/AngularJS学习--Services/index.html","hash":"c48627bd7b2b08567c3e093aafae6faadddca8bc","modified":1520777716989},{"_id":"public/2015/05/10/other/企业知识管理/index.html","hash":"6148dbab975cf63058caade24d30eece46f0d394","modified":1520777716989},{"_id":"public/page/3/index.html","hash":"18d62a6e13d5f34ea40c30af206650e4f3787da3","modified":1520777716989},{"_id":"public/page/4/index.html","hash":"e55a24108a72980ab79262c0fe00bcd0140ec482","modified":1520777716989}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"关于我","date":"2018-01-01T11:53:12.000Z","_content":"\n2004年南京航空航天大学本科毕业后来到上海。先后在华为，中兴以及物联网公司就职。做过测试，自动化测试工具，物联网应用软件系统，web系统开发。参与敏捷推广。web全栈均有所涉猎，ASP.net,Android,Spring cloud,AngularJS,Vue,React Native……\n目前就职于中兴通讯，在一款企业内部知识共享，组织协作平台项目中担任Tech Leader，系统架构师。\n<center>出生于白山黑水之间，\n求学于虎踞龙蟠之地，\n奋斗于东方明珠之畔，\n钟情于coding之中。</center>\n\n#### 曾经写的一些博客\nhttps://my.oschina.net/belllee/blog\nhttps://www.jianshu.com/u/563753cefe4d\nhttp://blog.csdn.net/li_lzw","source":"_posts/关于我.md","raw":"---\ntitle: 关于我\ndate: 2018-01-01 19:53:12\ntags:\n---\n\n2004年南京航空航天大学本科毕业后来到上海。先后在华为，中兴以及物联网公司就职。做过测试，自动化测试工具，物联网应用软件系统，web系统开发。参与敏捷推广。web全栈均有所涉猎，ASP.net,Android,Spring cloud,AngularJS,Vue,React Native……\n目前就职于中兴通讯，在一款企业内部知识共享，组织协作平台项目中担任Tech Leader，系统架构师。\n<center>出生于白山黑水之间，\n求学于虎踞龙蟠之地，\n奋斗于东方明珠之畔，\n钟情于coding之中。</center>\n\n#### 曾经写的一些博客\nhttps://my.oschina.net/belllee/blog\nhttps://www.jianshu.com/u/563753cefe4d\nhttp://blog.csdn.net/li_lzw","slug":"关于我","published":1,"updated":"2018-01-10T13:56:25.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci1i000080cmeci6ipl9","content":"<p>2004年南京航空航天大学本科毕业后来到上海。先后在华为，中兴以及物联网公司就职。做过测试，自动化测试工具，物联网应用软件系统，web系统开发。参与敏捷推广。web全栈均有所涉猎，ASP.net,Android,Spring cloud,AngularJS,Vue,React Native……<br>目前就职于中兴通讯，在一款企业内部知识共享，组织协作平台项目中担任Tech Leader，系统架构师。</p>\n<center>出生于白山黑水之间，<br>求学于虎踞龙蟠之地，<br>奋斗于东方明珠之畔，<br>钟情于coding之中。</center>\n\n<h4 id=\"曾经写的一些博客\"><a href=\"#曾经写的一些博客\" class=\"headerlink\" title=\"曾经写的一些博客\"></a>曾经写的一些博客</h4><p><a href=\"https://my.oschina.net/belllee/blog\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/belllee/blog</a><br><a href=\"https://www.jianshu.com/u/563753cefe4d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/u/563753cefe4d</a><br><a href=\"http://blog.csdn.net/li_lzw\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/li_lzw</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>2004年南京航空航天大学本科毕业后来到上海。先后在华为，中兴以及物联网公司就职。做过测试，自动化测试工具，物联网应用软件系统，web系统开发。参与敏捷推广。web全栈均有所涉猎，ASP.net,Android,Spring cloud,AngularJS,Vue,React Native……<br>目前就职于中兴通讯，在一款企业内部知识共享，组织协作平台项目中担任Tech Leader，系统架构师。</p>\n<center>出生于白山黑水之间，<br>求学于虎踞龙蟠之地，<br>奋斗于东方明珠之畔，<br>钟情于coding之中。</center>\n\n<h4 id=\"曾经写的一些博客\"><a href=\"#曾经写的一些博客\" class=\"headerlink\" title=\"曾经写的一些博客\"></a>曾经写的一些博客</h4><p><a href=\"https://my.oschina.net/belllee/blog\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/belllee/blog</a><br><a href=\"https://www.jianshu.com/u/563753cefe4d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/u/563753cefe4d</a><br><a href=\"http://blog.csdn.net/li_lzw\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/li_lzw</a></p>\n"},{"title":"mongodb的internalQueryExecMaxBlockingSortBytes异常修复","date":"2018-01-10T13:57:40.000Z","_content":"### 现象\nnode执行的服务出现异常，查看日志发现如下错误。\n```\nMongoError: QueryFailure flag set on getmore command\n    at Object.toError (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\utils.js:114:11)\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\cursor.js:854:31\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\db.js:1905:9\n    at Server.Base._callHandler (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\base.js:453:41)\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:488:18\n    at MongoReply.parseBody (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\responses\\mongo_reply.js:68:5)\n    at .<anonymous> (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:446:20)\n    at emitOne (events.js:96:13)\n    at emit (events.js:188:7)\n```\n查询该错误，未找到具体原因。然后在mongodb\\cursor.js 854行，增加打印result。得到具体错误信息如下：\nOverflow sort stage buffered data usage exceeds in internal limit\nmongo执行sort语句时，内存最大32M，如果数据量大，超过这个限制就出抛出异常。\n\n### 解决办法\n1、给sort语句中的字段建立索引。\n  比如： sort({ endDate: -1, createTime: -1})\n  建立索引如下：db.activity.createIndex({ endDate: -1, createTime: -1})  。其中acitivity是集合名\n\n2、增加内存限制\n需要在admin数据库下role为root的账户下设置,例如设置成100M\n```\nuse admin\ndb.auth(\"adminuser\",\"passwd\")\ndb.adminCommand({setParameter: 1, internalQueryExecMaxBlockingSortBytes: 104857600})\n```\n综合查询性能和服务器资源占用，推荐使用建立索引的方式。\n\n### 其他需要注意的地方\n除了sort, aggregate也存在内存限制，这是需要使用allowDiskUse参数，允许使用硬盘缓存中间数据。具体设置如下\n```\ndb.activity.aggregate(\n\t\t[{ $unwind: '$applyment' },\n\t\t{ $match: { 'applyment.items.value': req.query.uid }},\n\t\t{ $project : {id:1,title: 1, 'applyment.approve': 1,'applyment.createTime': 1, endDate: 1}},\n\t\t{ $sort:{ 'applyment.createTime': -1 }},\n\t\t{ $skip:(result.pageNumber - 1) * result.pageSize},\n\t\t{ $limit:result.pageSize}],\n\t\t{ allowDiskUse: true}）\n```\n### 关于设置索引\n1、mongoDB 3.0开始ensureIndex被废弃，今后都仅仅是db.collection.createIndex的一个别名。\n2、子对象的属性设置索引db.activity.createIndex({ \"applyment.createTime\": -1}) \n3、数组内置顶位置设置索引db.activity.createIndex({ \"applyment.items.0.value\": 1}) \n","source":"_posts/db/mongodb的internalQueryExecMaxBlockingSortBytes异常修复.md","raw":"---\ntitle: mongodb的internalQueryExecMaxBlockingSortBytes异常修复\ndate: 2018-01-10 21:57:40\ntags: [db,mongodb]\n---\n### 现象\nnode执行的服务出现异常，查看日志发现如下错误。\n```\nMongoError: QueryFailure flag set on getmore command\n    at Object.toError (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\utils.js:114:11)\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\cursor.js:854:31\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\db.js:1905:9\n    at Server.Base._callHandler (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\base.js:453:41)\n    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:488:18\n    at MongoReply.parseBody (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\responses\\mongo_reply.js:68:5)\n    at .<anonymous> (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:446:20)\n    at emitOne (events.js:96:13)\n    at emit (events.js:188:7)\n```\n查询该错误，未找到具体原因。然后在mongodb\\cursor.js 854行，增加打印result。得到具体错误信息如下：\nOverflow sort stage buffered data usage exceeds in internal limit\nmongo执行sort语句时，内存最大32M，如果数据量大，超过这个限制就出抛出异常。\n\n### 解决办法\n1、给sort语句中的字段建立索引。\n  比如： sort({ endDate: -1, createTime: -1})\n  建立索引如下：db.activity.createIndex({ endDate: -1, createTime: -1})  。其中acitivity是集合名\n\n2、增加内存限制\n需要在admin数据库下role为root的账户下设置,例如设置成100M\n```\nuse admin\ndb.auth(\"adminuser\",\"passwd\")\ndb.adminCommand({setParameter: 1, internalQueryExecMaxBlockingSortBytes: 104857600})\n```\n综合查询性能和服务器资源占用，推荐使用建立索引的方式。\n\n### 其他需要注意的地方\n除了sort, aggregate也存在内存限制，这是需要使用allowDiskUse参数，允许使用硬盘缓存中间数据。具体设置如下\n```\ndb.activity.aggregate(\n\t\t[{ $unwind: '$applyment' },\n\t\t{ $match: { 'applyment.items.value': req.query.uid }},\n\t\t{ $project : {id:1,title: 1, 'applyment.approve': 1,'applyment.createTime': 1, endDate: 1}},\n\t\t{ $sort:{ 'applyment.createTime': -1 }},\n\t\t{ $skip:(result.pageNumber - 1) * result.pageSize},\n\t\t{ $limit:result.pageSize}],\n\t\t{ allowDiskUse: true}）\n```\n### 关于设置索引\n1、mongoDB 3.0开始ensureIndex被废弃，今后都仅仅是db.collection.createIndex的一个别名。\n2、子对象的属性设置索引db.activity.createIndex({ \"applyment.createTime\": -1}) \n3、数组内置顶位置设置索引db.activity.createIndex({ \"applyment.items.0.value\": 1}) \n","slug":"db/mongodb的internalQueryExecMaxBlockingSortBytes异常修复","published":1,"updated":"2018-01-10T13:58:35.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3a000180cmuseh0lp6","content":"<h3 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h3><p>node执行的服务出现异常，查看日志发现如下错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoError: QueryFailure flag set on getmore command</span><br><span class=\"line\">    at Object.toError (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\utils.js:114:11)</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\cursor.js:854:31</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\db.js:1905:9</span><br><span class=\"line\">    at Server.Base._callHandler (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\base.js:453:41)</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:488:18</span><br><span class=\"line\">    at MongoReply.parseBody (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\responses\\mongo_reply.js:68:5)</span><br><span class=\"line\">    at .&lt;anonymous&gt; (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:446:20)</span><br><span class=\"line\">    at emitOne (events.js:96:13)</span><br><span class=\"line\">    at emit (events.js:188:7)</span><br></pre></td></tr></table></figure></p>\n<p>查询该错误，未找到具体原因。然后在mongodb\\cursor.js 854行，增加打印result。得到具体错误信息如下：<br>Overflow sort stage buffered data usage exceeds in internal limit<br>mongo执行sort语句时，内存最大32M，如果数据量大，超过这个限制就出抛出异常。</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>1、给sort语句中的字段建立索引。<br>  比如： sort({ endDate: -1, createTime: -1})<br>  建立索引如下：db.activity.createIndex({ endDate: -1, createTime: -1})  。其中acitivity是集合名</p>\n<p>2、增加内存限制<br>需要在admin数据库下role为root的账户下设置,例如设置成100M<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use admin</span><br><span class=\"line\">db.auth(&quot;adminuser&quot;,&quot;passwd&quot;)</span><br><span class=\"line\">db.adminCommand(&#123;setParameter: 1, internalQueryExecMaxBlockingSortBytes: 104857600&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>综合查询性能和服务器资源占用，推荐使用建立索引的方式。</p>\n<h3 id=\"其他需要注意的地方\"><a href=\"#其他需要注意的地方\" class=\"headerlink\" title=\"其他需要注意的地方\"></a>其他需要注意的地方</h3><p>除了sort, aggregate也存在内存限制，这是需要使用allowDiskUse参数，允许使用硬盘缓存中间数据。具体设置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.activity.aggregate(</span><br><span class=\"line\">\t\t[&#123; $unwind: &apos;$applyment&apos; &#125;,</span><br><span class=\"line\">\t\t&#123; $match: &#123; &apos;applyment.items.value&apos;: req.query.uid &#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $project : &#123;id:1,title: 1, &apos;applyment.approve&apos;: 1,&apos;applyment.createTime&apos;: 1, endDate: 1&#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $sort:&#123; &apos;applyment.createTime&apos;: -1 &#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $skip:(result.pageNumber - 1) * result.pageSize&#125;,</span><br><span class=\"line\">\t\t&#123; $limit:result.pageSize&#125;],</span><br><span class=\"line\">\t\t&#123; allowDiskUse: true&#125;）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于设置索引\"><a href=\"#关于设置索引\" class=\"headerlink\" title=\"关于设置索引\"></a>关于设置索引</h3><p>1、mongoDB 3.0开始ensureIndex被废弃，今后都仅仅是db.collection.createIndex的一个别名。<br>2、子对象的属性设置索引db.activity.createIndex({ “applyment.createTime”: -1})<br>3、数组内置顶位置设置索引db.activity.createIndex({ “applyment.items.0.value”: 1}) </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h3><p>node执行的服务出现异常，查看日志发现如下错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoError: QueryFailure flag set on getmore command</span><br><span class=\"line\">    at Object.toError (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\utils.js:114:11)</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\cursor.js:854:31</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\db.js:1905:9</span><br><span class=\"line\">    at Server.Base._callHandler (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\base.js:453:41)</span><br><span class=\"line\">    at e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:488:18</span><br><span class=\"line\">    at MongoReply.parseBody (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\responses\\mongo_reply.js:68:5)</span><br><span class=\"line\">    at .&lt;anonymous&gt; (e:\\code\\api\\mobile\\nodejs\\node_modules\\mongodb\\lib\\mongodb\\connection\\server.js:446:20)</span><br><span class=\"line\">    at emitOne (events.js:96:13)</span><br><span class=\"line\">    at emit (events.js:188:7)</span><br></pre></td></tr></table></figure></p>\n<p>查询该错误，未找到具体原因。然后在mongodb\\cursor.js 854行，增加打印result。得到具体错误信息如下：<br>Overflow sort stage buffered data usage exceeds in internal limit<br>mongo执行sort语句时，内存最大32M，如果数据量大，超过这个限制就出抛出异常。</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>1、给sort语句中的字段建立索引。<br>  比如： sort({ endDate: -1, createTime: -1})<br>  建立索引如下：db.activity.createIndex({ endDate: -1, createTime: -1})  。其中acitivity是集合名</p>\n<p>2、增加内存限制<br>需要在admin数据库下role为root的账户下设置,例如设置成100M<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use admin</span><br><span class=\"line\">db.auth(&quot;adminuser&quot;,&quot;passwd&quot;)</span><br><span class=\"line\">db.adminCommand(&#123;setParameter: 1, internalQueryExecMaxBlockingSortBytes: 104857600&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>综合查询性能和服务器资源占用，推荐使用建立索引的方式。</p>\n<h3 id=\"其他需要注意的地方\"><a href=\"#其他需要注意的地方\" class=\"headerlink\" title=\"其他需要注意的地方\"></a>其他需要注意的地方</h3><p>除了sort, aggregate也存在内存限制，这是需要使用allowDiskUse参数，允许使用硬盘缓存中间数据。具体设置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.activity.aggregate(</span><br><span class=\"line\">\t\t[&#123; $unwind: &apos;$applyment&apos; &#125;,</span><br><span class=\"line\">\t\t&#123; $match: &#123; &apos;applyment.items.value&apos;: req.query.uid &#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $project : &#123;id:1,title: 1, &apos;applyment.approve&apos;: 1,&apos;applyment.createTime&apos;: 1, endDate: 1&#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $sort:&#123; &apos;applyment.createTime&apos;: -1 &#125;&#125;,</span><br><span class=\"line\">\t\t&#123; $skip:(result.pageNumber - 1) * result.pageSize&#125;,</span><br><span class=\"line\">\t\t&#123; $limit:result.pageSize&#125;],</span><br><span class=\"line\">\t\t&#123; allowDiskUse: true&#125;）</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于设置索引\"><a href=\"#关于设置索引\" class=\"headerlink\" title=\"关于设置索引\"></a>关于设置索引</h3><p>1、mongoDB 3.0开始ensureIndex被废弃，今后都仅仅是db.collection.createIndex的一个别名。<br>2、子对象的属性设置索引db.activity.createIndex({ “applyment.createTime”: -1})<br>3、数组内置顶位置设置索引db.activity.createIndex({ “applyment.items.0.value”: 1}) </p>\n"},{"title":"EffectiveJava--对象的通用方法","date":"2018-01-10T14:00:46.000Z","_content":"## 第8条，覆盖equals时请遵守通用约定#\n除非必要，不要重写equals方法。注意：\n- 类的每个实例本质上都是唯一的。这时候继承的Object的euqals方法是完全正确的，不需要重写\n- 不关心类是否提供“逻辑相等”功能。比如Random类。\n- 超类（父类）已经重写了quals，对于子类是适用的，无需重写。例如:AbstractSet——>Set，AbstractList——>List，AbstractMap——>Map\n- 类是私有的或者是包级私有的，并且确定它的equals方法永远不会被调用时。可以进行如下重写，防止意外调用：\n```java\n    @Override public boolean equals(Object o){\n        throw new AssertionError();\n    }\n```\n- 如果类具有自己特有的“逻辑相等概念”，而且超类还没有覆盖equals实现期望的行为，此时就需要重写equals方法。重写后被用做map的key，或者set的元素时才能表现出预期的行为。\n- 对于“每个值至多只存在一个对象”的“值类”，Object的euqals方法等同于逻辑相等。例如：枚举类型\nObject的euqals方法的规范：\n- 自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。\n- 对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。\n- 传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。\n- 一致性（consistent）。对于任何非null的引用值x和y，只要x，y没有被修改过，多次调用x.equals(y)，返回值一定是一致的。\n- 对于任何非null的引用值x，x.equals(null)必须返回false。\n如果不符合这些规范，程序会表现异常，甚至是崩溃，而且很难找到根源。\n在子类和超类，子类之间，以及同一个超类的子类之间，equals就很有可能出现问题。我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。推荐用复合的方式代替继承，每个属性分别equals。\n```java\n    public class ColorPoint {\n\t\t private Point point;\n\t\t private Color color;\n\t\t @Override public boolean equals(Object o){\n\t\t\t if(!(o instanceof ColorPoint)){\n\t\t\t\t return false;\n\t\t\t }\n\t\t\t ColorPoint cp = (ColorPoint)o;\n\t\t\t return cp.point.equals(point) && cp.color.equals(color);\n\t\t }\n\t }\n```\nequals实现时一般要使用instanceof进行类型检查，对null检查时必定返回false，所以没必要再检查是否为null。\n实现高质量equals方法的诀窍：\n- 使用==操作符检查“参数是否为这个对象的引用”。（出于性能优化方面考虑）\n- 使用instanceof操作符检查“参数是否为正确的类型”。所谓“正确的类型”一般是指类，如果接口改进了equals约定，允许实现该接口的类之间进行比较，就可以使用接口。例如Set、List、Map和Map.Entry。\n- 把参数转换成正确的类型。即转换成当前对象的类型。\n- 对该类中的每个关键域（属性），分别进行比较。除float和double的基本值类型，直接使用==比较。float使用Float.compare，double使用Double.compare。如果要检查数组中的每个元素，可以使用Arrays.equals。对于引用域，可能存在null为合法值，需要进行null检查。多个域的情况下，要优先比较开销低的域。\n- 要确保equals符合对称性，传递性和一致性。 \n- 不要企图让equals做过多的比较\n- 不要将equals方法的参数类型必须是Object，不能改成当前类。因为没有重写Object.equals，只是重载了。\n\n## 第9条：重写equals时必须重写hashCode#\n如果没有重写hashCode方法，就无法作为散列集合（例如：HashMap，HashSet和HashTable）的key。因为在取值时会优先通过hashCode比较。\n\n## 第10条，始终要重写toString#\ntoString在打印日志时，可以明确当前实例的重要信息，便于理解。而且要注意格式一旦确定就不要修改，格式要便于字符串解析，去除对应域的值。\n\n## 第11条，谨慎的重写clone#\n如果要支持clone需要实现Cloneable接口。\nclone方法就是一个构造器，你必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件。\n* 对于子类型的域直接使用Object.clone即可。\n* 对于可变的引用类型，可变引用类型的集合，就需要递归的调用clone。以避免伤害到原始对象。\n```java\n    @Override public Stack clone() {\n\t\t try{\n\t\t\t Stack result = (Stack) super.clone();\n\t\t\t result.date = date.clone();\n\t\t\t result.elements = elements.clone();\n             return result;\n\t\t } catch (CloneNotSupportedException e) {\n\t\t\t throw new AssertionError();\n\t\t }\n\t }\n```\n* clone架构与引用可变对象的final域的正常用法是不相兼容的，除非在clone对象和原始对象间可以安全的共享此可变对象。\n* 对于散列桶数组，需要遍历每个数据元素，进行深度拷贝进行clone。\n* clone不应该在构造的过程中，调用新对象中任何非final的方法，防止新旧对象不一致。\n* 对于有线程安全要求的类，clone方法要处理好同步。Object.clone没有同步。\n* 对于ID或者时间戳一类的值域，注意clone后进行修正。\n* 可以考虑使用拷贝构造器或者拷贝工厂方法，更加灵活的实现拷贝操作，比如带参数或者类型转换（比如用数组生成List对象）。\n* 如果不能提供良好保护的clone方法，他的子类就不可能实现Cloneable接口。\n\n编程通则：永远不要让客户去做任何类库能够替客户完成的事情。\n## 第12条，考虑实现Compareable接口#\ncompareTo的通用约定与equals类似。\n注意：HashSet实例中添加new BigDecimal(\"1.0\")和new BigDecimal(\"1.00\")，这个集合将含有两个元素。而如果把类型HashSet改成TreeSet，则只有一个元素。因为HashSet使用equals比较，TreeSet使用comapreTo比较。","source":"_posts/java/EffectiveJava--对象的通用方法.md","raw":"---\ntitle: EffectiveJava--对象的通用方法\ndate: 2018-01-10 22:00:46\ntags: [java]\n---\n## 第8条，覆盖equals时请遵守通用约定#\n除非必要，不要重写equals方法。注意：\n- 类的每个实例本质上都是唯一的。这时候继承的Object的euqals方法是完全正确的，不需要重写\n- 不关心类是否提供“逻辑相等”功能。比如Random类。\n- 超类（父类）已经重写了quals，对于子类是适用的，无需重写。例如:AbstractSet——>Set，AbstractList——>List，AbstractMap——>Map\n- 类是私有的或者是包级私有的，并且确定它的equals方法永远不会被调用时。可以进行如下重写，防止意外调用：\n```java\n    @Override public boolean equals(Object o){\n        throw new AssertionError();\n    }\n```\n- 如果类具有自己特有的“逻辑相等概念”，而且超类还没有覆盖equals实现期望的行为，此时就需要重写equals方法。重写后被用做map的key，或者set的元素时才能表现出预期的行为。\n- 对于“每个值至多只存在一个对象”的“值类”，Object的euqals方法等同于逻辑相等。例如：枚举类型\nObject的euqals方法的规范：\n- 自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。\n- 对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。\n- 传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。\n- 一致性（consistent）。对于任何非null的引用值x和y，只要x，y没有被修改过，多次调用x.equals(y)，返回值一定是一致的。\n- 对于任何非null的引用值x，x.equals(null)必须返回false。\n如果不符合这些规范，程序会表现异常，甚至是崩溃，而且很难找到根源。\n在子类和超类，子类之间，以及同一个超类的子类之间，equals就很有可能出现问题。我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。推荐用复合的方式代替继承，每个属性分别equals。\n```java\n    public class ColorPoint {\n\t\t private Point point;\n\t\t private Color color;\n\t\t @Override public boolean equals(Object o){\n\t\t\t if(!(o instanceof ColorPoint)){\n\t\t\t\t return false;\n\t\t\t }\n\t\t\t ColorPoint cp = (ColorPoint)o;\n\t\t\t return cp.point.equals(point) && cp.color.equals(color);\n\t\t }\n\t }\n```\nequals实现时一般要使用instanceof进行类型检查，对null检查时必定返回false，所以没必要再检查是否为null。\n实现高质量equals方法的诀窍：\n- 使用==操作符检查“参数是否为这个对象的引用”。（出于性能优化方面考虑）\n- 使用instanceof操作符检查“参数是否为正确的类型”。所谓“正确的类型”一般是指类，如果接口改进了equals约定，允许实现该接口的类之间进行比较，就可以使用接口。例如Set、List、Map和Map.Entry。\n- 把参数转换成正确的类型。即转换成当前对象的类型。\n- 对该类中的每个关键域（属性），分别进行比较。除float和double的基本值类型，直接使用==比较。float使用Float.compare，double使用Double.compare。如果要检查数组中的每个元素，可以使用Arrays.equals。对于引用域，可能存在null为合法值，需要进行null检查。多个域的情况下，要优先比较开销低的域。\n- 要确保equals符合对称性，传递性和一致性。 \n- 不要企图让equals做过多的比较\n- 不要将equals方法的参数类型必须是Object，不能改成当前类。因为没有重写Object.equals，只是重载了。\n\n## 第9条：重写equals时必须重写hashCode#\n如果没有重写hashCode方法，就无法作为散列集合（例如：HashMap，HashSet和HashTable）的key。因为在取值时会优先通过hashCode比较。\n\n## 第10条，始终要重写toString#\ntoString在打印日志时，可以明确当前实例的重要信息，便于理解。而且要注意格式一旦确定就不要修改，格式要便于字符串解析，去除对应域的值。\n\n## 第11条，谨慎的重写clone#\n如果要支持clone需要实现Cloneable接口。\nclone方法就是一个构造器，你必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件。\n* 对于子类型的域直接使用Object.clone即可。\n* 对于可变的引用类型，可变引用类型的集合，就需要递归的调用clone。以避免伤害到原始对象。\n```java\n    @Override public Stack clone() {\n\t\t try{\n\t\t\t Stack result = (Stack) super.clone();\n\t\t\t result.date = date.clone();\n\t\t\t result.elements = elements.clone();\n             return result;\n\t\t } catch (CloneNotSupportedException e) {\n\t\t\t throw new AssertionError();\n\t\t }\n\t }\n```\n* clone架构与引用可变对象的final域的正常用法是不相兼容的，除非在clone对象和原始对象间可以安全的共享此可变对象。\n* 对于散列桶数组，需要遍历每个数据元素，进行深度拷贝进行clone。\n* clone不应该在构造的过程中，调用新对象中任何非final的方法，防止新旧对象不一致。\n* 对于有线程安全要求的类，clone方法要处理好同步。Object.clone没有同步。\n* 对于ID或者时间戳一类的值域，注意clone后进行修正。\n* 可以考虑使用拷贝构造器或者拷贝工厂方法，更加灵活的实现拷贝操作，比如带参数或者类型转换（比如用数组生成List对象）。\n* 如果不能提供良好保护的clone方法，他的子类就不可能实现Cloneable接口。\n\n编程通则：永远不要让客户去做任何类库能够替客户完成的事情。\n## 第12条，考虑实现Compareable接口#\ncompareTo的通用约定与equals类似。\n注意：HashSet实例中添加new BigDecimal(\"1.0\")和new BigDecimal(\"1.00\")，这个集合将含有两个元素。而如果把类型HashSet改成TreeSet，则只有一个元素。因为HashSet使用equals比较，TreeSet使用comapreTo比较。","slug":"java/EffectiveJava--对象的通用方法","published":1,"updated":"2018-01-10T14:02:15.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3e000280cmed7lx2df","content":"<h2 id=\"第8条，覆盖equals时请遵守通用约定\"><a href=\"#第8条，覆盖equals时请遵守通用约定\" class=\"headerlink\" title=\"第8条，覆盖equals时请遵守通用约定\"></a>第8条，覆盖equals时请遵守通用约定</h2><p>除非必要，不要重写equals方法。注意：</p>\n<ul>\n<li>类的每个实例本质上都是唯一的。这时候继承的Object的euqals方法是完全正确的，不需要重写</li>\n<li>不关心类是否提供“逻辑相等”功能。比如Random类。</li>\n<li>超类（父类）已经重写了quals，对于子类是适用的，无需重写。例如:AbstractSet——&gt;Set，AbstractList——&gt;List，AbstractMap——&gt;Map</li>\n<li><p>类是私有的或者是包级私有的，并且确定它的equals方法永远不会被调用时。可以进行如下重写，防止意外调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果类具有自己特有的“逻辑相等概念”，而且超类还没有覆盖equals实现期望的行为，此时就需要重写equals方法。重写后被用做map的key，或者set的元素时才能表现出预期的行为。</p>\n</li>\n<li>对于“每个值至多只存在一个对象”的“值类”，Object的euqals方法等同于逻辑相等。例如：枚举类型<br>Object的euqals方法的规范：</li>\n<li>自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。</li>\n<li>对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li>\n<li>传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。</li>\n<li>一致性（consistent）。对于任何非null的引用值x和y，只要x，y没有被修改过，多次调用x.equals(y)，返回值一定是一致的。</li>\n<li>对于任何非null的引用值x，x.equals(null)必须返回false。<br>如果不符合这些规范，程序会表现异常，甚至是崩溃，而且很难找到根源。<br>在子类和超类，子类之间，以及同一个超类的子类之间，equals就很有可能出现问题。我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。推荐用复合的方式代替继承，每个属性分别equals。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> Point point;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint))&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t ColorPoint cp = (ColorPoint)o;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>equals实现时一般要使用instanceof进行类型检查，对null检查时必定返回false，所以没必要再检查是否为null。<br>实现高质量equals方法的诀窍：</p>\n<ul>\n<li>使用==操作符检查“参数是否为这个对象的引用”。（出于性能优化方面考虑）</li>\n<li>使用instanceof操作符检查“参数是否为正确的类型”。所谓“正确的类型”一般是指类，如果接口改进了equals约定，允许实现该接口的类之间进行比较，就可以使用接口。例如Set、List、Map和Map.Entry。</li>\n<li>把参数转换成正确的类型。即转换成当前对象的类型。</li>\n<li>对该类中的每个关键域（属性），分别进行比较。除float和double的基本值类型，直接使用==比较。float使用Float.compare，double使用Double.compare。如果要检查数组中的每个元素，可以使用Arrays.equals。对于引用域，可能存在null为合法值，需要进行null检查。多个域的情况下，要优先比较开销低的域。</li>\n<li>要确保equals符合对称性，传递性和一致性。 </li>\n<li>不要企图让equals做过多的比较</li>\n<li>不要将equals方法的参数类型必须是Object，不能改成当前类。因为没有重写Object.equals，只是重载了。</li>\n</ul>\n<h2 id=\"第9条：重写equals时必须重写hashCode\"><a href=\"#第9条：重写equals时必须重写hashCode\" class=\"headerlink\" title=\"第9条：重写equals时必须重写hashCode\"></a>第9条：重写equals时必须重写hashCode</h2><p>如果没有重写hashCode方法，就无法作为散列集合（例如：HashMap，HashSet和HashTable）的key。因为在取值时会优先通过hashCode比较。</p>\n<h2 id=\"第10条，始终要重写toString\"><a href=\"#第10条，始终要重写toString\" class=\"headerlink\" title=\"第10条，始终要重写toString\"></a>第10条，始终要重写toString</h2><p>toString在打印日志时，可以明确当前实例的重要信息，便于理解。而且要注意格式一旦确定就不要修改，格式要便于字符串解析，去除对应域的值。</p>\n<h2 id=\"第11条，谨慎的重写clone\"><a href=\"#第11条，谨慎的重写clone\" class=\"headerlink\" title=\"第11条，谨慎的重写clone\"></a>第11条，谨慎的重写clone</h2><p>如果要支持clone需要实现Cloneable接口。<br>clone方法就是一个构造器，你必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件。</p>\n<ul>\n<li>对于子类型的域直接使用Object.clone即可。</li>\n<li><p>对于可变的引用类型，可变引用类型的集合，就需要递归的调用clone。以避免伤害到原始对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Stack <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t Stack result = (Stack) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t result.date = date.clone();</span><br><span class=\"line\">\t result.elements = elements.clone();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clone架构与引用可变对象的final域的正常用法是不相兼容的，除非在clone对象和原始对象间可以安全的共享此可变对象。</p>\n</li>\n<li>对于散列桶数组，需要遍历每个数据元素，进行深度拷贝进行clone。</li>\n<li>clone不应该在构造的过程中，调用新对象中任何非final的方法，防止新旧对象不一致。</li>\n<li>对于有线程安全要求的类，clone方法要处理好同步。Object.clone没有同步。</li>\n<li>对于ID或者时间戳一类的值域，注意clone后进行修正。</li>\n<li>可以考虑使用拷贝构造器或者拷贝工厂方法，更加灵活的实现拷贝操作，比如带参数或者类型转换（比如用数组生成List对象）。</li>\n<li>如果不能提供良好保护的clone方法，他的子类就不可能实现Cloneable接口。</li>\n</ul>\n<p>编程通则：永远不要让客户去做任何类库能够替客户完成的事情。</p>\n<h2 id=\"第12条，考虑实现Compareable接口\"><a href=\"#第12条，考虑实现Compareable接口\" class=\"headerlink\" title=\"第12条，考虑实现Compareable接口\"></a>第12条，考虑实现Compareable接口</h2><p>compareTo的通用约定与equals类似。<br>注意：HashSet实例中添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，这个集合将含有两个元素。而如果把类型HashSet改成TreeSet，则只有一个元素。因为HashSet使用equals比较，TreeSet使用comapreTo比较。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第8条，覆盖equals时请遵守通用约定\"><a href=\"#第8条，覆盖equals时请遵守通用约定\" class=\"headerlink\" title=\"第8条，覆盖equals时请遵守通用约定\"></a>第8条，覆盖equals时请遵守通用约定</h2><p>除非必要，不要重写equals方法。注意：</p>\n<ul>\n<li>类的每个实例本质上都是唯一的。这时候继承的Object的euqals方法是完全正确的，不需要重写</li>\n<li>不关心类是否提供“逻辑相等”功能。比如Random类。</li>\n<li>超类（父类）已经重写了quals，对于子类是适用的，无需重写。例如:AbstractSet——&gt;Set，AbstractList——&gt;List，AbstractMap——&gt;Map</li>\n<li><p>类是私有的或者是包级私有的，并且确定它的equals方法永远不会被调用时。可以进行如下重写，防止意外调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果类具有自己特有的“逻辑相等概念”，而且超类还没有覆盖equals实现期望的行为，此时就需要重写equals方法。重写后被用做map的key，或者set的元素时才能表现出预期的行为。</p>\n</li>\n<li>对于“每个值至多只存在一个对象”的“值类”，Object的euqals方法等同于逻辑相等。例如：枚举类型<br>Object的euqals方法的规范：</li>\n<li>自反性（reflexive）。对于任何非null的引用值x，x.equals(x)必须返回true。</li>\n<li>对称性（symmetric）。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true。</li>\n<li>传递性（transitive）。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)必须返回true。</li>\n<li>一致性（consistent）。对于任何非null的引用值x和y，只要x，y没有被修改过，多次调用x.equals(y)，返回值一定是一致的。</li>\n<li>对于任何非null的引用值x，x.equals(null)必须返回false。<br>如果不符合这些规范，程序会表现异常，甚至是崩溃，而且很难找到根源。<br>在子类和超类，子类之间，以及同一个超类的子类之间，equals就很有可能出现问题。我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。推荐用复合的方式代替继承，每个属性分别equals。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> Point point;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> Color color;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">if</span>(!(o <span class=\"keyword\">instanceof</span> ColorPoint))&#123;</span><br><span class=\"line\">\t\t <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t ColorPoint cp = (ColorPoint)o;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>equals实现时一般要使用instanceof进行类型检查，对null检查时必定返回false，所以没必要再检查是否为null。<br>实现高质量equals方法的诀窍：</p>\n<ul>\n<li>使用==操作符检查“参数是否为这个对象的引用”。（出于性能优化方面考虑）</li>\n<li>使用instanceof操作符检查“参数是否为正确的类型”。所谓“正确的类型”一般是指类，如果接口改进了equals约定，允许实现该接口的类之间进行比较，就可以使用接口。例如Set、List、Map和Map.Entry。</li>\n<li>把参数转换成正确的类型。即转换成当前对象的类型。</li>\n<li>对该类中的每个关键域（属性），分别进行比较。除float和double的基本值类型，直接使用==比较。float使用Float.compare，double使用Double.compare。如果要检查数组中的每个元素，可以使用Arrays.equals。对于引用域，可能存在null为合法值，需要进行null检查。多个域的情况下，要优先比较开销低的域。</li>\n<li>要确保equals符合对称性，传递性和一致性。 </li>\n<li>不要企图让equals做过多的比较</li>\n<li>不要将equals方法的参数类型必须是Object，不能改成当前类。因为没有重写Object.equals，只是重载了。</li>\n</ul>\n<h2 id=\"第9条：重写equals时必须重写hashCode\"><a href=\"#第9条：重写equals时必须重写hashCode\" class=\"headerlink\" title=\"第9条：重写equals时必须重写hashCode\"></a>第9条：重写equals时必须重写hashCode</h2><p>如果没有重写hashCode方法，就无法作为散列集合（例如：HashMap，HashSet和HashTable）的key。因为在取值时会优先通过hashCode比较。</p>\n<h2 id=\"第10条，始终要重写toString\"><a href=\"#第10条，始终要重写toString\" class=\"headerlink\" title=\"第10条，始终要重写toString\"></a>第10条，始终要重写toString</h2><p>toString在打印日志时，可以明确当前实例的重要信息，便于理解。而且要注意格式一旦确定就不要修改，格式要便于字符串解析，去除对应域的值。</p>\n<h2 id=\"第11条，谨慎的重写clone\"><a href=\"#第11条，谨慎的重写clone\" class=\"headerlink\" title=\"第11条，谨慎的重写clone\"></a>第11条，谨慎的重写clone</h2><p>如果要支持clone需要实现Cloneable接口。<br>clone方法就是一个构造器，你必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件。</p>\n<ul>\n<li>对于子类型的域直接使用Object.clone即可。</li>\n<li><p>对于可变的引用类型，可变引用类型的集合，就需要递归的调用clone。以避免伤害到原始对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Stack <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">\t Stack result = (Stack) <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t result.date = date.clone();</span><br><span class=\"line\">\t result.elements = elements.clone();</span><br><span class=\"line\">           <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>clone架构与引用可变对象的final域的正常用法是不相兼容的，除非在clone对象和原始对象间可以安全的共享此可变对象。</p>\n</li>\n<li>对于散列桶数组，需要遍历每个数据元素，进行深度拷贝进行clone。</li>\n<li>clone不应该在构造的过程中，调用新对象中任何非final的方法，防止新旧对象不一致。</li>\n<li>对于有线程安全要求的类，clone方法要处理好同步。Object.clone没有同步。</li>\n<li>对于ID或者时间戳一类的值域，注意clone后进行修正。</li>\n<li>可以考虑使用拷贝构造器或者拷贝工厂方法，更加灵活的实现拷贝操作，比如带参数或者类型转换（比如用数组生成List对象）。</li>\n<li>如果不能提供良好保护的clone方法，他的子类就不可能实现Cloneable接口。</li>\n</ul>\n<p>编程通则：永远不要让客户去做任何类库能够替客户完成的事情。</p>\n<h2 id=\"第12条，考虑实现Compareable接口\"><a href=\"#第12条，考虑实现Compareable接口\" class=\"headerlink\" title=\"第12条，考虑实现Compareable接口\"></a>第12条，考虑实现Compareable接口</h2><p>compareTo的通用约定与equals类似。<br>注意：HashSet实例中添加new BigDecimal(“1.0”)和new BigDecimal(“1.00”)，这个集合将含有两个元素。而如果把类型HashSet改成TreeSet，则只有一个元素。因为HashSet使用equals比较，TreeSet使用comapreTo比较。</p>\n"},{"title":"EffectiveJava--对象的通用方法","date":"2018-01-10T14:00:46.000Z","_content":"## 第1条，考虑用静态工厂方法代替构造器\n### 优点:\n- 有名称，作用更清晰\n- 可以实现单例\n- 可以返回原类型的任何子类型\n- 创建参数化实例对象时，代码更简洁\n\n### 缺点:\n- 类如果不含公有或者受保护的构造器，就不能被子类化  \n- 与其他静态方法没区别\n\n## 第2条，遇到多个构造器参数时考虑用建造者(builder)模式  \n构造器遇到多个参数组合的时候，需要定义不通组合的构造器，复杂而且顺序容易弄错。使用建造者模式就可以解决此类问题。  \n优点:灵活链式构建  \n缺点:需创建构建器，有开销  \n## 第3条，用私有构造器或者枚举类型强化Singleton属性  \n序列化，反射安全？  \n单元素的枚举类型已经成为实现Sibgleton的最佳方法。  \n## 第4条，通过私有构造器强化不可实例化的能力  \n不需要被实例化的类，添加私有构造函数，并且在构造函数中抛出异常，来避免被实例化。  \n```java\n    public class UtilityClass{\n\t\tprivate UtilityClass(){\n\t\t\tthrow new AssertionError();\n\t\t}\n\t}\n```\n## 第5条，避免创建不必要的对象  \n如下情况可以不创建对象，示例如下：\n1、\"\"字符串本身就是一个String对象，再new会重复创建String对象。 \n```java\n    String s = new String(\"this is a wrong\");//bad  \n    String s = \"good\";//good  \n```\n2、提供静态方法和构造函数的不可变类，静态方法优于创建对象  \n```java\n    Boolean constructObj = new Boolean(\"true\");//bad  \n    Boolean staticMethodObj = Boolean.valueOf(\"true\");//good  \n```\n3、作为常量使用的可变类。比如作为固定开始日期的Date，只需要实例化一次即可重复使用  \n4、优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱  \n```java\n    Long sum = 0L;//bad  \n    long sum = 0L;//good  \n```\n不是不要创建对象，小对象的开销很小。  \n重量级的对象才需要维护资源池，例如数据库连接。  \n## 第6条，消除过期的对象引用  \n例如，Stack中pop的对象引用，需要主动释放内存,同时也能尽早暴漏错误调用  \n```java\n    public Object pop(){\n        if(size == 0)\n            throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = bull; //释放过期的引用\n        return result;\n    }\n```\n清空对象引用应该是一种例外，而不是一种规范行为。通过再尽量小的作用域内，变量及时结束其生命周期来释放。  \n关于内存泄露的来源：  \n- 类自己管理的内存，程序猿需要关注其释放\n- 缓存，可以使用WeakHashMap代替缓存，需要定期清理，或者类似LinkedHashMap的removeEldestEntry方法清理。\n- 监听器和其他回调。确保回调立即回收的方法保存他们的弱引用。例如保存成WeakHashMap的键。 \n\n## 第7条，避免使用终结方法(finalizer)#\nfinalizer的缺点：\n- 不能保证会被及时的执行，间隔是任意的。\n- 在不同JVM平台表现不同。\n- finalizer线程的优先级比程序中其他线程低很多，会导致队列积压，内存溢出。\n- finalizer可能不会被执行。\n需要注意的地方：\n- 所以不应该依赖finalizer来更新重要的持久状态。  \n- System.gc和System.runFinalization可以增加finalizer被执行的机会，单不能保证一定被执行。  \n- finalizer中抛出的异常如果未捕获，该异常可能被忽略（警告也不会被打印），并且finalizer也会终止。继续使用此对象时会产生不确定的结果。\n- 使用finalizer会导致对象的创建和销毁时间大幅增加，甚至几百倍。\n- 建议定义一个显式的终止方法释放资源。例如InputStream/FileOutputStream/Connection的close等。本地对等体需要finalizer或者显式的终止方法才能释放，GC不会自动释放。对于需要及时释放资源的情况，应该用显式的终止方法来释放。\n- 显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止\n- 子类的finalizer，需要在try-finally的finally中调用超类的finalizer。\n```java\n    @Override protected void finalize() throws Throwable {\n\t\t try{\n\t\t\t //Finalize subClass state\n\t\t } finally {\n\t\t\t super.finalize();\n\t\t }\n    } \n```\n- 可以考虑使用匿名类来充当总结方法守卫者，确保能够调用finalizer.因为成员变量会被主动释放，从而触发finalizer。\n```java\n    private final Object finalizerGuardian = new Object(){\n\t\t @Override protected void finalize() throws Throwable {\n\t\t\t super.finalize();\n\t    } \n\t };\n```","source":"_posts/java/EffectiveJava--创建和销毁对象.md","raw":"---\ntitle: EffectiveJava--对象的通用方法\ndate: 2018-01-10 22:00:46\ntags: [java]\n---\n## 第1条，考虑用静态工厂方法代替构造器\n### 优点:\n- 有名称，作用更清晰\n- 可以实现单例\n- 可以返回原类型的任何子类型\n- 创建参数化实例对象时，代码更简洁\n\n### 缺点:\n- 类如果不含公有或者受保护的构造器，就不能被子类化  \n- 与其他静态方法没区别\n\n## 第2条，遇到多个构造器参数时考虑用建造者(builder)模式  \n构造器遇到多个参数组合的时候，需要定义不通组合的构造器，复杂而且顺序容易弄错。使用建造者模式就可以解决此类问题。  \n优点:灵活链式构建  \n缺点:需创建构建器，有开销  \n## 第3条，用私有构造器或者枚举类型强化Singleton属性  \n序列化，反射安全？  \n单元素的枚举类型已经成为实现Sibgleton的最佳方法。  \n## 第4条，通过私有构造器强化不可实例化的能力  \n不需要被实例化的类，添加私有构造函数，并且在构造函数中抛出异常，来避免被实例化。  \n```java\n    public class UtilityClass{\n\t\tprivate UtilityClass(){\n\t\t\tthrow new AssertionError();\n\t\t}\n\t}\n```\n## 第5条，避免创建不必要的对象  \n如下情况可以不创建对象，示例如下：\n1、\"\"字符串本身就是一个String对象，再new会重复创建String对象。 \n```java\n    String s = new String(\"this is a wrong\");//bad  \n    String s = \"good\";//good  \n```\n2、提供静态方法和构造函数的不可变类，静态方法优于创建对象  \n```java\n    Boolean constructObj = new Boolean(\"true\");//bad  \n    Boolean staticMethodObj = Boolean.valueOf(\"true\");//good  \n```\n3、作为常量使用的可变类。比如作为固定开始日期的Date，只需要实例化一次即可重复使用  \n4、优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱  \n```java\n    Long sum = 0L;//bad  \n    long sum = 0L;//good  \n```\n不是不要创建对象，小对象的开销很小。  \n重量级的对象才需要维护资源池，例如数据库连接。  \n## 第6条，消除过期的对象引用  \n例如，Stack中pop的对象引用，需要主动释放内存,同时也能尽早暴漏错误调用  \n```java\n    public Object pop(){\n        if(size == 0)\n            throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = bull; //释放过期的引用\n        return result;\n    }\n```\n清空对象引用应该是一种例外，而不是一种规范行为。通过再尽量小的作用域内，变量及时结束其生命周期来释放。  \n关于内存泄露的来源：  \n- 类自己管理的内存，程序猿需要关注其释放\n- 缓存，可以使用WeakHashMap代替缓存，需要定期清理，或者类似LinkedHashMap的removeEldestEntry方法清理。\n- 监听器和其他回调。确保回调立即回收的方法保存他们的弱引用。例如保存成WeakHashMap的键。 \n\n## 第7条，避免使用终结方法(finalizer)#\nfinalizer的缺点：\n- 不能保证会被及时的执行，间隔是任意的。\n- 在不同JVM平台表现不同。\n- finalizer线程的优先级比程序中其他线程低很多，会导致队列积压，内存溢出。\n- finalizer可能不会被执行。\n需要注意的地方：\n- 所以不应该依赖finalizer来更新重要的持久状态。  \n- System.gc和System.runFinalization可以增加finalizer被执行的机会，单不能保证一定被执行。  \n- finalizer中抛出的异常如果未捕获，该异常可能被忽略（警告也不会被打印），并且finalizer也会终止。继续使用此对象时会产生不确定的结果。\n- 使用finalizer会导致对象的创建和销毁时间大幅增加，甚至几百倍。\n- 建议定义一个显式的终止方法释放资源。例如InputStream/FileOutputStream/Connection的close等。本地对等体需要finalizer或者显式的终止方法才能释放，GC不会自动释放。对于需要及时释放资源的情况，应该用显式的终止方法来释放。\n- 显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止\n- 子类的finalizer，需要在try-finally的finally中调用超类的finalizer。\n```java\n    @Override protected void finalize() throws Throwable {\n\t\t try{\n\t\t\t //Finalize subClass state\n\t\t } finally {\n\t\t\t super.finalize();\n\t\t }\n    } \n```\n- 可以考虑使用匿名类来充当总结方法守卫者，确保能够调用finalizer.因为成员变量会被主动释放，从而触发finalizer。\n```java\n    private final Object finalizerGuardian = new Object(){\n\t\t @Override protected void finalize() throws Throwable {\n\t\t\t super.finalize();\n\t    } \n\t };\n```","slug":"java/EffectiveJava--创建和销毁对象","published":1,"updated":"2018-01-10T14:04:09.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3i000480cm4oq5rapj","content":"<h2 id=\"第1条，考虑用静态工厂方法代替构造器\"><a href=\"#第1条，考虑用静态工厂方法代替构造器\" class=\"headerlink\" title=\"第1条，考虑用静态工厂方法代替构造器\"></a>第1条，考虑用静态工厂方法代替构造器</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>有名称，作用更清晰</li>\n<li>可以实现单例</li>\n<li>可以返回原类型的任何子类型</li>\n<li>创建参数化实例对象时，代码更简洁</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3><ul>\n<li>类如果不含公有或者受保护的构造器，就不能被子类化  </li>\n<li>与其他静态方法没区别</li>\n</ul>\n<h2 id=\"第2条，遇到多个构造器参数时考虑用建造者-builder-模式\"><a href=\"#第2条，遇到多个构造器参数时考虑用建造者-builder-模式\" class=\"headerlink\" title=\"第2条，遇到多个构造器参数时考虑用建造者(builder)模式\"></a>第2条，遇到多个构造器参数时考虑用建造者(builder)模式</h2><p>构造器遇到多个参数组合的时候，需要定义不通组合的构造器，复杂而且顺序容易弄错。使用建造者模式就可以解决此类问题。<br>优点:灵活链式构建<br>缺点:需创建构建器，有开销  </p>\n<h2 id=\"第3条，用私有构造器或者枚举类型强化Singleton属性\"><a href=\"#第3条，用私有构造器或者枚举类型强化Singleton属性\" class=\"headerlink\" title=\"第3条，用私有构造器或者枚举类型强化Singleton属性\"></a>第3条，用私有构造器或者枚举类型强化Singleton属性</h2><p>序列化，反射安全？<br>单元素的枚举类型已经成为实现Sibgleton的最佳方法。  </p>\n<h2 id=\"第4条，通过私有构造器强化不可实例化的能力\"><a href=\"#第4条，通过私有构造器强化不可实例化的能力\" class=\"headerlink\" title=\"第4条，通过私有构造器强化不可实例化的能力\"></a>第4条，通过私有构造器强化不可实例化的能力</h2><p>不需要被实例化的类，添加私有构造函数，并且在构造函数中抛出异常，来避免被实例化。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UtilityClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">UtilityClass</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第5条，避免创建不必要的对象\"><a href=\"#第5条，避免创建不必要的对象\" class=\"headerlink\" title=\"第5条，避免创建不必要的对象\"></a>第5条，避免创建不必要的对象</h2><p>如下情况可以不创建对象，示例如下：<br>1、””字符串本身就是一个String对象，再new会重复创建String对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"this is a wrong\"</span>);<span class=\"comment\">//bad  </span></span><br><span class=\"line\">String s = <span class=\"string\">\"good\"</span>;<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>2、提供静态方法和构造函数的不可变类，静态方法优于创建对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean constructObj = <span class=\"keyword\">new</span> Boolean(<span class=\"string\">\"true\"</span>);<span class=\"comment\">//bad  </span></span><br><span class=\"line\">Boolean staticMethodObj = Boolean.valueOf(<span class=\"string\">\"true\"</span>);<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>3、作为常量使用的可变类。比如作为固定开始日期的Date，只需要实例化一次即可重复使用<br>4、优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long sum = <span class=\"number\">0L</span>;<span class=\"comment\">//bad  </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> sum = <span class=\"number\">0L</span>;<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>不是不要创建对象，小对象的开销很小。<br>重量级的对象才需要维护资源池，例如数据库连接。  </p>\n<h2 id=\"第6条，消除过期的对象引用\"><a href=\"#第6条，消除过期的对象引用\" class=\"headerlink\" title=\"第6条，消除过期的对象引用\"></a>第6条，消除过期的对象引用</h2><p>例如，Stack中pop的对象引用，需要主动释放内存,同时也能尽早暴漏错误调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">pop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EmptyStackException();</span><br><span class=\"line\">    Object result = elements[--size];</span><br><span class=\"line\">    elements[size] = bull; <span class=\"comment\">//释放过期的引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>清空对象引用应该是一种例外，而不是一种规范行为。通过再尽量小的作用域内，变量及时结束其生命周期来释放。<br>关于内存泄露的来源：  </p>\n<ul>\n<li>类自己管理的内存，程序猿需要关注其释放</li>\n<li>缓存，可以使用WeakHashMap代替缓存，需要定期清理，或者类似LinkedHashMap的removeEldestEntry方法清理。</li>\n<li>监听器和其他回调。确保回调立即回收的方法保存他们的弱引用。例如保存成WeakHashMap的键。 </li>\n</ul>\n<h2 id=\"第7条，避免使用终结方法-finalizer\"><a href=\"#第7条，避免使用终结方法-finalizer\" class=\"headerlink\" title=\"第7条，避免使用终结方法(finalizer)\"></a>第7条，避免使用终结方法(finalizer)</h2><p>finalizer的缺点：</p>\n<ul>\n<li>不能保证会被及时的执行，间隔是任意的。</li>\n<li>在不同JVM平台表现不同。</li>\n<li>finalizer线程的优先级比程序中其他线程低很多，会导致队列积压，内存溢出。</li>\n<li>finalizer可能不会被执行。<br>需要注意的地方：</li>\n<li>所以不应该依赖finalizer来更新重要的持久状态。  </li>\n<li>System.gc和System.runFinalization可以增加finalizer被执行的机会，单不能保证一定被执行。  </li>\n<li>finalizer中抛出的异常如果未捕获，该异常可能被忽略（警告也不会被打印），并且finalizer也会终止。继续使用此对象时会产生不确定的结果。</li>\n<li>使用finalizer会导致对象的创建和销毁时间大幅增加，甚至几百倍。</li>\n<li>建议定义一个显式的终止方法释放资源。例如InputStream/FileOutputStream/Connection的close等。本地对等体需要finalizer或者显式的终止方法才能释放，GC不会自动释放。对于需要及时释放资源的情况，应该用显式的终止方法来释放。</li>\n<li>显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止</li>\n<li><p>子类的finalizer，需要在try-finally的finally中调用超类的finalizer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//Finalize subClass state</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以考虑使用匿名类来充当总结方法守卫者，确保能够调用finalizer.因为成员变量会被主动释放，从而触发finalizer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object finalizerGuardian = <span class=\"keyword\">new</span> Object()&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第1条，考虑用静态工厂方法代替构造器\"><a href=\"#第1条，考虑用静态工厂方法代替构造器\" class=\"headerlink\" title=\"第1条，考虑用静态工厂方法代替构造器\"></a>第1条，考虑用静态工厂方法代替构造器</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h3><ul>\n<li>有名称，作用更清晰</li>\n<li>可以实现单例</li>\n<li>可以返回原类型的任何子类型</li>\n<li>创建参数化实例对象时，代码更简洁</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点:\"></a>缺点:</h3><ul>\n<li>类如果不含公有或者受保护的构造器，就不能被子类化  </li>\n<li>与其他静态方法没区别</li>\n</ul>\n<h2 id=\"第2条，遇到多个构造器参数时考虑用建造者-builder-模式\"><a href=\"#第2条，遇到多个构造器参数时考虑用建造者-builder-模式\" class=\"headerlink\" title=\"第2条，遇到多个构造器参数时考虑用建造者(builder)模式\"></a>第2条，遇到多个构造器参数时考虑用建造者(builder)模式</h2><p>构造器遇到多个参数组合的时候，需要定义不通组合的构造器，复杂而且顺序容易弄错。使用建造者模式就可以解决此类问题。<br>优点:灵活链式构建<br>缺点:需创建构建器，有开销  </p>\n<h2 id=\"第3条，用私有构造器或者枚举类型强化Singleton属性\"><a href=\"#第3条，用私有构造器或者枚举类型强化Singleton属性\" class=\"headerlink\" title=\"第3条，用私有构造器或者枚举类型强化Singleton属性\"></a>第3条，用私有构造器或者枚举类型强化Singleton属性</h2><p>序列化，反射安全？<br>单元素的枚举类型已经成为实现Sibgleton的最佳方法。  </p>\n<h2 id=\"第4条，通过私有构造器强化不可实例化的能力\"><a href=\"#第4条，通过私有构造器强化不可实例化的能力\" class=\"headerlink\" title=\"第4条，通过私有构造器强化不可实例化的能力\"></a>第4条，通过私有构造器强化不可实例化的能力</h2><p>不需要被实例化的类，添加私有构造函数，并且在构造函数中抛出异常，来避免被实例化。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UtilityClass</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">UtilityClass</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第5条，避免创建不必要的对象\"><a href=\"#第5条，避免创建不必要的对象\" class=\"headerlink\" title=\"第5条，避免创建不必要的对象\"></a>第5条，避免创建不必要的对象</h2><p>如下情况可以不创建对象，示例如下：<br>1、””字符串本身就是一个String对象，再new会重复创建String对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> String(<span class=\"string\">\"this is a wrong\"</span>);<span class=\"comment\">//bad  </span></span><br><span class=\"line\">String s = <span class=\"string\">\"good\"</span>;<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>2、提供静态方法和构造函数的不可变类，静态方法优于创建对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Boolean constructObj = <span class=\"keyword\">new</span> Boolean(<span class=\"string\">\"true\"</span>);<span class=\"comment\">//bad  </span></span><br><span class=\"line\">Boolean staticMethodObj = Boolean.valueOf(<span class=\"string\">\"true\"</span>);<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>3、作为常量使用的可变类。比如作为固定开始日期的Date，只需要实例化一次即可重复使用<br>4、优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long sum = <span class=\"number\">0L</span>;<span class=\"comment\">//bad  </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> sum = <span class=\"number\">0L</span>;<span class=\"comment\">//good</span></span><br></pre></td></tr></table></figure></p>\n<p>不是不要创建对象，小对象的开销很小。<br>重量级的对象才需要维护资源池，例如数据库连接。  </p>\n<h2 id=\"第6条，消除过期的对象引用\"><a href=\"#第6条，消除过期的对象引用\" class=\"headerlink\" title=\"第6条，消除过期的对象引用\"></a>第6条，消除过期的对象引用</h2><p>例如，Stack中pop的对象引用，需要主动释放内存,同时也能尽早暴漏错误调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">pop</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> EmptyStackException();</span><br><span class=\"line\">    Object result = elements[--size];</span><br><span class=\"line\">    elements[size] = bull; <span class=\"comment\">//释放过期的引用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>清空对象引用应该是一种例外，而不是一种规范行为。通过再尽量小的作用域内，变量及时结束其生命周期来释放。<br>关于内存泄露的来源：  </p>\n<ul>\n<li>类自己管理的内存，程序猿需要关注其释放</li>\n<li>缓存，可以使用WeakHashMap代替缓存，需要定期清理，或者类似LinkedHashMap的removeEldestEntry方法清理。</li>\n<li>监听器和其他回调。确保回调立即回收的方法保存他们的弱引用。例如保存成WeakHashMap的键。 </li>\n</ul>\n<h2 id=\"第7条，避免使用终结方法-finalizer\"><a href=\"#第7条，避免使用终结方法-finalizer\" class=\"headerlink\" title=\"第7条，避免使用终结方法(finalizer)\"></a>第7条，避免使用终结方法(finalizer)</h2><p>finalizer的缺点：</p>\n<ul>\n<li>不能保证会被及时的执行，间隔是任意的。</li>\n<li>在不同JVM平台表现不同。</li>\n<li>finalizer线程的优先级比程序中其他线程低很多，会导致队列积压，内存溢出。</li>\n<li>finalizer可能不会被执行。<br>需要注意的地方：</li>\n<li>所以不应该依赖finalizer来更新重要的持久状态。  </li>\n<li>System.gc和System.runFinalization可以增加finalizer被执行的机会，单不能保证一定被执行。  </li>\n<li>finalizer中抛出的异常如果未捕获，该异常可能被忽略（警告也不会被打印），并且finalizer也会终止。继续使用此对象时会产生不确定的结果。</li>\n<li>使用finalizer会导致对象的创建和销毁时间大幅增加，甚至几百倍。</li>\n<li>建议定义一个显式的终止方法释放资源。例如InputStream/FileOutputStream/Connection的close等。本地对等体需要finalizer或者显式的终止方法才能释放，GC不会自动释放。对于需要及时释放资源的情况，应该用显式的终止方法来释放。</li>\n<li>显式的终止方法通常与try-finally结构结合起来使用，以确保及时终止</li>\n<li><p>子类的finalizer，需要在try-finally的finally中调用超类的finalizer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//Finalize subClass state</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以考虑使用匿名类来充当总结方法守卫者，确保能够调用finalizer.因为成员变量会被主动释放，从而触发finalizer。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object finalizerGuardian = <span class=\"keyword\">new</span> Object()&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">finalize</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">\t <span class=\"keyword\">super</span>.finalize();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"非maven的jar包怎么引入maven工程","date":"2018-01-10T13:41:23.000Z","_content":"前几天因为业务需要，引入了一个其他部门的jar包。不是Maven工程构建的，也就没有pom文件。这里记录下引入的过程，以备今后参考。  \n1. maven仓库中存在的jar包\n可以直接在pom文件中添加依赖。但是问题来了，只有jar包，怎么知道groupId和artifactId呢？下面我就用实例告诉大家，怎么引入。比如依赖一个json-lib-2.2.1.jar。只需要在[](http://mvnrepository.com) 网站上查询这个jar包。然后在版本列表中，点击具体需要的版本。\n![mvn1-1.jpg](http://upload-images.jianshu.io/upload_images/4944427-0788fe4e3ca5beb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n进入具体页面后，拷贝需要的依赖配置内容，复制到maven\n![mvn1-2.jpg](http://upload-images.jianshu.io/upload_images/4944427-ed06810e63b8067a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n复制maven的配置描述，拷贝到pom文件里即可。\n2. maven仓库里不存在的jar包  \n可以自己在本地手工添加的方式解决。例如，haha-1.0.jar。我们设置groupId为com.my.test，artifactId为haha。版本为1.0。\na.  maven添加本地jar包\n配置好maven环境，有些使用eclipse的童鞋，可能没有安装过maven，会导致无法执行，需要自己配置maven环境。  \n执行如下命令：\nmvn install:install-file -Dfile=E:\\work\\haha-1.0.jar -DgroupId=com.my.test -DartifactId=haha -Dversion=1.0 -Dpackaging=jar\nb. 手工创建目录\n在pom文件里添加配置信息：  \n        <dependency>\n            <groupId>commons-httpclient</groupId>\n            <artifactId>commons-httpclient</artifactId>\n            <version>3.1</version>\n        </dependency>\n创建好目录\\.m2\\repository\\com\\my\\test\\haha\\1.0。把haha-1.0.jar文件复制过来，同时新建haha-1.0.jar.pom。参考maven从仓库下载的jar包里相同的文件，复制里面的内容，修改一下groupId，artifactId和version信息即可。执行完这些后，再更新和编辑就可以解决了。","source":"_posts/java/非maven的jar包怎么引入maven工程.md","raw":"---\ntitle: 非maven的jar包怎么引入maven工程\ndate: 2018-01-10 21:41:23\ntags: [java]\n---\n前几天因为业务需要，引入了一个其他部门的jar包。不是Maven工程构建的，也就没有pom文件。这里记录下引入的过程，以备今后参考。  \n1. maven仓库中存在的jar包\n可以直接在pom文件中添加依赖。但是问题来了，只有jar包，怎么知道groupId和artifactId呢？下面我就用实例告诉大家，怎么引入。比如依赖一个json-lib-2.2.1.jar。只需要在[](http://mvnrepository.com) 网站上查询这个jar包。然后在版本列表中，点击具体需要的版本。\n![mvn1-1.jpg](http://upload-images.jianshu.io/upload_images/4944427-0788fe4e3ca5beb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n进入具体页面后，拷贝需要的依赖配置内容，复制到maven\n![mvn1-2.jpg](http://upload-images.jianshu.io/upload_images/4944427-ed06810e63b8067a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n复制maven的配置描述，拷贝到pom文件里即可。\n2. maven仓库里不存在的jar包  \n可以自己在本地手工添加的方式解决。例如，haha-1.0.jar。我们设置groupId为com.my.test，artifactId为haha。版本为1.0。\na.  maven添加本地jar包\n配置好maven环境，有些使用eclipse的童鞋，可能没有安装过maven，会导致无法执行，需要自己配置maven环境。  \n执行如下命令：\nmvn install:install-file -Dfile=E:\\work\\haha-1.0.jar -DgroupId=com.my.test -DartifactId=haha -Dversion=1.0 -Dpackaging=jar\nb. 手工创建目录\n在pom文件里添加配置信息：  \n        <dependency>\n            <groupId>commons-httpclient</groupId>\n            <artifactId>commons-httpclient</artifactId>\n            <version>3.1</version>\n        </dependency>\n创建好目录\\.m2\\repository\\com\\my\\test\\haha\\1.0。把haha-1.0.jar文件复制过来，同时新建haha-1.0.jar.pom。参考maven从仓库下载的jar包里相同的文件，复制里面的内容，修改一下groupId，artifactId和version信息即可。执行完这些后，再更新和编辑就可以解决了。","slug":"java/非maven的jar包怎么引入maven工程","published":1,"updated":"2018-01-10T13:42:39.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3i000580cmls7naqjk","content":"<p>前几天因为业务需要，引入了一个其他部门的jar包。不是Maven工程构建的，也就没有pom文件。这里记录下引入的过程，以备今后参考。  </p>\n<ol>\n<li>maven仓库中存在的jar包<br>可以直接在pom文件中添加依赖。但是问题来了，只有jar包，怎么知道groupId和artifactId呢？下面我就用实例告诉大家，怎么引入。比如依赖一个json-lib-2.2.1.jar。只需要在<a href=\"http://mvnrepository.com\" target=\"_blank\" rel=\"noopener\"></a> 网站上查询这个jar包。然后在版本列表中，点击具体需要的版本。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-0788fe4e3ca5beb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mvn1-1.jpg\"><br>进入具体页面后，拷贝需要的依赖配置内容，复制到maven<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-ed06810e63b8067a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mvn1-2.jpg\"><br>复制maven的配置描述，拷贝到pom文件里即可。</li>\n<li>maven仓库里不存在的jar包<br>可以自己在本地手工添加的方式解决。例如，haha-1.0.jar。我们设置groupId为com.my.test，artifactId为haha。版本为1.0。<br>a.  maven添加本地jar包<br>配置好maven环境，有些使用eclipse的童鞋，可能没有安装过maven，会导致无法执行，需要自己配置maven环境。<br>执行如下命令：<br>mvn install:install-file -Dfile=E:\\work\\haha-1.0.jar -DgroupId=com.my.test -DartifactId=haha -Dversion=1.0 -Dpackaging=jar<br>b. 手工创建目录<br>在pom文件里添加配置信息：  <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;\n    &lt;version&gt;3.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>创建好目录.m2\\repository\\com\\my\\test\\haha\\1.0。把haha-1.0.jar文件复制过来，同时新建haha-1.0.jar.pom。参考maven从仓库下载的jar包里相同的文件，复制里面的内容，修改一下groupId，artifactId和version信息即可。执行完这些后，再更新和编辑就可以解决了。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>前几天因为业务需要，引入了一个其他部门的jar包。不是Maven工程构建的，也就没有pom文件。这里记录下引入的过程，以备今后参考。  </p>\n<ol>\n<li>maven仓库中存在的jar包<br>可以直接在pom文件中添加依赖。但是问题来了，只有jar包，怎么知道groupId和artifactId呢？下面我就用实例告诉大家，怎么引入。比如依赖一个json-lib-2.2.1.jar。只需要在<a href=\"http://mvnrepository.com\" target=\"_blank\" rel=\"noopener\"></a> 网站上查询这个jar包。然后在版本列表中，点击具体需要的版本。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-0788fe4e3ca5beb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mvn1-1.jpg\"><br>进入具体页面后，拷贝需要的依赖配置内容，复制到maven<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-ed06810e63b8067a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mvn1-2.jpg\"><br>复制maven的配置描述，拷贝到pom文件里即可。</li>\n<li>maven仓库里不存在的jar包<br>可以自己在本地手工添加的方式解决。例如，haha-1.0.jar。我们设置groupId为com.my.test，artifactId为haha。版本为1.0。<br>a.  maven添加本地jar包<br>配置好maven环境，有些使用eclipse的童鞋，可能没有安装过maven，会导致无法执行，需要自己配置maven环境。<br>执行如下命令：<br>mvn install:install-file -Dfile=E:\\work\\haha-1.0.jar -DgroupId=com.my.test -DartifactId=haha -Dversion=1.0 -Dpackaging=jar<br>b. 手工创建目录<br>在pom文件里添加配置信息：  <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;\n    &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;\n    &lt;version&gt;3.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>创建好目录.m2\\repository\\com\\my\\test\\haha\\1.0。把haha-1.0.jar文件复制过来，同时新建haha-1.0.jar.pom。参考maven从仓库下载的jar包里相同的文件，复制里面的内容，修改一下groupId，artifactId和version信息即可。执行完这些后，再更新和编辑就可以解决了。</li>\n</ol>\n"},{"title":"也谈TDD","date":"2018-01-10T13:33:51.000Z","_content":"&nbsp;&nbsp;&nbsp;&nbsp;最近在组织项目成员的能力提升，不可避免的就进入了TDD这个话题。对于TDD，已经成为很多公司员工入职的专业知识培训课程。网上关于TDD的各种文章和讨论也很多，但是感觉大家都是望文生义，都是先写测试用例，再写代码。  \n&nbsp;&nbsp;&nbsp;&nbsp;可能有人会说TDD就是“Test Driven Development”，就是测试驱动开发。就是写测试用例，然后再写代码。我承认，书里是这么写的。大家也是这么理解，然后去实践的。实际效果如何呢，就我了解的情况，大家对这个都很纠结。很多都在说，我先写几行代码，然后再写用例为啥就不行了呢？难道真是缺少仪式感吗？  \n&nbsp;&nbsp;&nbsp;&nbsp;那么我先说说，我最近的思考。TDD方式，实际上是关注点驱动开发，或者说规则驱动开发。我要实现一个关注点/规则，我就先一条用例来验证这个关注点/规则，然后去完成这个关注点/规则的代码。如果按照这个思路去思考，我每次实现一个关注点/规则，我先写用例后写代码，或者先写代码再写用例。每次都是围绕着一个关注点/规则，是否先后顺序就显得不那么重要了。关键是每次聚焦于一个关注点/规则，有测试用例保证这个关注点/规则的准确性。那么就可以放心的去实现下一个关注点/规则，并且保证整个功能的准确了。  \n&nbsp;&nbsp;&nbsp;&nbsp;以上是我对于TDD的最新理解和思考。各位看过后是否也对TDD也有了新的理解了呢？","source":"_posts/swe/也谈TDD.md","raw":"---\ntitle: 也谈TDD\ndate: 2018-01-10 21:33:51\ntags: [敏捷]\n---\n&nbsp;&nbsp;&nbsp;&nbsp;最近在组织项目成员的能力提升，不可避免的就进入了TDD这个话题。对于TDD，已经成为很多公司员工入职的专业知识培训课程。网上关于TDD的各种文章和讨论也很多，但是感觉大家都是望文生义，都是先写测试用例，再写代码。  \n&nbsp;&nbsp;&nbsp;&nbsp;可能有人会说TDD就是“Test Driven Development”，就是测试驱动开发。就是写测试用例，然后再写代码。我承认，书里是这么写的。大家也是这么理解，然后去实践的。实际效果如何呢，就我了解的情况，大家对这个都很纠结。很多都在说，我先写几行代码，然后再写用例为啥就不行了呢？难道真是缺少仪式感吗？  \n&nbsp;&nbsp;&nbsp;&nbsp;那么我先说说，我最近的思考。TDD方式，实际上是关注点驱动开发，或者说规则驱动开发。我要实现一个关注点/规则，我就先一条用例来验证这个关注点/规则，然后去完成这个关注点/规则的代码。如果按照这个思路去思考，我每次实现一个关注点/规则，我先写用例后写代码，或者先写代码再写用例。每次都是围绕着一个关注点/规则，是否先后顺序就显得不那么重要了。关键是每次聚焦于一个关注点/规则，有测试用例保证这个关注点/规则的准确性。那么就可以放心的去实现下一个关注点/规则，并且保证整个功能的准确了。  \n&nbsp;&nbsp;&nbsp;&nbsp;以上是我对于TDD的最新理解和思考。各位看过后是否也对TDD也有了新的理解了呢？","slug":"swe/也谈TDD","published":1,"updated":"2018-01-10T13:36:17.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3m000680cmurao82ya","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;最近在组织项目成员的能力提升，不可避免的就进入了TDD这个话题。对于TDD，已经成为很多公司员工入职的专业知识培训课程。网上关于TDD的各种文章和讨论也很多，但是感觉大家都是望文生义，都是先写测试用例，再写代码。<br>&nbsp;&nbsp;&nbsp;&nbsp;可能有人会说TDD就是“Test Driven Development”，就是测试驱动开发。就是写测试用例，然后再写代码。我承认，书里是这么写的。大家也是这么理解，然后去实践的。实际效果如何呢，就我了解的情况，大家对这个都很纠结。很多都在说，我先写几行代码，然后再写用例为啥就不行了呢？难道真是缺少仪式感吗？<br>&nbsp;&nbsp;&nbsp;&nbsp;那么我先说说，我最近的思考。TDD方式，实际上是关注点驱动开发，或者说规则驱动开发。我要实现一个关注点/规则，我就先一条用例来验证这个关注点/规则，然后去完成这个关注点/规则的代码。如果按照这个思路去思考，我每次实现一个关注点/规则，我先写用例后写代码，或者先写代码再写用例。每次都是围绕着一个关注点/规则，是否先后顺序就显得不那么重要了。关键是每次聚焦于一个关注点/规则，有测试用例保证这个关注点/规则的准确性。那么就可以放心的去实现下一个关注点/规则，并且保证整个功能的准确了。<br>&nbsp;&nbsp;&nbsp;&nbsp;以上是我对于TDD的最新理解和思考。各位看过后是否也对TDD也有了新的理解了呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;最近在组织项目成员的能力提升，不可避免的就进入了TDD这个话题。对于TDD，已经成为很多公司员工入职的专业知识培训课程。网上关于TDD的各种文章和讨论也很多，但是感觉大家都是望文生义，都是先写测试用例，再写代码。<br>&nbsp;&nbsp;&nbsp;&nbsp;可能有人会说TDD就是“Test Driven Development”，就是测试驱动开发。就是写测试用例，然后再写代码。我承认，书里是这么写的。大家也是这么理解，然后去实践的。实际效果如何呢，就我了解的情况，大家对这个都很纠结。很多都在说，我先写几行代码，然后再写用例为啥就不行了呢？难道真是缺少仪式感吗？<br>&nbsp;&nbsp;&nbsp;&nbsp;那么我先说说，我最近的思考。TDD方式，实际上是关注点驱动开发，或者说规则驱动开发。我要实现一个关注点/规则，我就先一条用例来验证这个关注点/规则，然后去完成这个关注点/规则的代码。如果按照这个思路去思考，我每次实现一个关注点/规则，我先写用例后写代码，或者先写代码再写用例。每次都是围绕着一个关注点/规则，是否先后顺序就显得不那么重要了。关键是每次聚焦于一个关注点/规则，有测试用例保证这个关注点/规则的准确性。那么就可以放心的去实现下一个关注点/规则，并且保证整个功能的准确了。<br>&nbsp;&nbsp;&nbsp;&nbsp;以上是我对于TDD的最新理解和思考。各位看过后是否也对TDD也有了新的理解了呢？</p>\n"},{"title":"Hexo使用","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/tool/hexo.md","raw":"---\ntitle: Hexo使用\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"tool/hexo","published":1,"date":"2018-01-07T04:16:57.927Z","updated":"2018-01-10T13:38:25.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3m000880cmx0az42qu","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"编码新利器--Visual Studio Code","date":"2018-01-10T11:39:06.000Z","_content":"### VSC简介\nMicrosoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。  \nVisual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作……   \n\n下面简单介绍下个人认为比较酸爽的特性：   \n### 集成Git\nVSC默认集成了git。打开git项目根目录后，VSC自动会扫描git相关设置，并且默认定时更新代码，扫描状态。如下图，左侧菜单选择git，就能看到变更的文件信息（包括新建，修改，删除）。在信息输入框里输入注释信息，执行Ctrl+Enter，即可完成 git add . 和git commit操作。\n![git1png.jpg](http://upload-images.jianshu.io/upload_images/4944427-de4b3dcedbf922f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n然后在右上角打开菜单，执行push操作,或者撤销本次提交，以及其他操作。  \n双击修改的文件，会自动进行差异对比。如下图   \n  \n![git3.jpg](http://upload-images.jianshu.io/upload_images/4944427-5e4dd64069840178.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 集成ESLint\nESLint需要自己安装，安装过程如下： \n* 安装ESLint环境。首先安装node.js，然后执行npm install -g eslint安装eslint。\n* 安装vsc的eslint插件。点击左侧菜单最后一项，进入插件安装界面。选择 ESLint点击安装，安装后变成设置按钮。  \n\n![plugin.jpg](http://upload-images.jianshu.io/upload_images/4944427-936edcdf8d1fbe11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n安装完成后，按照提示重启VSC。再次打开后在底部信息框的“问题”标签页里就能看到ESLint检查的结果了。同时在有问题的代码，以及右侧滚动条上也会有错误位置提示。如下图。  \n\n![eslint.jpg](http://upload-images.jianshu.io/upload_images/4944427-226ea44081f94918.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n\n注意，代理设置方法如下： \n文件——>首选项——>设置。在右侧配置里增加如下设置\n\"http.proxy\": \"http://proxy.my.com.cn:80\",\n    \"https.proxy\": \"https://proxy.my.com.cn:80\",\n    \"http.proxyStrictSSL\": false,\n\n\n### 支持Node.js调试\n打开Node.js项目，左侧菜单选择调试功能。点击顶部的启动调试按钮。第一次调试时，会弹出配置页面。对配置文件launch.json里的参数进行配置。主要是配置下路径和启动文件名，配置完成后再次点击启动即可。如下图\n\n![debug1.jpg](http://upload-images.jianshu.io/upload_images/4944427-98e9adc4ecb8668b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n调试的界面与Chrome dev tool类似，这里就不多介绍了，如下图。\n\n![debug2.jpg](http://upload-images.jianshu.io/upload_images/4944427-881637f5e0a2da45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 内嵌终端控制器\n在底部的信息框里选择“终端”选项卡，就能看到命令行界面了，调入命令执行即可，免去了频繁的切换窗口。如下图：   \n\n![cmd.jpg](http://upload-images.jianshu.io/upload_images/4944427-9c38ee9cab51d5e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 代码格式化\n选中代码，右键，选择格式化\n### 代码跳转\n右键，选择跳转       \n### html、css自动填充\n同sublime功能类似，输入标签后按下tab自动补齐。输入字母后，自动关联可能的属性等\n### 支持Markdown预览","source":"_posts/tool/编码新利器--Visual-Studio-Code.md","raw":"---\ntitle: 编码新利器--Visual Studio Code\ndate: 2018-01-10 19:39:06\ntags: [工具]\n---\n### VSC简介\nMicrosoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。  \nVisual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作……   \n\n下面简单介绍下个人认为比较酸爽的特性：   \n### 集成Git\nVSC默认集成了git。打开git项目根目录后，VSC自动会扫描git相关设置，并且默认定时更新代码，扫描状态。如下图，左侧菜单选择git，就能看到变更的文件信息（包括新建，修改，删除）。在信息输入框里输入注释信息，执行Ctrl+Enter，即可完成 git add . 和git commit操作。\n![git1png.jpg](http://upload-images.jianshu.io/upload_images/4944427-de4b3dcedbf922f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n然后在右上角打开菜单，执行push操作,或者撤销本次提交，以及其他操作。  \n双击修改的文件，会自动进行差异对比。如下图   \n  \n![git3.jpg](http://upload-images.jianshu.io/upload_images/4944427-5e4dd64069840178.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 集成ESLint\nESLint需要自己安装，安装过程如下： \n* 安装ESLint环境。首先安装node.js，然后执行npm install -g eslint安装eslint。\n* 安装vsc的eslint插件。点击左侧菜单最后一项，进入插件安装界面。选择 ESLint点击安装，安装后变成设置按钮。  \n\n![plugin.jpg](http://upload-images.jianshu.io/upload_images/4944427-936edcdf8d1fbe11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n安装完成后，按照提示重启VSC。再次打开后在底部信息框的“问题”标签页里就能看到ESLint检查的结果了。同时在有问题的代码，以及右侧滚动条上也会有错误位置提示。如下图。  \n\n![eslint.jpg](http://upload-images.jianshu.io/upload_images/4944427-226ea44081f94918.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n\n注意，代理设置方法如下： \n文件——>首选项——>设置。在右侧配置里增加如下设置\n\"http.proxy\": \"http://proxy.my.com.cn:80\",\n    \"https.proxy\": \"https://proxy.my.com.cn:80\",\n    \"http.proxyStrictSSL\": false,\n\n\n### 支持Node.js调试\n打开Node.js项目，左侧菜单选择调试功能。点击顶部的启动调试按钮。第一次调试时，会弹出配置页面。对配置文件launch.json里的参数进行配置。主要是配置下路径和启动文件名，配置完成后再次点击启动即可。如下图\n\n![debug1.jpg](http://upload-images.jianshu.io/upload_images/4944427-98e9adc4ecb8668b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n调试的界面与Chrome dev tool类似，这里就不多介绍了，如下图。\n\n![debug2.jpg](http://upload-images.jianshu.io/upload_images/4944427-881637f5e0a2da45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 内嵌终端控制器\n在底部的信息框里选择“终端”选项卡，就能看到命令行界面了，调入命令执行即可，免去了频繁的切换窗口。如下图：   \n\n![cmd.jpg](http://upload-images.jianshu.io/upload_images/4944427-9c38ee9cab51d5e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 代码格式化\n选中代码，右键，选择格式化\n### 代码跳转\n右键，选择跳转       \n### html、css自动填充\n同sublime功能类似，输入标签后按下tab自动补齐。输入字母后，自动关联可能的属性等\n### 支持Markdown预览","slug":"tool/编码新利器--Visual-Studio-Code","published":1,"updated":"2018-01-10T13:40:07.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci3q000980cm2db34uje","content":"<h3 id=\"VSC简介\"><a href=\"#VSC简介\" class=\"headerlink\" title=\"VSC简介\"></a>VSC简介</h3><p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。<br>Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作……   </p>\n<p>下面简单介绍下个人认为比较酸爽的特性：   </p>\n<h3 id=\"集成Git\"><a href=\"#集成Git\" class=\"headerlink\" title=\"集成Git\"></a>集成Git</h3><p>VSC默认集成了git。打开git项目根目录后，VSC自动会扫描git相关设置，并且默认定时更新代码，扫描状态。如下图，左侧菜单选择git，就能看到变更的文件信息（包括新建，修改，删除）。在信息输入框里输入注释信息，执行Ctrl+Enter，即可完成 git add . 和git commit操作。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-de4b3dcedbf922f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git1png.jpg\"></p>\n<p>然后在右上角打开菜单，执行push操作,或者撤销本次提交，以及其他操作。<br>双击修改的文件，会自动进行差异对比。如下图   </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-5e4dd64069840178.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git3.jpg\"></p>\n<h3 id=\"集成ESLint\"><a href=\"#集成ESLint\" class=\"headerlink\" title=\"集成ESLint\"></a>集成ESLint</h3><p>ESLint需要自己安装，安装过程如下： </p>\n<ul>\n<li>安装ESLint环境。首先安装node.js，然后执行npm install -g eslint安装eslint。</li>\n<li>安装vsc的eslint插件。点击左侧菜单最后一项，进入插件安装界面。选择 ESLint点击安装，安装后变成设置按钮。  </li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-936edcdf8d1fbe11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"plugin.jpg\"></p>\n<p>安装完成后，按照提示重启VSC。再次打开后在底部信息框的“问题”标签页里就能看到ESLint检查的结果了。同时在有问题的代码，以及右侧滚动条上也会有错误位置提示。如下图。  </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-226ea44081f94918.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eslint.jpg\"></p>\n<p>注意，代理设置方法如下：<br>文件——&gt;首选项——&gt;设置。在右侧配置里增加如下设置<br>“http.proxy”: “<a href=\"http://proxy.my.com.cn:80\" target=\"_blank\" rel=\"noopener\">http://proxy.my.com.cn:80</a>“,<br>    “https.proxy”: “<a href=\"https://proxy.my.com.cn:80\" target=\"_blank\" rel=\"noopener\">https://proxy.my.com.cn:80</a>“,<br>    “http.proxyStrictSSL”: false,</p>\n<h3 id=\"支持Node-js调试\"><a href=\"#支持Node-js调试\" class=\"headerlink\" title=\"支持Node.js调试\"></a>支持Node.js调试</h3><p>打开Node.js项目，左侧菜单选择调试功能。点击顶部的启动调试按钮。第一次调试时，会弹出配置页面。对配置文件launch.json里的参数进行配置。主要是配置下路径和启动文件名，配置完成后再次点击启动即可。如下图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-98e9adc4ecb8668b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debug1.jpg\"></p>\n<p>调试的界面与Chrome dev tool类似，这里就不多介绍了，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-881637f5e0a2da45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debug2.jpg\"></p>\n<h3 id=\"内嵌终端控制器\"><a href=\"#内嵌终端控制器\" class=\"headerlink\" title=\"内嵌终端控制器\"></a>内嵌终端控制器</h3><p>在底部的信息框里选择“终端”选项卡，就能看到命令行界面了，调入命令执行即可，免去了频繁的切换窗口。如下图：   </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-9c38ee9cab51d5e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cmd.jpg\"></p>\n<h3 id=\"代码格式化\"><a href=\"#代码格式化\" class=\"headerlink\" title=\"代码格式化\"></a>代码格式化</h3><p>选中代码，右键，选择格式化</p>\n<h3 id=\"代码跳转\"><a href=\"#代码跳转\" class=\"headerlink\" title=\"代码跳转\"></a>代码跳转</h3><p>右键，选择跳转       </p>\n<h3 id=\"html、css自动填充\"><a href=\"#html、css自动填充\" class=\"headerlink\" title=\"html、css自动填充\"></a>html、css自动填充</h3><p>同sublime功能类似，输入标签后按下tab自动补齐。输入字母后，自动关联可能的属性等</p>\n<h3 id=\"支持Markdown预览\"><a href=\"#支持Markdown预览\" class=\"headerlink\" title=\"支持Markdown预览\"></a>支持Markdown预览</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"VSC简介\"><a href=\"#VSC简介\" class=\"headerlink\" title=\"VSC简介\"></a>VSC简介</h3><p>Microsoft在2015年4月30日Build 开发者大会上正式宣布了 Visual Studio Code项目：一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器。<br>Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux，运行流畅，可谓是微软的良心之作……   </p>\n<p>下面简单介绍下个人认为比较酸爽的特性：   </p>\n<h3 id=\"集成Git\"><a href=\"#集成Git\" class=\"headerlink\" title=\"集成Git\"></a>集成Git</h3><p>VSC默认集成了git。打开git项目根目录后，VSC自动会扫描git相关设置，并且默认定时更新代码，扫描状态。如下图，左侧菜单选择git，就能看到变更的文件信息（包括新建，修改，删除）。在信息输入框里输入注释信息，执行Ctrl+Enter，即可完成 git add . 和git commit操作。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-de4b3dcedbf922f2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git1png.jpg\"></p>\n<p>然后在右上角打开菜单，执行push操作,或者撤销本次提交，以及其他操作。<br>双击修改的文件，会自动进行差异对比。如下图   </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-5e4dd64069840178.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"git3.jpg\"></p>\n<h3 id=\"集成ESLint\"><a href=\"#集成ESLint\" class=\"headerlink\" title=\"集成ESLint\"></a>集成ESLint</h3><p>ESLint需要自己安装，安装过程如下： </p>\n<ul>\n<li>安装ESLint环境。首先安装node.js，然后执行npm install -g eslint安装eslint。</li>\n<li>安装vsc的eslint插件。点击左侧菜单最后一项，进入插件安装界面。选择 ESLint点击安装，安装后变成设置按钮。  </li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-936edcdf8d1fbe11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"plugin.jpg\"></p>\n<p>安装完成后，按照提示重启VSC。再次打开后在底部信息框的“问题”标签页里就能看到ESLint检查的结果了。同时在有问题的代码，以及右侧滚动条上也会有错误位置提示。如下图。  </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-226ea44081f94918.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eslint.jpg\"></p>\n<p>注意，代理设置方法如下：<br>文件——&gt;首选项——&gt;设置。在右侧配置里增加如下设置<br>“http.proxy”: “<a href=\"http://proxy.my.com.cn:80\" target=\"_blank\" rel=\"noopener\">http://proxy.my.com.cn:80</a>“,<br>    “https.proxy”: “<a href=\"https://proxy.my.com.cn:80\" target=\"_blank\" rel=\"noopener\">https://proxy.my.com.cn:80</a>“,<br>    “http.proxyStrictSSL”: false,</p>\n<h3 id=\"支持Node-js调试\"><a href=\"#支持Node-js调试\" class=\"headerlink\" title=\"支持Node.js调试\"></a>支持Node.js调试</h3><p>打开Node.js项目，左侧菜单选择调试功能。点击顶部的启动调试按钮。第一次调试时，会弹出配置页面。对配置文件launch.json里的参数进行配置。主要是配置下路径和启动文件名，配置完成后再次点击启动即可。如下图</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-98e9adc4ecb8668b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debug1.jpg\"></p>\n<p>调试的界面与Chrome dev tool类似，这里就不多介绍了，如下图。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-881637f5e0a2da45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debug2.jpg\"></p>\n<h3 id=\"内嵌终端控制器\"><a href=\"#内嵌终端控制器\" class=\"headerlink\" title=\"内嵌终端控制器\"></a>内嵌终端控制器</h3><p>在底部的信息框里选择“终端”选项卡，就能看到命令行界面了，调入命令执行即可，免去了频繁的切换窗口。如下图：   </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-9c38ee9cab51d5e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cmd.jpg\"></p>\n<h3 id=\"代码格式化\"><a href=\"#代码格式化\" class=\"headerlink\" title=\"代码格式化\"></a>代码格式化</h3><p>选中代码，右键，选择格式化</p>\n<h3 id=\"代码跳转\"><a href=\"#代码跳转\" class=\"headerlink\" title=\"代码跳转\"></a>代码跳转</h3><p>右键，选择跳转       </p>\n<h3 id=\"html、css自动填充\"><a href=\"#html、css自动填充\" class=\"headerlink\" title=\"html、css自动填充\"></a>html、css自动填充</h3><p>同sublime功能类似，输入标签后按下tab自动补齐。输入字母后，自动关联可能的属性等</p>\n<h3 id=\"支持Markdown预览\"><a href=\"#支持Markdown预览\" class=\"headerlink\" title=\"支持Markdown预览\"></a>支持Markdown预览</h3>"},{"title":"高性能JavaScript--JS加载和执行","date":"2018-01-10T13:28:07.000Z","_content":"随着前端技术的不断发展，JS在web应用中的作用越来越来大，同时也意味着JS越来越成为前端的瓶颈。写出高性能的JS代码，也成为了前端开发者必备的技能。这里分享一下《高性能JavaScript》的读书心得，以便大家更好的理解JS，写出更高效的JS代码。  \n## JS加载和执行  \n### JS的加载  \n1. 地球人都知道，为了不阻塞页面的加载和渲染，JS文件一般放在html的底部加载。\n2. 减少加载的JS脚本数量，一般采用合并文件的方式\n3. 减小JS文件大小，压缩JS文件，开启GZIP压缩  \n\n### 无阻塞的脚本  \n避免一次加载一个很大的JS文件，避免阻塞浏览器。主要采用延迟加载技术，具体实现方法包括：\n1. 利用script标签的延迟加载属性defer(需注意兼容性，可以在[](http://caniuse.com/)上查看)\n```\n<script type=\"text/javascript\" src=\"file1.js\" defer></script>\n```\n带有defer属性的script标签，可以放在文档的任何位置。对应的JS文件将在script标签解析时下载，但代码不会被执行，直到DOM加载完成（onload事件触发之前）才会执行。JS文件下载时不会阻塞页面的其他处理过程。\n2. 动态创建script元素,通过src加载脚本 \n```\nvar script= document.createElement (\"script\");\nscript.type= \"text/javascript\";\nscript.src= \"file1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script)\n```\n特点：无论在何处启动下载，文件的下载和运行都不会阻塞页面的其他处理过程。如需控制狂态和加载顺序，需要自己添加监听事件处理.\n```\n//Internet Explorer\nscript.onreadystatechange =function(){...}\n//Firefox,Opera, Chrome,Safari3+\nscript.onload = function(){...}\n```  \n\n3. XMLHttpRequest脚本注入，通过XHR获取JS字符串，填入script元素。\n```\nvar xhr= newXMLHttpRequest();\nxhr.open(\"get\",\"file1.js\",true);\nxhr.onreadystatechange= function(){\n    if (xhr.readyState==4){\n        if (xhr.status>=200&&xhr.status<300|| xhr.status== 304){\n            varscript= document.createElement(\"script\");\n            script.type= \"text/javascript\";\n            script.text= xhr.responseText;\n            document.body.appendChild(script);\n        }\n    }\n};\nxhr.send(null)\n```\n特点：下载后可以不用立即添加script元素，从而控制执行时间。\n### 推荐的无阻塞模式\n先加载必要的JS文件，然后再执行load函数，再加载其他功能所需的脚本。\n```\n<script type=\"text/javascript\" src=\"loader.js\"></script>\n<script type=\"text/javascript\">\n    loadScript(\"the-rest.js\",function(){\n        Application.init();\n    });\n</script>\n```\n目前各主流的延迟加载类库，也是采用这些技术。比如，图片懒加载，动态给img元素的src赋值。requireJS是使用动态创建script元素实现的。  \n","source":"_posts/FE/js/高性能JavaScript-JS加载和执行.md","raw":"---\ntitle: 高性能JavaScript--JS加载和执行\ndate: 2018-01-10 21:28:07\ntags: [JS,性能]\n---\n随着前端技术的不断发展，JS在web应用中的作用越来越来大，同时也意味着JS越来越成为前端的瓶颈。写出高性能的JS代码，也成为了前端开发者必备的技能。这里分享一下《高性能JavaScript》的读书心得，以便大家更好的理解JS，写出更高效的JS代码。  \n## JS加载和执行  \n### JS的加载  \n1. 地球人都知道，为了不阻塞页面的加载和渲染，JS文件一般放在html的底部加载。\n2. 减少加载的JS脚本数量，一般采用合并文件的方式\n3. 减小JS文件大小，压缩JS文件，开启GZIP压缩  \n\n### 无阻塞的脚本  \n避免一次加载一个很大的JS文件，避免阻塞浏览器。主要采用延迟加载技术，具体实现方法包括：\n1. 利用script标签的延迟加载属性defer(需注意兼容性，可以在[](http://caniuse.com/)上查看)\n```\n<script type=\"text/javascript\" src=\"file1.js\" defer></script>\n```\n带有defer属性的script标签，可以放在文档的任何位置。对应的JS文件将在script标签解析时下载，但代码不会被执行，直到DOM加载完成（onload事件触发之前）才会执行。JS文件下载时不会阻塞页面的其他处理过程。\n2. 动态创建script元素,通过src加载脚本 \n```\nvar script= document.createElement (\"script\");\nscript.type= \"text/javascript\";\nscript.src= \"file1.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script)\n```\n特点：无论在何处启动下载，文件的下载和运行都不会阻塞页面的其他处理过程。如需控制狂态和加载顺序，需要自己添加监听事件处理.\n```\n//Internet Explorer\nscript.onreadystatechange =function(){...}\n//Firefox,Opera, Chrome,Safari3+\nscript.onload = function(){...}\n```  \n\n3. XMLHttpRequest脚本注入，通过XHR获取JS字符串，填入script元素。\n```\nvar xhr= newXMLHttpRequest();\nxhr.open(\"get\",\"file1.js\",true);\nxhr.onreadystatechange= function(){\n    if (xhr.readyState==4){\n        if (xhr.status>=200&&xhr.status<300|| xhr.status== 304){\n            varscript= document.createElement(\"script\");\n            script.type= \"text/javascript\";\n            script.text= xhr.responseText;\n            document.body.appendChild(script);\n        }\n    }\n};\nxhr.send(null)\n```\n特点：下载后可以不用立即添加script元素，从而控制执行时间。\n### 推荐的无阻塞模式\n先加载必要的JS文件，然后再执行load函数，再加载其他功能所需的脚本。\n```\n<script type=\"text/javascript\" src=\"loader.js\"></script>\n<script type=\"text/javascript\">\n    loadScript(\"the-rest.js\",function(){\n        Application.init();\n    });\n</script>\n```\n目前各主流的延迟加载类库，也是采用这些技术。比如，图片懒加载，动态给img元素的src赋值。requireJS是使用动态创建script元素实现的。  \n","slug":"FE/js/高性能JavaScript-JS加载和执行","published":1,"updated":"2018-01-10T13:31:39.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci42000m80cm8gmyfauf","content":"<p>随着前端技术的不断发展，JS在web应用中的作用越来越来大，同时也意味着JS越来越成为前端的瓶颈。写出高性能的JS代码，也成为了前端开发者必备的技能。这里分享一下《高性能JavaScript》的读书心得，以便大家更好的理解JS，写出更高效的JS代码。  </p>\n<h2 id=\"JS加载和执行\"><a href=\"#JS加载和执行\" class=\"headerlink\" title=\"JS加载和执行\"></a>JS加载和执行</h2><h3 id=\"JS的加载\"><a href=\"#JS的加载\" class=\"headerlink\" title=\"JS的加载\"></a>JS的加载</h3><ol>\n<li>地球人都知道，为了不阻塞页面的加载和渲染，JS文件一般放在html的底部加载。</li>\n<li>减少加载的JS脚本数量，一般采用合并文件的方式</li>\n<li>减小JS文件大小，压缩JS文件，开启GZIP压缩  </li>\n</ol>\n<h3 id=\"无阻塞的脚本\"><a href=\"#无阻塞的脚本\" class=\"headerlink\" title=\"无阻塞的脚本\"></a>无阻塞的脚本</h3><p>避免一次加载一个很大的JS文件，避免阻塞浏览器。主要采用延迟加载技术，具体实现方法包括：</p>\n<ol>\n<li>利用script标签的延迟加载属性defer(需注意兼容性，可以在<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\"></a>上查看)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>带有defer属性的script标签，可以放在文档的任何位置。对应的JS文件将在script标签解析时下载，但代码不会被执行，直到DOM加载完成（onload事件触发之前）才会执行。JS文件下载时不会阻塞页面的其他处理过程。</p>\n<ol>\n<li>动态创建script元素,通过src加载脚本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var script= document.createElement (&quot;script&quot;);</span><br><span class=\"line\">script.type= &quot;text/javascript&quot;;</span><br><span class=\"line\">script.src= &quot;file1.js&quot;;</span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>特点：无论在何处启动下载，文件的下载和运行都不会阻塞页面的其他处理过程。如需控制狂态和加载顺序，需要自己添加监听事件处理.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Internet Explorer</span><br><span class=\"line\">script.onreadystatechange =function()&#123;...&#125;</span><br><span class=\"line\">//Firefox,Opera, Chrome,Safari3+</span><br><span class=\"line\">script.onload = function()&#123;...&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">3. XMLHttpRequest脚本注入，通过XHR获取JS字符串，填入script元素。</span><br></pre></td></tr></table></figure></p>\n<p>var xhr= newXMLHttpRequest();<br>xhr.open(“get”,”file1.js”,true);<br>xhr.onreadystatechange= function(){<br>    if (xhr.readyState==4){<br>        if (xhr.status&gt;=200&amp;&amp;xhr.status<300|| xhr.status=\"=\" 304){=\"\" varscript=\"document.createElement(\"script\");\" script.type=\"text/javascript\" ;=\"\" script.text=\"xhr.responseText;\" document.body.appendchild(script);=\"\" }=\"\" };=\"\" xhr.send(null)=\"\" <figure=\"\" class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特点：下载后可以不用立即添加script元素，从而控制执行时间。</span><br><span class=\"line\">### 推荐的无阻塞模式</span><br><span class=\"line\">先加载必要的JS文件，然后再执行load函数，再加载其他功能所需的脚本。</span><br></pre></td></tr></table></300||></p>\n<p><script type=\"text/javascript\" src=\"loader.js\"></script></p>\n<p><script type=\"text/javascript\"><br>    loadScript(“the-rest.js”,function(){<br>        Application.init();<br>    });<br></script><br>```<br>目前各主流的延迟加载类库，也是采用这些技术。比如，图片懒加载，动态给img元素的src赋值。requireJS是使用动态创建script元素实现的。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着前端技术的不断发展，JS在web应用中的作用越来越来大，同时也意味着JS越来越成为前端的瓶颈。写出高性能的JS代码，也成为了前端开发者必备的技能。这里分享一下《高性能JavaScript》的读书心得，以便大家更好的理解JS，写出更高效的JS代码。  </p>\n<h2 id=\"JS加载和执行\"><a href=\"#JS加载和执行\" class=\"headerlink\" title=\"JS加载和执行\"></a>JS加载和执行</h2><h3 id=\"JS的加载\"><a href=\"#JS的加载\" class=\"headerlink\" title=\"JS的加载\"></a>JS的加载</h3><ol>\n<li>地球人都知道，为了不阻塞页面的加载和渲染，JS文件一般放在html的底部加载。</li>\n<li>减少加载的JS脚本数量，一般采用合并文件的方式</li>\n<li>减小JS文件大小，压缩JS文件，开启GZIP压缩  </li>\n</ol>\n<h3 id=\"无阻塞的脚本\"><a href=\"#无阻塞的脚本\" class=\"headerlink\" title=\"无阻塞的脚本\"></a>无阻塞的脚本</h3><p>避免一次加载一个很大的JS文件，避免阻塞浏览器。主要采用延迟加载技术，具体实现方法包括：</p>\n<ol>\n<li>利用script标签的延迟加载属性defer(需注意兼容性，可以在<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"noopener\"></a>上查看)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;file1.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>带有defer属性的script标签，可以放在文档的任何位置。对应的JS文件将在script标签解析时下载，但代码不会被执行，直到DOM加载完成（onload事件触发之前）才会执行。JS文件下载时不会阻塞页面的其他处理过程。</p>\n<ol>\n<li>动态创建script元素,通过src加载脚本 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var script= document.createElement (&quot;script&quot;);</span><br><span class=\"line\">script.type= &quot;text/javascript&quot;;</span><br><span class=\"line\">script.src= &quot;file1.js&quot;;</span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>特点：无论在何处启动下载，文件的下载和运行都不会阻塞页面的其他处理过程。如需控制狂态和加载顺序，需要自己添加监听事件处理.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Internet Explorer</span><br><span class=\"line\">script.onreadystatechange =function()&#123;...&#125;</span><br><span class=\"line\">//Firefox,Opera, Chrome,Safari3+</span><br><span class=\"line\">script.onload = function()&#123;...&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">3. XMLHttpRequest脚本注入，通过XHR获取JS字符串，填入script元素。</span><br></pre></td></tr></table></figure></p>\n<p>var xhr= newXMLHttpRequest();<br>xhr.open(“get”,”file1.js”,true);<br>xhr.onreadystatechange= function(){<br>    if (xhr.readyState==4){<br>        if (xhr.status&gt;=200&amp;&amp;xhr.status<300|| xhr.status=\"=\" 304){=\"\" varscript=\"document.createElement(\"script\");\" script.type=\"text/javascript\" ;=\"\" script.text=\"xhr.responseText;\" document.body.appendchild(script);=\"\" }=\"\" };=\"\" xhr.send(null)=\"\" <figure=\"\" class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">特点：下载后可以不用立即添加script元素，从而控制执行时间。</span><br><span class=\"line\">### 推荐的无阻塞模式</span><br><span class=\"line\">先加载必要的JS文件，然后再执行load函数，再加载其他功能所需的脚本。</span><br></pre></td></tr></table></300||></p>\n<p><script type=\"text/javascript\" src=\"loader.js\"></script></p>\n<p><script type=\"text/javascript\"><br>    loadScript(“the-rest.js”,function(){<br>        Application.init();<br>    });<br></script><br>```<br>目前各主流的延迟加载类库，也是采用这些技术。比如，图片懒加载，动态给img元素的src赋值。requireJS是使用动态创建script元素实现的。  </p>\n"},{"title":"高性能JavaScript--原型链","date":"2018-01-10T13:29:12.000Z","_content":"### 对象成员\n前面已经介绍过，访问对象成员的速度比字面量或变量要慢，某些浏览器比数组元素还要慢。这里所说的对象成员包括属性和方法。大部分的JS代码都是以面向对象风格编写的，这就导致了非常频繁的访问对象成员操作？\n#### 原型\nJS的对象是基于原型的。原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表。不同于其他编程语言的类，原型为所有对象实例所共享，因此这些实例也共享原型对象的成员。并且每个对象实例上的原型修改后，会影响原型的定义。\n在Firefox，Safari，Chrome和IE11+浏览器里，对象实例可以通过__proto__读取原型对象。一旦创建一个内置对象（例如Object或Array）的实例，他们就会自动拥有一个Object对象作为原型。\n对象可以有两种成员类型：实例成员（或own成员）和原型成员。实例成员直接存在于对象实例中，原型成员则从对象的原型继承而来。实例代码如下：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n}\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\");\nconsole.log(book1.title);//实例成员\nconsole.log(book1.toString());//原型成员\n```\n如何判断对象的相关成员是否存在？是实例成员还是原型成员成员？方法如下：\n```\nconsole.log( book1.hasOwnProperty('title')) //true\nconsole.log( book1.hasOwnProperty('toString')) //false\nconsole.log('title' in book1) //true\nconsole.log('toString' in book1) //true\n```\n#### 原型链\n一个对象实例的原型对象，如果不是Object对象，那么原型对象就还有其自己的原型对象，直到原型对象是Object对象才结束。这种原型对象的嵌套就是原型链。\nObject实例的原型就是Object对象，而其他对象生成实例时，instance.__proto__.__proto__才是Object对象。\n示例代码：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n}\nBook.prototype.price = 1.2\n\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\");\n```\n实例book1的原型(__proto__)是Book.prototype,而Book.prototype的原型是Object。\n对象Book拥有__proto__和prototype两个属性，\n注意prototype的使用，只有在实例中才能直接读取prototype定义的属性。\n```\nfunction seven() {\n    this.a = 7;\n}\nseven.prototype.a = -1;\nconsole.log('seven.a', seven.a); //undefine\nconsole.log('new seven().a', new seven().a); //7\n```\n\n#### 缓存对象成员值\n访问对象成员时，对象在原型链的位置越深，读取的速度也就越慢。只有在必要时才使用对象成员，特别是没有必要反复多次读取同一对象成员。最佳做法是将属性值保存在局部变量中，使用局部变量代替属性以避免多次查找带来的性能开销。\n实例代码如下：\n```\nfunction toggle(element){\n    if(YAHOO.util.Dom.hasClass(element,'selected')){\n        YAHOO.util.Dom.removeClass(element,'selected');\n        return false;\n    } else {\n        YAHOO.util.Dom.addClass(element,'selected');\n        return true;\n    }\n}\n\n//改进后\nfunction toggle(element){\n    var dom = YAHOO.util.Dom;\n    var hasClass = dom.hasClass(element,'selected');\n    if(hasClass){\n        dom.removeClass(element,'selected');\n    } else {\n        dom.addClass(element,'selected');\n    }\n    return !hasClass;\n}\n```\n注意：\n这种优化技术，并不推荐用于对象的成员方法。因为许多对象方法使用this来判断执行环境，把一个对象方法保存在局部变量会导致this的改变，从而导致异常。示例如下：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n    this.getTitle = function(){\n        return this.title\n    }\n}\n\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\")\nconsole.log(book1.getTitle())\nvar mytitle = book1.getTitle\nconsole.log(mytitle()) //throw exception\n\n```","source":"_posts/FE/js/高性能JavaScript-原型链.md","raw":"---\ntitle: 高性能JavaScript--原型链\ndate: 2018-01-10 21:29:12\ntags: [JS,性能]\n---\n### 对象成员\n前面已经介绍过，访问对象成员的速度比字面量或变量要慢，某些浏览器比数组元素还要慢。这里所说的对象成员包括属性和方法。大部分的JS代码都是以面向对象风格编写的，这就导致了非常频繁的访问对象成员操作？\n#### 原型\nJS的对象是基于原型的。原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表。不同于其他编程语言的类，原型为所有对象实例所共享，因此这些实例也共享原型对象的成员。并且每个对象实例上的原型修改后，会影响原型的定义。\n在Firefox，Safari，Chrome和IE11+浏览器里，对象实例可以通过__proto__读取原型对象。一旦创建一个内置对象（例如Object或Array）的实例，他们就会自动拥有一个Object对象作为原型。\n对象可以有两种成员类型：实例成员（或own成员）和原型成员。实例成员直接存在于对象实例中，原型成员则从对象的原型继承而来。实例代码如下：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n}\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\");\nconsole.log(book1.title);//实例成员\nconsole.log(book1.toString());//原型成员\n```\n如何判断对象的相关成员是否存在？是实例成员还是原型成员成员？方法如下：\n```\nconsole.log( book1.hasOwnProperty('title')) //true\nconsole.log( book1.hasOwnProperty('toString')) //false\nconsole.log('title' in book1) //true\nconsole.log('toString' in book1) //true\n```\n#### 原型链\n一个对象实例的原型对象，如果不是Object对象，那么原型对象就还有其自己的原型对象，直到原型对象是Object对象才结束。这种原型对象的嵌套就是原型链。\nObject实例的原型就是Object对象，而其他对象生成实例时，instance.__proto__.__proto__才是Object对象。\n示例代码：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n}\nBook.prototype.price = 1.2\n\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\");\n```\n实例book1的原型(__proto__)是Book.prototype,而Book.prototype的原型是Object。\n对象Book拥有__proto__和prototype两个属性，\n注意prototype的使用，只有在实例中才能直接读取prototype定义的属性。\n```\nfunction seven() {\n    this.a = 7;\n}\nseven.prototype.a = -1;\nconsole.log('seven.a', seven.a); //undefine\nconsole.log('new seven().a', new seven().a); //7\n```\n\n#### 缓存对象成员值\n访问对象成员时，对象在原型链的位置越深，读取的速度也就越慢。只有在必要时才使用对象成员，特别是没有必要反复多次读取同一对象成员。最佳做法是将属性值保存在局部变量中，使用局部变量代替属性以避免多次查找带来的性能开销。\n实例代码如下：\n```\nfunction toggle(element){\n    if(YAHOO.util.Dom.hasClass(element,'selected')){\n        YAHOO.util.Dom.removeClass(element,'selected');\n        return false;\n    } else {\n        YAHOO.util.Dom.addClass(element,'selected');\n        return true;\n    }\n}\n\n//改进后\nfunction toggle(element){\n    var dom = YAHOO.util.Dom;\n    var hasClass = dom.hasClass(element,'selected');\n    if(hasClass){\n        dom.removeClass(element,'selected');\n    } else {\n        dom.addClass(element,'selected');\n    }\n    return !hasClass;\n}\n```\n注意：\n这种优化技术，并不推荐用于对象的成员方法。因为许多对象方法使用this来判断执行环境，把一个对象方法保存在局部变量会导致this的改变，从而导致异常。示例如下：\n```\nfunction Book(title, publisher){\n    this.title = title\n    this.publisher = publisher\n    this.getTitle = function(){\n        return this.title\n    }\n}\n\nvar book1 = new Book(\"High Performance JavaScript\",\"Yahoo! Press\")\nconsole.log(book1.getTitle())\nvar mytitle = book1.getTitle\nconsole.log(mytitle()) //throw exception\n\n```","slug":"FE/js/高性能JavaScript-原型链","published":1,"updated":"2018-01-10T13:32:56.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci46000n80cmtelmgdly","content":"<h3 id=\"对象成员\"><a href=\"#对象成员\" class=\"headerlink\" title=\"对象成员\"></a>对象成员</h3><p>前面已经介绍过，访问对象成员的速度比字面量或变量要慢，某些浏览器比数组元素还要慢。这里所说的对象成员包括属性和方法。大部分的JS代码都是以面向对象风格编写的，这就导致了非常频繁的访问对象成员操作？</p>\n<h4 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>JS的对象是基于原型的。原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表。不同于其他编程语言的类，原型为所有对象实例所共享，因此这些实例也共享原型对象的成员。并且每个对象实例上的原型修改后，会影响原型的定义。<br>在Firefox，Safari，Chrome和IE11+浏览器里，对象实例可以通过<strong>proto</strong>读取原型对象。一旦创建一个内置对象（例如Object或Array）的实例，他们就会自动拥有一个Object对象作为原型。<br>对象可以有两种成员类型：实例成员（或own成员）和原型成员。实例成员直接存在于对象实例中，原型成员则从对象的原型继承而来。实例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;);</span><br><span class=\"line\">console.log(book1.title);//实例成员</span><br><span class=\"line\">console.log(book1.toString());//原型成员</span><br></pre></td></tr></table></figure></p>\n<p>如何判断对象的相关成员是否存在？是实例成员还是原型成员成员？方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log( book1.hasOwnProperty(&apos;title&apos;)) //true</span><br><span class=\"line\">console.log( book1.hasOwnProperty(&apos;toString&apos;)) //false</span><br><span class=\"line\">console.log(&apos;title&apos; in book1) //true</span><br><span class=\"line\">console.log(&apos;toString&apos; in book1) //true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>一个对象实例的原型对象，如果不是Object对象，那么原型对象就还有其自己的原型对象，直到原型对象是Object对象才结束。这种原型对象的嵌套就是原型链。<br>Object实例的原型就是Object对象，而其他对象生成实例时，instance.<strong>proto</strong>.<strong>proto</strong>才是Object对象。<br>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Book.prototype.price = 1.2</span><br><span class=\"line\"></span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>实例book1的原型(<strong>proto</strong>)是Book.prototype,而Book.prototype的原型是Object。<br>对象Book拥有<strong>proto</strong>和prototype两个属性，<br>注意prototype的使用，只有在实例中才能直接读取prototype定义的属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function seven() &#123;</span><br><span class=\"line\">    this.a = 7;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">seven.prototype.a = -1;</span><br><span class=\"line\">console.log(&apos;seven.a&apos;, seven.a); //undefine</span><br><span class=\"line\">console.log(&apos;new seven().a&apos;, new seven().a); //7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"缓存对象成员值\"><a href=\"#缓存对象成员值\" class=\"headerlink\" title=\"缓存对象成员值\"></a>缓存对象成员值</h4><p>访问对象成员时，对象在原型链的位置越深，读取的速度也就越慢。只有在必要时才使用对象成员，特别是没有必要反复多次读取同一对象成员。最佳做法是将属性值保存在局部变量中，使用局部变量代替属性以避免多次查找带来的性能开销。<br>实例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toggle(element)&#123;</span><br><span class=\"line\">    if(YAHOO.util.Dom.hasClass(element,&apos;selected&apos;))&#123;</span><br><span class=\"line\">        YAHOO.util.Dom.removeClass(element,&apos;selected&apos;);</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        YAHOO.util.Dom.addClass(element,&apos;selected&apos;);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//改进后</span><br><span class=\"line\">function toggle(element)&#123;</span><br><span class=\"line\">    var dom = YAHOO.util.Dom;</span><br><span class=\"line\">    var hasClass = dom.hasClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    if(hasClass)&#123;</span><br><span class=\"line\">        dom.removeClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom.addClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return !hasClass;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>这种优化技术，并不推荐用于对象的成员方法。因为许多对象方法使用this来判断执行环境，把一个对象方法保存在局部变量会导致this的改变，从而导致异常。示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">    this.getTitle = function()&#123;</span><br><span class=\"line\">        return this.title</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;)</span><br><span class=\"line\">console.log(book1.getTitle())</span><br><span class=\"line\">var mytitle = book1.getTitle</span><br><span class=\"line\">console.log(mytitle()) //throw exception</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"对象成员\"><a href=\"#对象成员\" class=\"headerlink\" title=\"对象成员\"></a>对象成员</h3><p>前面已经介绍过，访问对象成员的速度比字面量或变量要慢，某些浏览器比数组元素还要慢。这里所说的对象成员包括属性和方法。大部分的JS代码都是以面向对象风格编写的，这就导致了非常频繁的访问对象成员操作？</p>\n<h4 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h4><p>JS的对象是基于原型的。原型是其他对象的基础，它定义并实现了一个新创建的对象所必须包含的成员列表。不同于其他编程语言的类，原型为所有对象实例所共享，因此这些实例也共享原型对象的成员。并且每个对象实例上的原型修改后，会影响原型的定义。<br>在Firefox，Safari，Chrome和IE11+浏览器里，对象实例可以通过<strong>proto</strong>读取原型对象。一旦创建一个内置对象（例如Object或Array）的实例，他们就会自动拥有一个Object对象作为原型。<br>对象可以有两种成员类型：实例成员（或own成员）和原型成员。实例成员直接存在于对象实例中，原型成员则从对象的原型继承而来。实例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;);</span><br><span class=\"line\">console.log(book1.title);//实例成员</span><br><span class=\"line\">console.log(book1.toString());//原型成员</span><br></pre></td></tr></table></figure></p>\n<p>如何判断对象的相关成员是否存在？是实例成员还是原型成员成员？方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log( book1.hasOwnProperty(&apos;title&apos;)) //true</span><br><span class=\"line\">console.log( book1.hasOwnProperty(&apos;toString&apos;)) //false</span><br><span class=\"line\">console.log(&apos;title&apos; in book1) //true</span><br><span class=\"line\">console.log(&apos;toString&apos; in book1) //true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h4><p>一个对象实例的原型对象，如果不是Object对象，那么原型对象就还有其自己的原型对象，直到原型对象是Object对象才结束。这种原型对象的嵌套就是原型链。<br>Object实例的原型就是Object对象，而其他对象生成实例时，instance.<strong>proto</strong>.<strong>proto</strong>才是Object对象。<br>示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Book.prototype.price = 1.2</span><br><span class=\"line\"></span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>实例book1的原型(<strong>proto</strong>)是Book.prototype,而Book.prototype的原型是Object。<br>对象Book拥有<strong>proto</strong>和prototype两个属性，<br>注意prototype的使用，只有在实例中才能直接读取prototype定义的属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function seven() &#123;</span><br><span class=\"line\">    this.a = 7;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">seven.prototype.a = -1;</span><br><span class=\"line\">console.log(&apos;seven.a&apos;, seven.a); //undefine</span><br><span class=\"line\">console.log(&apos;new seven().a&apos;, new seven().a); //7</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"缓存对象成员值\"><a href=\"#缓存对象成员值\" class=\"headerlink\" title=\"缓存对象成员值\"></a>缓存对象成员值</h4><p>访问对象成员时，对象在原型链的位置越深，读取的速度也就越慢。只有在必要时才使用对象成员，特别是没有必要反复多次读取同一对象成员。最佳做法是将属性值保存在局部变量中，使用局部变量代替属性以避免多次查找带来的性能开销。<br>实例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toggle(element)&#123;</span><br><span class=\"line\">    if(YAHOO.util.Dom.hasClass(element,&apos;selected&apos;))&#123;</span><br><span class=\"line\">        YAHOO.util.Dom.removeClass(element,&apos;selected&apos;);</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        YAHOO.util.Dom.addClass(element,&apos;selected&apos;);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//改进后</span><br><span class=\"line\">function toggle(element)&#123;</span><br><span class=\"line\">    var dom = YAHOO.util.Dom;</span><br><span class=\"line\">    var hasClass = dom.hasClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    if(hasClass)&#123;</span><br><span class=\"line\">        dom.removeClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        dom.addClass(element,&apos;selected&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return !hasClass;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>这种优化技术，并不推荐用于对象的成员方法。因为许多对象方法使用this来判断执行环境，把一个对象方法保存在局部变量会导致this的改变，从而导致异常。示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Book(title, publisher)&#123;</span><br><span class=\"line\">    this.title = title</span><br><span class=\"line\">    this.publisher = publisher</span><br><span class=\"line\">    this.getTitle = function()&#123;</span><br><span class=\"line\">        return this.title</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var book1 = new Book(&quot;High Performance JavaScript&quot;,&quot;Yahoo! Press&quot;)</span><br><span class=\"line\">console.log(book1.getTitle())</span><br><span class=\"line\">var mytitle = book1.getTitle</span><br><span class=\"line\">console.log(mytitle()) //throw exception</span><br></pre></td></tr></table></figure></p>\n"},{"title":"高性能JavaScript--作用域链","date":"2018-01-10T13:28:35.000Z","_content":"## 数据存取\nJS中有如下四种基本数据的存取：\n- 字面量：字符串、数字、布尔值、对象、数组、函数、正则表达式、null和undefined。\n- 本地变量：var/let 定义的数据存储单元。\n- 数组元素\n- 对象成员\n通常情况下，访问速度排序：字面量 > 本地变量 > 数组元素 > 对象成员。个别浏览器的版本，可能有细微差别。\n### 作用域\n执行环境/运行期上下文(execution context): 是指当前变量或函数有权访问的其它数据。每个执行环境都有一个与之关联的变量对象(variable object, VO)，VO是不能直接访问的，执行环境中定义的所有变量和函数都会保存在这个对象中，解析器在处理数据的时候就会访问这个内部对象。\n全局执行环境是最外层的一个执行环境，在web浏览器中全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和成员函数创建的。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，控制权返回到之前的执行环境中，全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。\n每一个JS函数可以看做是Function对象的一个实例，并且含有一个内部属性[[Scopes]],[[Scopes]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为作用域链，它决定哪些数据能被函数访问。函数作用域中的每个对象被称为一个可变对象，每个可变对象都是以“key-value”形式存在。\n典型的作用域链：\n1. 函数创建时\n此时函数的作用域链会压入第一个作用域对象，即创建此函数的作用域中可访问的数据对象填充。如下图所示：\n\n![scope1.png](http://upload-images.jianshu.io/upload_images/4944427-48ee5069cc4bba9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意：这个作用域对象是可变的，可以理解为这个对象是引用的。\n具体对象信息可以在chrome dev tool中查看，如下图：\n\n![scope1-tool.png](http://upload-images.jianshu.io/upload_images/4944427-2f9ebf872328209d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 函数执行时\n每次执行函数时都会创建一个执行环境，每个执行环境都是独一无二的，多次调用函数就会导致创建多个执行环境。此时会将会将一个被称为“活动对象”(activation object,AO)的新对象作为第二个作用域对象压入作用域链。如下图所示:\n\n![scope2.png](http://upload-images.jianshu.io/upload_images/4944427-9709f477eae42387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在函数的执行过程中，每遇到一个变量或者函数，都会在作用域链中按照顺序进行查找，直到遍历所有的作用域，此过程会影响运行性能。\n3. 闭包时的作用域\n如下一段代码中，包含了闭包\n```\nfunctionassignEvents(){\n    var id= \"xdi9592\";\n    document.getElementById(\"save-btn\").onclick =function(event){\n        saveDocument(id);\n    };\n}   \n```\n\n![scope3.png](http://upload-images.jianshu.io/upload_images/4944427-98c7ce04672a331c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![scope3-tool.png](http://upload-images.jianshu.io/upload_images/4944427-b5a1093ace42448b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n4. 其他改变作用域的情况\n一般作用域链的顺序是按照调用的顺序排列的，但是特殊情况下会改变。\n- with\n执行with语句时，会将with带入的对象压入作用域链，导致调用深度发生变化。\n```\nfunctioninitUI(){\n    with(document){\n        var bd= body,\n        links=getElementsByTagName_r(\"a\"),\n        i=0,\n        len= links.length;\n        while(i<len){\n        update(links[i++]);\n        }\n        getElementById(\"go-btn\").onclick=function(){\n        start();\n        };\n        bd.className =\"active\";\n    }\n}\n```\n![with.png](http://upload-images.jianshu.io/upload_images/4944427-71b9617f98d995b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- try-catch\n类似with，当try块发生异常时，程序跳转到catch子句，并且把异常对象压入作用域首位。catch子句执行完作用域链恢复之前的状态。由于加深了调用深度，如果在catch子句执行操作会造成性能问题。可以采用错误处理函数的方式，改变作用域链的状态，从而减少调用深度。\n```\ntry{\n    methodThatMightCauseAnError();\n}catch (ex){\n    handleError(ex);//delegate tohandlermethod\n}\n```\n### 标识符解析的性能\n在执行环境的作用域链中，一个标识符的位置越深，他的读写速度就越慢，因此函数中读写局部变量是最快的，读写全局变量通常是最慢的。\n改进办法，通过赋值给局部变量，改变标识符的深度，从而提高读写速度。\n```\nfor(var i = 0; i < document.getElementsByTagName(\"a\").length; i++){\n    document.getElementsByTagName(\"a\")[i].class = 'active'\n}\n//改进后\nvar list = document.getElementsByTagName(\"a\");\nfor(var i = 0; i < list.length; i++){\n    list[i].class = 'active'\n}\n```","source":"_posts/FE/js/高性能JavaScript-作用域链.md","raw":"---\ntitle: 高性能JavaScript--作用域链\ndate: 2018-01-10 21:28:35\ntags: [JS,性能]\n---\n## 数据存取\nJS中有如下四种基本数据的存取：\n- 字面量：字符串、数字、布尔值、对象、数组、函数、正则表达式、null和undefined。\n- 本地变量：var/let 定义的数据存储单元。\n- 数组元素\n- 对象成员\n通常情况下，访问速度排序：字面量 > 本地变量 > 数组元素 > 对象成员。个别浏览器的版本，可能有细微差别。\n### 作用域\n执行环境/运行期上下文(execution context): 是指当前变量或函数有权访问的其它数据。每个执行环境都有一个与之关联的变量对象(variable object, VO)，VO是不能直接访问的，执行环境中定义的所有变量和函数都会保存在这个对象中，解析器在处理数据的时候就会访问这个内部对象。\n全局执行环境是最外层的一个执行环境，在web浏览器中全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和成员函数创建的。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，控制权返回到之前的执行环境中，全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。\n每一个JS函数可以看做是Function对象的一个实例，并且含有一个内部属性[[Scopes]],[[Scopes]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为作用域链，它决定哪些数据能被函数访问。函数作用域中的每个对象被称为一个可变对象，每个可变对象都是以“key-value”形式存在。\n典型的作用域链：\n1. 函数创建时\n此时函数的作用域链会压入第一个作用域对象，即创建此函数的作用域中可访问的数据对象填充。如下图所示：\n\n![scope1.png](http://upload-images.jianshu.io/upload_images/4944427-48ee5069cc4bba9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n注意：这个作用域对象是可变的，可以理解为这个对象是引用的。\n具体对象信息可以在chrome dev tool中查看，如下图：\n\n![scope1-tool.png](http://upload-images.jianshu.io/upload_images/4944427-2f9ebf872328209d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 函数执行时\n每次执行函数时都会创建一个执行环境，每个执行环境都是独一无二的，多次调用函数就会导致创建多个执行环境。此时会将会将一个被称为“活动对象”(activation object,AO)的新对象作为第二个作用域对象压入作用域链。如下图所示:\n\n![scope2.png](http://upload-images.jianshu.io/upload_images/4944427-9709f477eae42387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在函数的执行过程中，每遇到一个变量或者函数，都会在作用域链中按照顺序进行查找，直到遍历所有的作用域，此过程会影响运行性能。\n3. 闭包时的作用域\n如下一段代码中，包含了闭包\n```\nfunctionassignEvents(){\n    var id= \"xdi9592\";\n    document.getElementById(\"save-btn\").onclick =function(event){\n        saveDocument(id);\n    };\n}   \n```\n\n![scope3.png](http://upload-images.jianshu.io/upload_images/4944427-98c7ce04672a331c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![scope3-tool.png](http://upload-images.jianshu.io/upload_images/4944427-b5a1093ace42448b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n4. 其他改变作用域的情况\n一般作用域链的顺序是按照调用的顺序排列的，但是特殊情况下会改变。\n- with\n执行with语句时，会将with带入的对象压入作用域链，导致调用深度发生变化。\n```\nfunctioninitUI(){\n    with(document){\n        var bd= body,\n        links=getElementsByTagName_r(\"a\"),\n        i=0,\n        len= links.length;\n        while(i<len){\n        update(links[i++]);\n        }\n        getElementById(\"go-btn\").onclick=function(){\n        start();\n        };\n        bd.className =\"active\";\n    }\n}\n```\n![with.png](http://upload-images.jianshu.io/upload_images/4944427-71b9617f98d995b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n- try-catch\n类似with，当try块发生异常时，程序跳转到catch子句，并且把异常对象压入作用域首位。catch子句执行完作用域链恢复之前的状态。由于加深了调用深度，如果在catch子句执行操作会造成性能问题。可以采用错误处理函数的方式，改变作用域链的状态，从而减少调用深度。\n```\ntry{\n    methodThatMightCauseAnError();\n}catch (ex){\n    handleError(ex);//delegate tohandlermethod\n}\n```\n### 标识符解析的性能\n在执行环境的作用域链中，一个标识符的位置越深，他的读写速度就越慢，因此函数中读写局部变量是最快的，读写全局变量通常是最慢的。\n改进办法，通过赋值给局部变量，改变标识符的深度，从而提高读写速度。\n```\nfor(var i = 0; i < document.getElementsByTagName(\"a\").length; i++){\n    document.getElementsByTagName(\"a\")[i].class = 'active'\n}\n//改进后\nvar list = document.getElementsByTagName(\"a\");\nfor(var i = 0; i < list.length; i++){\n    list[i].class = 'active'\n}\n```","slug":"FE/js/高性能JavaScript-作用域链","published":1,"updated":"2018-01-10T13:32:29.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci4a000p80cmkp2j2yir","content":"<h2 id=\"数据存取\"><a href=\"#数据存取\" class=\"headerlink\" title=\"数据存取\"></a>数据存取</h2><p>JS中有如下四种基本数据的存取：</p>\n<ul>\n<li>字面量：字符串、数字、布尔值、对象、数组、函数、正则表达式、null和undefined。</li>\n<li>本地变量：var/let 定义的数据存储单元。</li>\n<li>数组元素</li>\n<li>对象成员<br>通常情况下，访问速度排序：字面量 &gt; 本地变量 &gt; 数组元素 &gt; 对象成员。个别浏览器的版本，可能有细微差别。<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3>执行环境/运行期上下文(execution context): 是指当前变量或函数有权访问的其它数据。每个执行环境都有一个与之关联的变量对象(variable object, VO)，VO是不能直接访问的，执行环境中定义的所有变量和函数都会保存在这个对象中，解析器在处理数据的时候就会访问这个内部对象。<br>全局执行环境是最外层的一个执行环境，在web浏览器中全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和成员函数创建的。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，控制权返回到之前的执行环境中，全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。<br>每一个JS函数可以看做是Function对象的一个实例，并且含有一个内部属性[[Scopes]],[[Scopes]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为作用域链，它决定哪些数据能被函数访问。函数作用域中的每个对象被称为一个可变对象，每个可变对象都是以“key-value”形式存在。<br>典型的作用域链：</li>\n</ul>\n<ol>\n<li>函数创建时<br>此时函数的作用域链会压入第一个作用域对象，即创建此函数的作用域中可访问的数据对象填充。如下图所示：</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-48ee5069cc4bba9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope1.png\"></p>\n<p>注意：这个作用域对象是可变的，可以理解为这个对象是引用的。<br>具体对象信息可以在chrome dev tool中查看，如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-2f9ebf872328209d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope1-tool.png\"></p>\n<ol>\n<li>函数执行时<br>每次执行函数时都会创建一个执行环境，每个执行环境都是独一无二的，多次调用函数就会导致创建多个执行环境。此时会将会将一个被称为“活动对象”(activation object,AO)的新对象作为第二个作用域对象压入作用域链。如下图所示:</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-9709f477eae42387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope2.png\"></p>\n<p>在函数的执行过程中，每遇到一个变量或者函数，都会在作用域链中按照顺序进行查找，直到遍历所有的作用域，此过程会影响运行性能。</p>\n<ol>\n<li>闭包时的作用域<br>如下一段代码中，包含了闭包<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functionassignEvents()&#123;</span><br><span class=\"line\">    var id= &quot;xdi9592&quot;;</span><br><span class=\"line\">    document.getElementById(&quot;save-btn&quot;).onclick =function(event)&#123;</span><br><span class=\"line\">        saveDocument(id);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-98c7ce04672a331c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope3.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-b5a1093ace42448b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope3-tool.png\"></p>\n<ol>\n<li>其他改变作用域的情况<br>一般作用域链的顺序是按照调用的顺序排列的，但是特殊情况下会改变。</li>\n</ol>\n<ul>\n<li>with<br>执行with语句时，会将with带入的对象压入作用域链，导致调用深度发生变化。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functioninitUI()&#123;</span><br><span class=\"line\">    with(document)&#123;</span><br><span class=\"line\">        var bd= body,</span><br><span class=\"line\">        links=getElementsByTagName_r(&quot;a&quot;),</span><br><span class=\"line\">        i=0,</span><br><span class=\"line\">        len= links.length;</span><br><span class=\"line\">        while(i&lt;len)&#123;</span><br><span class=\"line\">        update(links[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getElementById(&quot;go-btn&quot;).onclick=function()&#123;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bd.className =&quot;active&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-71b9617f98d995b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"with.png\"></p>\n<ul>\n<li>try-catch<br>类似with，当try块发生异常时，程序跳转到catch子句，并且把异常对象压入作用域首位。catch子句执行完作用域链恢复之前的状态。由于加深了调用深度，如果在catch子句执行操作会造成性能问题。可以采用错误处理函数的方式，改变作用域链的状态，从而减少调用深度。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    methodThatMightCauseAnError();</span><br><span class=\"line\">&#125;catch (ex)&#123;</span><br><span class=\"line\">    handleError(ex);//delegate tohandlermethod</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"标识符解析的性能\"><a href=\"#标识符解析的性能\" class=\"headerlink\" title=\"标识符解析的性能\"></a>标识符解析的性能</h3><p>在执行环境的作用域链中，一个标识符的位置越深，他的读写速度就越慢，因此函数中读写局部变量是最快的，读写全局变量通常是最慢的。<br>改进办法，通过赋值给局部变量，改变标识符的深度，从而提高读写速度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; document.getElementsByTagName(&quot;a&quot;).length; i++)&#123;</span><br><span class=\"line\">    document.getElementsByTagName(&quot;a&quot;)[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var list = document.getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">for(var i = 0; i &lt; list.length; i++)&#123;</span><br><span class=\"line\">    list[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据存取\"><a href=\"#数据存取\" class=\"headerlink\" title=\"数据存取\"></a>数据存取</h2><p>JS中有如下四种基本数据的存取：</p>\n<ul>\n<li>字面量：字符串、数字、布尔值、对象、数组、函数、正则表达式、null和undefined。</li>\n<li>本地变量：var/let 定义的数据存储单元。</li>\n<li>数组元素</li>\n<li>对象成员<br>通常情况下，访问速度排序：字面量 &gt; 本地变量 &gt; 数组元素 &gt; 对象成员。个别浏览器的版本，可能有细微差别。<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3>执行环境/运行期上下文(execution context): 是指当前变量或函数有权访问的其它数据。每个执行环境都有一个与之关联的变量对象(variable object, VO)，VO是不能直接访问的，执行环境中定义的所有变量和函数都会保存在这个对象中，解析器在处理数据的时候就会访问这个内部对象。<br>全局执行环境是最外层的一个执行环境，在web浏览器中全局执行环境是window对象，因此所有全局变量和函数都是作为window对象的属性和成员函数创建的。每个函数都有自己的执行环境，当执行流进入一个函数的时候，函数的环境会被推入一个函数栈中，而在函数执行完毕后执行环境出栈并被销毁，保存在其中的所有变量和函数定义随之销毁，控制权返回到之前的执行环境中，全局的执行环境在应用程序退出（浏览器关闭）才会被销毁。<br>每一个JS函数可以看做是Function对象的一个实例，并且含有一个内部属性[[Scopes]],[[Scopes]]包含了一个函数被创建的作用域中对象的集合。这个集合被称为作用域链，它决定哪些数据能被函数访问。函数作用域中的每个对象被称为一个可变对象，每个可变对象都是以“key-value”形式存在。<br>典型的作用域链：</li>\n</ul>\n<ol>\n<li>函数创建时<br>此时函数的作用域链会压入第一个作用域对象，即创建此函数的作用域中可访问的数据对象填充。如下图所示：</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-48ee5069cc4bba9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope1.png\"></p>\n<p>注意：这个作用域对象是可变的，可以理解为这个对象是引用的。<br>具体对象信息可以在chrome dev tool中查看，如下图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-2f9ebf872328209d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope1-tool.png\"></p>\n<ol>\n<li>函数执行时<br>每次执行函数时都会创建一个执行环境，每个执行环境都是独一无二的，多次调用函数就会导致创建多个执行环境。此时会将会将一个被称为“活动对象”(activation object,AO)的新对象作为第二个作用域对象压入作用域链。如下图所示:</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-9709f477eae42387.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope2.png\"></p>\n<p>在函数的执行过程中，每遇到一个变量或者函数，都会在作用域链中按照顺序进行查找，直到遍历所有的作用域，此过程会影响运行性能。</p>\n<ol>\n<li>闭包时的作用域<br>如下一段代码中，包含了闭包<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functionassignEvents()&#123;</span><br><span class=\"line\">    var id= &quot;xdi9592&quot;;</span><br><span class=\"line\">    document.getElementById(&quot;save-btn&quot;).onclick =function(event)&#123;</span><br><span class=\"line\">        saveDocument(id);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-98c7ce04672a331c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope3.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-b5a1093ace42448b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scope3-tool.png\"></p>\n<ol>\n<li>其他改变作用域的情况<br>一般作用域链的顺序是按照调用的顺序排列的，但是特殊情况下会改变。</li>\n</ol>\n<ul>\n<li>with<br>执行with语句时，会将with带入的对象压入作用域链，导致调用深度发生变化。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">functioninitUI()&#123;</span><br><span class=\"line\">    with(document)&#123;</span><br><span class=\"line\">        var bd= body,</span><br><span class=\"line\">        links=getElementsByTagName_r(&quot;a&quot;),</span><br><span class=\"line\">        i=0,</span><br><span class=\"line\">        len= links.length;</span><br><span class=\"line\">        while(i&lt;len)&#123;</span><br><span class=\"line\">        update(links[i++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getElementById(&quot;go-btn&quot;).onclick=function()&#123;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bd.className =&quot;active&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4944427-71b9617f98d995b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"with.png\"></p>\n<ul>\n<li>try-catch<br>类似with，当try块发生异常时，程序跳转到catch子句，并且把异常对象压入作用域首位。catch子句执行完作用域链恢复之前的状态。由于加深了调用深度，如果在catch子句执行操作会造成性能问题。可以采用错误处理函数的方式，改变作用域链的状态，从而减少调用深度。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    methodThatMightCauseAnError();</span><br><span class=\"line\">&#125;catch (ex)&#123;</span><br><span class=\"line\">    handleError(ex);//delegate tohandlermethod</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"标识符解析的性能\"><a href=\"#标识符解析的性能\" class=\"headerlink\" title=\"标识符解析的性能\"></a>标识符解析的性能</h3><p>在执行环境的作用域链中，一个标识符的位置越深，他的读写速度就越慢，因此函数中读写局部变量是最快的，读写全局变量通常是最慢的。<br>改进办法，通过赋值给局部变量，改变标识符的深度，从而提高读写速度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; document.getElementsByTagName(&quot;a&quot;).length; i++)&#123;</span><br><span class=\"line\">    document.getElementsByTagName(&quot;a&quot;)[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var list = document.getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">for(var i = 0; i &lt; list.length; i++)&#123;</span><br><span class=\"line\">    list[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"使用Protractor进行web功能测试","date":"2018-01-10T13:21:34.000Z","_content":"本文介绍了使用Protractor对AngularJS开发的web应用进行自动化功能测试的方案和详细操作指导。\n### 名词解释\nProtractor是AngularJS团队发布的一款开源的端到端web测试运行工具。它可以模拟用户的实际交互，帮助验证Angular应用的实际运行状况。Protractor使用Jasmine测试框架来定义测试用例。Protractor为不同的页面交互提供一套健壮的API。相对于其他的端到端的工具，Protractor有着自己的优势，它知道怎么和AngularJS的代码一起运行，特别是应对$digest循环。\n### 环境安装\n1. 首先必须安装执行环境nodejs\n2. 安装浏览器，推荐chrome\n3. 安装protractor+webdriver\n\t\tnpm install protractor -g\n\t\twebdriver-manager update \n4. 安装完成后执行protractor --version，检查安装是否正常\n5. 在命令行控制台启动Selenium测试服务器。\n\t\twebdriver-manager start\n\t\t//默认情况下，Selenium测试服务器接入地址为：http://localhost:4444/wd/hub\n6. 输出测试报告需要安装相关插件\n\t\t//输出html报告\n\t\tnpm install protractor-jasmine2-html-reporter -g\n\t\t//输出junit格式的xml报告\n\t\tnpm install jasmine-reporters -g\n\t\t//由于需要在config文件中加载。一般把这两个插件放在根目录的node_modules 目录下\n\n\n### 工程配置\n配置文件举例如下：\n```javascript\nvar Jasmine2HtmlReporter = require('./node_modules/protractor-jasmine2-html-reporter');\nvar report = require('./node_modules/jasmine-reporters');\nexports.config = {\n  // Selenium server 测试服务器接入地址\n  SeleniumAddress: 'http://localhost:4444/wd/hub',\n  // 测试服务器的配置信息\n  multiCapabilities: [{\n    browserName: 'firefox'\n  },{\n    browserName: 'chrome',\n    'chromeOptions': {\n            'args': ['incognito', 'disable-extensions', 'start-maximized']\n        }\n  }],\n  // 需要运行的测试程序代码文件列表\n  suites: {\n    scan: 'tc/e2e/scan.js',\n    app: 'tc/e2e/app.js',\n    hppd: 'tc/e2e/hppd.js'\n  },\n  // 选择使用 jasmine 作为JavaScript语言的测试框架\n  framework: 'jasmine',\n  jasmineNodeOpts: {\n    showColors: true,\n    defaultTimeoutInterval: 30000,\n    isVerbose: true,\n    includeStackTrace: false\n  },\n  //输出测试报告\n  onPrepare: function(){\n    jasmine.getEnv().addReporter(\n        new Jasmine2HtmlReporter({\n          savePath: 'report/e2e/',\n          takeScreenshots: true,  //是否截屏\n          takeScreenshotsOnlyOnFailures: true //测试用例执行失败时才截屏\n        })\n      );\n    jasmine.getEnv().addReporter(\n      new report.JUnitXmlReporter({\n          savePath: 'report/tc/e2e/',\n          consolidateAll: false,\n          filePrefix:'',\n          package:'E2E'\n      })\n    );\n  }\n};\n```\n### 测试用例怎么写\n测试用例是基于jasmine框架，关于用例描述和断言比较，请参考上一篇帖子[《基于karma+jasmine的web前端自动化测试》](https://my.oschina.net/u/2492371/blog/796382 \"《基于karma+jasmine的web前端自动化测试》\")，这里不再赘述了\n这里举一个简单的例子。\n```javascript\nvar DOMAIN = '127.0.0.1';\nvar TARGET_ROOT = 'http://'+DOMAIN;\ndescribe('scan all app', function() {\n\tbeforeAll(function() {\n        // 设置cookie\n        var cookieObj = {\n            \"real_name\":\"放松一下\",\n            \"dept_name\":\"开发部\",\n            \"avatar\":\"/images/u15.png\",\n            \"message\":\"22\"\n        };\n        browser.get(TARGET_ROOT + '/index/about.html');\n        browser.manage().deleteAllCookies().then(function () {\n               \tbrowser.manage().addCookie(\"login_user\",JSON.stringify(JSON.stringify(cookieObj)), '/', DOMAIN);\n        });\n\t});\n    \n    it('app.code', function() {\n    \tbrowser.get(TARGET_ROOT + '/app/code/');        \n    \texpect(element.all(by.binding(\"project['name']\")).count()).toBeGreaterThan(1);\n    });\n   \n    it('app.ci', function() {\n    \tbrowser.get(TARGET_ROOT + '/app/ci/');        \n    \texpect(element(by.binding('userInfo.realName')).getText()).toEqual('李忠伟10183089');\n    });\n});\n```\n上述事例主要使用了如下接口：\n1.  browser.get(url) 访问url指定的web页面\n2.  browser.manage().deleteAllCookies() 删除所有cookie\n3.  browser.manage().addCookie(key,value) 添加cookie\n4.  element.all(locator) 查找locator描述的所有元素\n5.  element(locator)  查找locator描述的单个元素\n\n### #浏览器的相关操作\n这里举例常用的几个操作，详细的请见参考资料。\n```javascript\nbrowser.get(url)   //访问url指定的web页面\nbrowser.close()   //关闭当前窗口\nbrowser.sleep(ms)   //等待，单位毫秒\nbrowser.pause()  //暂停执行，停止在当前页面，主要用于调试\n```\n\n### #如何定位元素\n上述示例中提到的by.binding，用于定位元素，被称为定位器locator。Protractor中常用的定位器有如下几种：\n```javascript\nby.id('myElement')   //id为myElement的元素\nby.css('[class=\"element\"]')   //根据元素的属性定位元素，此例为样式class为element的元素。同时也支持jquery的selector语法来定位元素，例如（by.css('.element')）。\nby.binding('list.title')    //绑定了ng-bind=\"list.title\"的元素\nby.repeater('modules.content')    //绑定了ng-repeat=\"module in modules.content\"的元素\nby.model('person.name')  //绑定了ng-model=\"person.nam\"的元素\n```\n更多定位器请见参考资料。\n\n### 定位的元素如何操作\nProtractor中使用element(locator)和element.all(locator)来定位元素，前者是定位单个元素，后者是定位所有符合条件的元素。定位到元素后能做哪些操作？常用操作举例如下：\n```javascript\nelement.all(by.binding('list.title')).count()   //返回查找到的元素的个数\nelement.all(by.css('.element')).get(1)  //返回定查找到的元素中的第二个元素\nelement(by.css('.myname')).getText()  //返回查找到的元素的text\nelement(by.id('user_name').sendKeys('user1')    //向查找到的元素输入'user1'\nelement(by.id('user_desc').sendKeys(protractor.Key.ENTER);    //向查找到的元素输入回车键\nelement(by.id('user_desc').sendKeys(protractor.Key.TAB);    //向查找到的元素输入TAB键\nelement(by.id('user_name')).clear();   //清空查找到的元素的内容\nelement(by.id('submit')).clear();   //点击查找到的元素\n```\n\n### 参考资料\n[Protractor官网，不过被墙了，你懂的。](http://www.protractortest.org/ \"Protractor官网，不过被墙了，你懂的。\")\n[《Protractor入门》推荐！有可能被墙](http://ramonvictor.github.io/protractor/slides/#/1 \"《Protractor入门》推荐！有可能被墙\")\n[示例比较多的指导书](http://timothymartin.azurewebsites.net/protractor-cheat-sheet/ \"示例比较多的指导书\")\n[《浏览器r相关接口文档》](http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.protractor.html \"《浏览器相关接口文档》\")\n[《元素操作的相关接口文档》](http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.webelement.html \"《元素操作的相关接口文档》\")","source":"_posts/FE/test/使用Protractor进行web功能测试.md","raw":"---\ntitle: 使用Protractor进行web功能测试\ndate: 2018-01-10 21:21:34\ntags: [JS,自动化,测试,工具]\n---\n本文介绍了使用Protractor对AngularJS开发的web应用进行自动化功能测试的方案和详细操作指导。\n### 名词解释\nProtractor是AngularJS团队发布的一款开源的端到端web测试运行工具。它可以模拟用户的实际交互，帮助验证Angular应用的实际运行状况。Protractor使用Jasmine测试框架来定义测试用例。Protractor为不同的页面交互提供一套健壮的API。相对于其他的端到端的工具，Protractor有着自己的优势，它知道怎么和AngularJS的代码一起运行，特别是应对$digest循环。\n### 环境安装\n1. 首先必须安装执行环境nodejs\n2. 安装浏览器，推荐chrome\n3. 安装protractor+webdriver\n\t\tnpm install protractor -g\n\t\twebdriver-manager update \n4. 安装完成后执行protractor --version，检查安装是否正常\n5. 在命令行控制台启动Selenium测试服务器。\n\t\twebdriver-manager start\n\t\t//默认情况下，Selenium测试服务器接入地址为：http://localhost:4444/wd/hub\n6. 输出测试报告需要安装相关插件\n\t\t//输出html报告\n\t\tnpm install protractor-jasmine2-html-reporter -g\n\t\t//输出junit格式的xml报告\n\t\tnpm install jasmine-reporters -g\n\t\t//由于需要在config文件中加载。一般把这两个插件放在根目录的node_modules 目录下\n\n\n### 工程配置\n配置文件举例如下：\n```javascript\nvar Jasmine2HtmlReporter = require('./node_modules/protractor-jasmine2-html-reporter');\nvar report = require('./node_modules/jasmine-reporters');\nexports.config = {\n  // Selenium server 测试服务器接入地址\n  SeleniumAddress: 'http://localhost:4444/wd/hub',\n  // 测试服务器的配置信息\n  multiCapabilities: [{\n    browserName: 'firefox'\n  },{\n    browserName: 'chrome',\n    'chromeOptions': {\n            'args': ['incognito', 'disable-extensions', 'start-maximized']\n        }\n  }],\n  // 需要运行的测试程序代码文件列表\n  suites: {\n    scan: 'tc/e2e/scan.js',\n    app: 'tc/e2e/app.js',\n    hppd: 'tc/e2e/hppd.js'\n  },\n  // 选择使用 jasmine 作为JavaScript语言的测试框架\n  framework: 'jasmine',\n  jasmineNodeOpts: {\n    showColors: true,\n    defaultTimeoutInterval: 30000,\n    isVerbose: true,\n    includeStackTrace: false\n  },\n  //输出测试报告\n  onPrepare: function(){\n    jasmine.getEnv().addReporter(\n        new Jasmine2HtmlReporter({\n          savePath: 'report/e2e/',\n          takeScreenshots: true,  //是否截屏\n          takeScreenshotsOnlyOnFailures: true //测试用例执行失败时才截屏\n        })\n      );\n    jasmine.getEnv().addReporter(\n      new report.JUnitXmlReporter({\n          savePath: 'report/tc/e2e/',\n          consolidateAll: false,\n          filePrefix:'',\n          package:'E2E'\n      })\n    );\n  }\n};\n```\n### 测试用例怎么写\n测试用例是基于jasmine框架，关于用例描述和断言比较，请参考上一篇帖子[《基于karma+jasmine的web前端自动化测试》](https://my.oschina.net/u/2492371/blog/796382 \"《基于karma+jasmine的web前端自动化测试》\")，这里不再赘述了\n这里举一个简单的例子。\n```javascript\nvar DOMAIN = '127.0.0.1';\nvar TARGET_ROOT = 'http://'+DOMAIN;\ndescribe('scan all app', function() {\n\tbeforeAll(function() {\n        // 设置cookie\n        var cookieObj = {\n            \"real_name\":\"放松一下\",\n            \"dept_name\":\"开发部\",\n            \"avatar\":\"/images/u15.png\",\n            \"message\":\"22\"\n        };\n        browser.get(TARGET_ROOT + '/index/about.html');\n        browser.manage().deleteAllCookies().then(function () {\n               \tbrowser.manage().addCookie(\"login_user\",JSON.stringify(JSON.stringify(cookieObj)), '/', DOMAIN);\n        });\n\t});\n    \n    it('app.code', function() {\n    \tbrowser.get(TARGET_ROOT + '/app/code/');        \n    \texpect(element.all(by.binding(\"project['name']\")).count()).toBeGreaterThan(1);\n    });\n   \n    it('app.ci', function() {\n    \tbrowser.get(TARGET_ROOT + '/app/ci/');        \n    \texpect(element(by.binding('userInfo.realName')).getText()).toEqual('李忠伟10183089');\n    });\n});\n```\n上述事例主要使用了如下接口：\n1.  browser.get(url) 访问url指定的web页面\n2.  browser.manage().deleteAllCookies() 删除所有cookie\n3.  browser.manage().addCookie(key,value) 添加cookie\n4.  element.all(locator) 查找locator描述的所有元素\n5.  element(locator)  查找locator描述的单个元素\n\n### #浏览器的相关操作\n这里举例常用的几个操作，详细的请见参考资料。\n```javascript\nbrowser.get(url)   //访问url指定的web页面\nbrowser.close()   //关闭当前窗口\nbrowser.sleep(ms)   //等待，单位毫秒\nbrowser.pause()  //暂停执行，停止在当前页面，主要用于调试\n```\n\n### #如何定位元素\n上述示例中提到的by.binding，用于定位元素，被称为定位器locator。Protractor中常用的定位器有如下几种：\n```javascript\nby.id('myElement')   //id为myElement的元素\nby.css('[class=\"element\"]')   //根据元素的属性定位元素，此例为样式class为element的元素。同时也支持jquery的selector语法来定位元素，例如（by.css('.element')）。\nby.binding('list.title')    //绑定了ng-bind=\"list.title\"的元素\nby.repeater('modules.content')    //绑定了ng-repeat=\"module in modules.content\"的元素\nby.model('person.name')  //绑定了ng-model=\"person.nam\"的元素\n```\n更多定位器请见参考资料。\n\n### 定位的元素如何操作\nProtractor中使用element(locator)和element.all(locator)来定位元素，前者是定位单个元素，后者是定位所有符合条件的元素。定位到元素后能做哪些操作？常用操作举例如下：\n```javascript\nelement.all(by.binding('list.title')).count()   //返回查找到的元素的个数\nelement.all(by.css('.element')).get(1)  //返回定查找到的元素中的第二个元素\nelement(by.css('.myname')).getText()  //返回查找到的元素的text\nelement(by.id('user_name').sendKeys('user1')    //向查找到的元素输入'user1'\nelement(by.id('user_desc').sendKeys(protractor.Key.ENTER);    //向查找到的元素输入回车键\nelement(by.id('user_desc').sendKeys(protractor.Key.TAB);    //向查找到的元素输入TAB键\nelement(by.id('user_name')).clear();   //清空查找到的元素的内容\nelement(by.id('submit')).clear();   //点击查找到的元素\n```\n\n### 参考资料\n[Protractor官网，不过被墙了，你懂的。](http://www.protractortest.org/ \"Protractor官网，不过被墙了，你懂的。\")\n[《Protractor入门》推荐！有可能被墙](http://ramonvictor.github.io/protractor/slides/#/1 \"《Protractor入门》推荐！有可能被墙\")\n[示例比较多的指导书](http://timothymartin.azurewebsites.net/protractor-cheat-sheet/ \"示例比较多的指导书\")\n[《浏览器r相关接口文档》](http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.protractor.html \"《浏览器相关接口文档》\")\n[《元素操作的相关接口文档》](http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.webelement.html \"《元素操作的相关接口文档》\")","slug":"FE/test/使用Protractor进行web功能测试","published":1,"updated":"2018-01-10T13:30:24.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci4e000q80cm97orzr7v","content":"<p>本文介绍了使用Protractor对AngularJS开发的web应用进行自动化功能测试的方案和详细操作指导。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>Protractor是AngularJS团队发布的一款开源的端到端web测试运行工具。它可以模拟用户的实际交互，帮助验证Angular应用的实际运行状况。Protractor使用Jasmine测试框架来定义测试用例。Protractor为不同的页面交互提供一套健壮的API。相对于其他的端到端的工具，Protractor有着自己的优势，它知道怎么和AngularJS的代码一起运行，特别是应对$digest循环。</p>\n<h3 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h3><ol>\n<li>首先必须安装执行环境nodejs</li>\n<li>安装浏览器，推荐chrome</li>\n<li>安装protractor+webdriver<pre><code>npm install protractor -g\nwebdriver-manager update \n</code></pre></li>\n<li>安装完成后执行protractor –version，检查安装是否正常</li>\n<li>在命令行控制台启动Selenium测试服务器。<pre><code>webdriver-manager start\n//默认情况下，Selenium测试服务器接入地址为：http://localhost:4444/wd/hub\n</code></pre></li>\n<li>输出测试报告需要安装相关插件<pre><code>//输出html报告\nnpm install protractor-jasmine2-html-reporter -g\n//输出junit格式的xml报告\nnpm install jasmine-reporters -g\n//由于需要在config文件中加载。一般把这两个插件放在根目录的node_modules 目录下\n</code></pre></li>\n</ol>\n<h3 id=\"工程配置\"><a href=\"#工程配置\" class=\"headerlink\" title=\"工程配置\"></a>工程配置</h3><p>配置文件举例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Jasmine2HtmlReporter = <span class=\"built_in\">require</span>(<span class=\"string\">'./node_modules/protractor-jasmine2-html-reporter'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> report = <span class=\"built_in\">require</span>(<span class=\"string\">'./node_modules/jasmine-reporters'</span>);</span><br><span class=\"line\">exports.config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Selenium server 测试服务器接入地址</span></span><br><span class=\"line\">  SeleniumAddress: <span class=\"string\">'http://localhost:4444/wd/hub'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 测试服务器的配置信息</span></span><br><span class=\"line\">  multiCapabilities: [&#123;</span><br><span class=\"line\">    browserName: <span class=\"string\">'firefox'</span></span><br><span class=\"line\">  &#125;,&#123;</span><br><span class=\"line\">    browserName: <span class=\"string\">'chrome'</span>,</span><br><span class=\"line\">    <span class=\"string\">'chromeOptions'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'args'</span>: [<span class=\"string\">'incognito'</span>, <span class=\"string\">'disable-extensions'</span>, <span class=\"string\">'start-maximized'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  <span class=\"comment\">// 需要运行的测试程序代码文件列表</span></span><br><span class=\"line\">  suites: &#123;</span><br><span class=\"line\">    scan: <span class=\"string\">'tc/e2e/scan.js'</span>,</span><br><span class=\"line\">    app: <span class=\"string\">'tc/e2e/app.js'</span>,</span><br><span class=\"line\">    hppd: <span class=\"string\">'tc/e2e/hppd.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 选择使用 jasmine 作为JavaScript语言的测试框架</span></span><br><span class=\"line\">  framework: <span class=\"string\">'jasmine'</span>,</span><br><span class=\"line\">  jasmineNodeOpts: &#123;</span><br><span class=\"line\">    showColors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    defaultTimeoutInterval: <span class=\"number\">30000</span>,</span><br><span class=\"line\">    isVerbose: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    includeStackTrace: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//输出测试报告</span></span><br><span class=\"line\">  onPrepare: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    jasmine.getEnv().addReporter(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Jasmine2HtmlReporter(&#123;</span><br><span class=\"line\">          savePath: <span class=\"string\">'report/e2e/'</span>,</span><br><span class=\"line\">          takeScreenshots: <span class=\"literal\">true</span>,  <span class=\"comment\">//是否截屏</span></span><br><span class=\"line\">          takeScreenshotsOnlyOnFailures: <span class=\"literal\">true</span> <span class=\"comment\">//测试用例执行失败时才截屏</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    jasmine.getEnv().addReporter(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> report.JUnitXmlReporter(&#123;</span><br><span class=\"line\">          savePath: <span class=\"string\">'report/tc/e2e/'</span>,</span><br><span class=\"line\">          consolidateAll: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          filePrefix:<span class=\"string\">''</span>,</span><br><span class=\"line\">          package:<span class=\"string\">'E2E'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例怎么写\"><a href=\"#测试用例怎么写\" class=\"headerlink\" title=\"测试用例怎么写\"></a>测试用例怎么写</h3><p>测试用例是基于jasmine框架，关于用例描述和断言比较，请参考上一篇帖子<a href=\"https://my.oschina.net/u/2492371/blog/796382\" title=\"《基于karma+jasmine的web前端自动化测试》\" target=\"_blank\" rel=\"noopener\">《基于karma+jasmine的web前端自动化测试》</a>，这里不再赘述了<br>这里举一个简单的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DOMAIN = <span class=\"string\">'127.0.0.1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> TARGET_ROOT = <span class=\"string\">'http://'</span>+DOMAIN;</span><br><span class=\"line\">describe(<span class=\"string\">'scan all app'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tbeforeAll(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置cookie</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> cookieObj = &#123;</span><br><span class=\"line\">            <span class=\"string\">\"real_name\"</span>:<span class=\"string\">\"放松一下\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"dept_name\"</span>:<span class=\"string\">\"开发部\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"avatar\"</span>:<span class=\"string\">\"/images/u15.png\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"message\"</span>:<span class=\"string\">\"22\"</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        browser.get(TARGET_ROOT + <span class=\"string\">'/index/about.html'</span>);</span><br><span class=\"line\">        browser.manage().deleteAllCookies().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               \tbrowser.manage().addCookie(<span class=\"string\">\"login_user\"</span>,<span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">JSON</span>.stringify(cookieObj)), <span class=\"string\">'/'</span>, DOMAIN);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(<span class=\"string\">'app.code'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \tbrowser.get(TARGET_ROOT + <span class=\"string\">'/app/code/'</span>);        </span><br><span class=\"line\">    \texpect(element.all(by.binding(<span class=\"string\">\"project['name']\"</span>)).count()).toBeGreaterThan(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   </span><br><span class=\"line\">    it(<span class=\"string\">'app.ci'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \tbrowser.get(TARGET_ROOT + <span class=\"string\">'/app/ci/'</span>);        </span><br><span class=\"line\">    \texpect(element(by.binding(<span class=\"string\">'userInfo.realName'</span>)).getText()).toEqual(<span class=\"string\">'李忠伟10183089'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述事例主要使用了如下接口：</p>\n<ol>\n<li>browser.get(url) 访问url指定的web页面</li>\n<li>browser.manage().deleteAllCookies() 删除所有cookie</li>\n<li>browser.manage().addCookie(key,value) 添加cookie</li>\n<li>element.all(locator) 查找locator描述的所有元素</li>\n<li>element(locator)  查找locator描述的单个元素</li>\n</ol>\n<h3 id=\"浏览器的相关操作\"><a href=\"#浏览器的相关操作\" class=\"headerlink\" title=\"#浏览器的相关操作\"></a>#浏览器的相关操作</h3><p>这里举例常用的几个操作，详细的请见参考资料。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser.get(url)   <span class=\"comment\">//访问url指定的web页面</span></span><br><span class=\"line\">browser.close()   <span class=\"comment\">//关闭当前窗口</span></span><br><span class=\"line\">browser.sleep(ms)   <span class=\"comment\">//等待，单位毫秒</span></span><br><span class=\"line\">browser.pause()  <span class=\"comment\">//暂停执行，停止在当前页面，主要用于调试</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何定位元素\"><a href=\"#如何定位元素\" class=\"headerlink\" title=\"#如何定位元素\"></a>#如何定位元素</h3><p>上述示例中提到的by.binding，用于定位元素，被称为定位器locator。Protractor中常用的定位器有如下几种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">by.id(<span class=\"string\">'myElement'</span>)   <span class=\"comment\">//id为myElement的元素</span></span><br><span class=\"line\">by.css(<span class=\"string\">'[class=\"element\"]'</span>)   <span class=\"comment\">//根据元素的属性定位元素，此例为样式class为element的元素。同时也支持jquery的selector语法来定位元素，例如（by.css('.element')）。</span></span><br><span class=\"line\">by.binding(<span class=\"string\">'list.title'</span>)    <span class=\"comment\">//绑定了ng-bind=\"list.title\"的元素</span></span><br><span class=\"line\">by.repeater(<span class=\"string\">'modules.content'</span>)    <span class=\"comment\">//绑定了ng-repeat=\"module in modules.content\"的元素</span></span><br><span class=\"line\">by.model(<span class=\"string\">'person.name'</span>)  <span class=\"comment\">//绑定了ng-model=\"person.nam\"的元素</span></span><br></pre></td></tr></table></figure></p>\n<p>更多定位器请见参考资料。</p>\n<h3 id=\"定位的元素如何操作\"><a href=\"#定位的元素如何操作\" class=\"headerlink\" title=\"定位的元素如何操作\"></a>定位的元素如何操作</h3><p>Protractor中使用element(locator)和element.all(locator)来定位元素，前者是定位单个元素，后者是定位所有符合条件的元素。定位到元素后能做哪些操作？常用操作举例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.all(by.binding(<span class=\"string\">'list.title'</span>)).count()   <span class=\"comment\">//返回查找到的元素的个数</span></span><br><span class=\"line\">element.all(by.css(<span class=\"string\">'.element'</span>)).get(<span class=\"number\">1</span>)  <span class=\"comment\">//返回定查找到的元素中的第二个元素</span></span><br><span class=\"line\">element(by.css(<span class=\"string\">'.myname'</span>)).getText()  <span class=\"comment\">//返回查找到的元素的text</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_name'</span>).sendKeys(<span class=\"string\">'user1'</span>)    <span class=\"comment\">//向查找到的元素输入'user1'</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_desc'</span>).sendKeys(protractor.Key.ENTER);    <span class=\"comment\">//向查找到的元素输入回车键</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_desc'</span>).sendKeys(protractor.Key.TAB);    <span class=\"comment\">//向查找到的元素输入TAB键</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_name'</span>)).clear();   <span class=\"comment\">//清空查找到的元素的内容</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'submit'</span>)).clear();   <span class=\"comment\">//点击查找到的元素</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.protractortest.org/\" title=\"Protractor官网，不过被墙了，你懂的。\" target=\"_blank\" rel=\"noopener\">Protractor官网，不过被墙了，你懂的。</a><br><a href=\"http://ramonvictor.github.io/protractor/slides/#/1\" title=\"《Protractor入门》推荐！有可能被墙\" target=\"_blank\" rel=\"noopener\">《Protractor入门》推荐！有可能被墙</a><br><a href=\"http://timothymartin.azurewebsites.net/protractor-cheat-sheet/\" title=\"示例比较多的指导书\" target=\"_blank\" rel=\"noopener\">示例比较多的指导书</a><br><a href=\"http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.protractor.html\" title=\"《浏览器相关接口文档》\" target=\"_blank\" rel=\"noopener\">《浏览器r相关接口文档》</a><br><a href=\"http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.webelement.html\" title=\"《元素操作的相关接口文档》\" target=\"_blank\" rel=\"noopener\">《元素操作的相关接口文档》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍了使用Protractor对AngularJS开发的web应用进行自动化功能测试的方案和详细操作指导。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><p>Protractor是AngularJS团队发布的一款开源的端到端web测试运行工具。它可以模拟用户的实际交互，帮助验证Angular应用的实际运行状况。Protractor使用Jasmine测试框架来定义测试用例。Protractor为不同的页面交互提供一套健壮的API。相对于其他的端到端的工具，Protractor有着自己的优势，它知道怎么和AngularJS的代码一起运行，特别是应对$digest循环。</p>\n<h3 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h3><ol>\n<li>首先必须安装执行环境nodejs</li>\n<li>安装浏览器，推荐chrome</li>\n<li>安装protractor+webdriver<pre><code>npm install protractor -g\nwebdriver-manager update \n</code></pre></li>\n<li>安装完成后执行protractor –version，检查安装是否正常</li>\n<li>在命令行控制台启动Selenium测试服务器。<pre><code>webdriver-manager start\n//默认情况下，Selenium测试服务器接入地址为：http://localhost:4444/wd/hub\n</code></pre></li>\n<li>输出测试报告需要安装相关插件<pre><code>//输出html报告\nnpm install protractor-jasmine2-html-reporter -g\n//输出junit格式的xml报告\nnpm install jasmine-reporters -g\n//由于需要在config文件中加载。一般把这两个插件放在根目录的node_modules 目录下\n</code></pre></li>\n</ol>\n<h3 id=\"工程配置\"><a href=\"#工程配置\" class=\"headerlink\" title=\"工程配置\"></a>工程配置</h3><p>配置文件举例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Jasmine2HtmlReporter = <span class=\"built_in\">require</span>(<span class=\"string\">'./node_modules/protractor-jasmine2-html-reporter'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> report = <span class=\"built_in\">require</span>(<span class=\"string\">'./node_modules/jasmine-reporters'</span>);</span><br><span class=\"line\">exports.config = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Selenium server 测试服务器接入地址</span></span><br><span class=\"line\">  SeleniumAddress: <span class=\"string\">'http://localhost:4444/wd/hub'</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 测试服务器的配置信息</span></span><br><span class=\"line\">  multiCapabilities: [&#123;</span><br><span class=\"line\">    browserName: <span class=\"string\">'firefox'</span></span><br><span class=\"line\">  &#125;,&#123;</span><br><span class=\"line\">    browserName: <span class=\"string\">'chrome'</span>,</span><br><span class=\"line\">    <span class=\"string\">'chromeOptions'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'args'</span>: [<span class=\"string\">'incognito'</span>, <span class=\"string\">'disable-extensions'</span>, <span class=\"string\">'start-maximized'</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  <span class=\"comment\">// 需要运行的测试程序代码文件列表</span></span><br><span class=\"line\">  suites: &#123;</span><br><span class=\"line\">    scan: <span class=\"string\">'tc/e2e/scan.js'</span>,</span><br><span class=\"line\">    app: <span class=\"string\">'tc/e2e/app.js'</span>,</span><br><span class=\"line\">    hppd: <span class=\"string\">'tc/e2e/hppd.js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 选择使用 jasmine 作为JavaScript语言的测试框架</span></span><br><span class=\"line\">  framework: <span class=\"string\">'jasmine'</span>,</span><br><span class=\"line\">  jasmineNodeOpts: &#123;</span><br><span class=\"line\">    showColors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    defaultTimeoutInterval: <span class=\"number\">30000</span>,</span><br><span class=\"line\">    isVerbose: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    includeStackTrace: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//输出测试报告</span></span><br><span class=\"line\">  onPrepare: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    jasmine.getEnv().addReporter(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Jasmine2HtmlReporter(&#123;</span><br><span class=\"line\">          savePath: <span class=\"string\">'report/e2e/'</span>,</span><br><span class=\"line\">          takeScreenshots: <span class=\"literal\">true</span>,  <span class=\"comment\">//是否截屏</span></span><br><span class=\"line\">          takeScreenshotsOnlyOnFailures: <span class=\"literal\">true</span> <span class=\"comment\">//测试用例执行失败时才截屏</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      );</span><br><span class=\"line\">    jasmine.getEnv().addReporter(</span><br><span class=\"line\">      <span class=\"keyword\">new</span> report.JUnitXmlReporter(&#123;</span><br><span class=\"line\">          savePath: <span class=\"string\">'report/tc/e2e/'</span>,</span><br><span class=\"line\">          consolidateAll: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          filePrefix:<span class=\"string\">''</span>,</span><br><span class=\"line\">          package:<span class=\"string\">'E2E'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例怎么写\"><a href=\"#测试用例怎么写\" class=\"headerlink\" title=\"测试用例怎么写\"></a>测试用例怎么写</h3><p>测试用例是基于jasmine框架，关于用例描述和断言比较，请参考上一篇帖子<a href=\"https://my.oschina.net/u/2492371/blog/796382\" title=\"《基于karma+jasmine的web前端自动化测试》\" target=\"_blank\" rel=\"noopener\">《基于karma+jasmine的web前端自动化测试》</a>，这里不再赘述了<br>这里举一个简单的例子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DOMAIN = <span class=\"string\">'127.0.0.1'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> TARGET_ROOT = <span class=\"string\">'http://'</span>+DOMAIN;</span><br><span class=\"line\">describe(<span class=\"string\">'scan all app'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tbeforeAll(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置cookie</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> cookieObj = &#123;</span><br><span class=\"line\">            <span class=\"string\">\"real_name\"</span>:<span class=\"string\">\"放松一下\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"dept_name\"</span>:<span class=\"string\">\"开发部\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"avatar\"</span>:<span class=\"string\">\"/images/u15.png\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"message\"</span>:<span class=\"string\">\"22\"</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        browser.get(TARGET_ROOT + <span class=\"string\">'/index/about.html'</span>);</span><br><span class=\"line\">        browser.manage().deleteAllCookies().then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               \tbrowser.manage().addCookie(<span class=\"string\">\"login_user\"</span>,<span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">JSON</span>.stringify(cookieObj)), <span class=\"string\">'/'</span>, DOMAIN);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    it(<span class=\"string\">'app.code'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \tbrowser.get(TARGET_ROOT + <span class=\"string\">'/app/code/'</span>);        </span><br><span class=\"line\">    \texpect(element.all(by.binding(<span class=\"string\">\"project['name']\"</span>)).count()).toBeGreaterThan(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">   </span><br><span class=\"line\">    it(<span class=\"string\">'app.ci'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    \tbrowser.get(TARGET_ROOT + <span class=\"string\">'/app/ci/'</span>);        </span><br><span class=\"line\">    \texpect(element(by.binding(<span class=\"string\">'userInfo.realName'</span>)).getText()).toEqual(<span class=\"string\">'李忠伟10183089'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>上述事例主要使用了如下接口：</p>\n<ol>\n<li>browser.get(url) 访问url指定的web页面</li>\n<li>browser.manage().deleteAllCookies() 删除所有cookie</li>\n<li>browser.manage().addCookie(key,value) 添加cookie</li>\n<li>element.all(locator) 查找locator描述的所有元素</li>\n<li>element(locator)  查找locator描述的单个元素</li>\n</ol>\n<h3 id=\"浏览器的相关操作\"><a href=\"#浏览器的相关操作\" class=\"headerlink\" title=\"#浏览器的相关操作\"></a>#浏览器的相关操作</h3><p>这里举例常用的几个操作，详细的请见参考资料。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser.get(url)   <span class=\"comment\">//访问url指定的web页面</span></span><br><span class=\"line\">browser.close()   <span class=\"comment\">//关闭当前窗口</span></span><br><span class=\"line\">browser.sleep(ms)   <span class=\"comment\">//等待，单位毫秒</span></span><br><span class=\"line\">browser.pause()  <span class=\"comment\">//暂停执行，停止在当前页面，主要用于调试</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何定位元素\"><a href=\"#如何定位元素\" class=\"headerlink\" title=\"#如何定位元素\"></a>#如何定位元素</h3><p>上述示例中提到的by.binding，用于定位元素，被称为定位器locator。Protractor中常用的定位器有如下几种：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">by.id(<span class=\"string\">'myElement'</span>)   <span class=\"comment\">//id为myElement的元素</span></span><br><span class=\"line\">by.css(<span class=\"string\">'[class=\"element\"]'</span>)   <span class=\"comment\">//根据元素的属性定位元素，此例为样式class为element的元素。同时也支持jquery的selector语法来定位元素，例如（by.css('.element')）。</span></span><br><span class=\"line\">by.binding(<span class=\"string\">'list.title'</span>)    <span class=\"comment\">//绑定了ng-bind=\"list.title\"的元素</span></span><br><span class=\"line\">by.repeater(<span class=\"string\">'modules.content'</span>)    <span class=\"comment\">//绑定了ng-repeat=\"module in modules.content\"的元素</span></span><br><span class=\"line\">by.model(<span class=\"string\">'person.name'</span>)  <span class=\"comment\">//绑定了ng-model=\"person.nam\"的元素</span></span><br></pre></td></tr></table></figure></p>\n<p>更多定位器请见参考资料。</p>\n<h3 id=\"定位的元素如何操作\"><a href=\"#定位的元素如何操作\" class=\"headerlink\" title=\"定位的元素如何操作\"></a>定位的元素如何操作</h3><p>Protractor中使用element(locator)和element.all(locator)来定位元素，前者是定位单个元素，后者是定位所有符合条件的元素。定位到元素后能做哪些操作？常用操作举例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.all(by.binding(<span class=\"string\">'list.title'</span>)).count()   <span class=\"comment\">//返回查找到的元素的个数</span></span><br><span class=\"line\">element.all(by.css(<span class=\"string\">'.element'</span>)).get(<span class=\"number\">1</span>)  <span class=\"comment\">//返回定查找到的元素中的第二个元素</span></span><br><span class=\"line\">element(by.css(<span class=\"string\">'.myname'</span>)).getText()  <span class=\"comment\">//返回查找到的元素的text</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_name'</span>).sendKeys(<span class=\"string\">'user1'</span>)    <span class=\"comment\">//向查找到的元素输入'user1'</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_desc'</span>).sendKeys(protractor.Key.ENTER);    <span class=\"comment\">//向查找到的元素输入回车键</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_desc'</span>).sendKeys(protractor.Key.TAB);    <span class=\"comment\">//向查找到的元素输入TAB键</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'user_name'</span>)).clear();   <span class=\"comment\">//清空查找到的元素的内容</span></span><br><span class=\"line\">element(by.id(<span class=\"string\">'submit'</span>)).clear();   <span class=\"comment\">//点击查找到的元素</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://www.protractortest.org/\" title=\"Protractor官网，不过被墙了，你懂的。\" target=\"_blank\" rel=\"noopener\">Protractor官网，不过被墙了，你懂的。</a><br><a href=\"http://ramonvictor.github.io/protractor/slides/#/1\" title=\"《Protractor入门》推荐！有可能被墙\" target=\"_blank\" rel=\"noopener\">《Protractor入门》推荐！有可能被墙</a><br><a href=\"http://timothymartin.azurewebsites.net/protractor-cheat-sheet/\" title=\"示例比较多的指导书\" target=\"_blank\" rel=\"noopener\">示例比较多的指导书</a><br><a href=\"http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.protractor.html\" title=\"《浏览器相关接口文档》\" target=\"_blank\" rel=\"noopener\">《浏览器r相关接口文档》</a><br><a href=\"http://definitelytyped.org/docs/angular-protractor--angular-protractor/classes/protractor.webelement.html\" title=\"《元素操作的相关接口文档》\" target=\"_blank\" rel=\"noopener\">《元素操作的相关接口文档》</a></p>\n"},{"title":"基于karma+jasmine的web前端自动化测试","date":"2018-01-10T13:24:35.000Z","_content":"本文介绍了基于karma+jasmine的web前端自动化测试的方案和详细操作指导。\n### 名词解释\n1. Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n2. Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。\n3. Jasmine 是一个简易的JS单元测试框架。Jasmine 不依赖于任何浏览器、DOM、或者是任何 JavaScript 而存在。它适用于所有网站、Node.js 项目，或者是任何能够在 JavaScript 上面运行的程序。\n\n### 环境安装\n1. 首先必须安装执行环境nodejs\n2. 安装浏览器，推荐chrome（用于运行监听程序，监听js文件变化，自动触发测试执行）\n3. 安装karma+jasmine\n\t\tnpm install karma -g\n\t\tnpm install karma-jasmine -g\n\t\tnpm install karma-chrome-launcher -g \n\t\tnpm install karma-cli -g \n\t\tnpm install karma-coverage -g \n\t\tnpm install karma-html-reporter -g \n4. 安装完成后执行karma -v，检查安装是否正常\n\n### 工程配置\n1. 可以使用karma init，自动生成配置文件，完成部分参数的设置，然后再手动修改。\n2. 当然最快的配置方法，复制下面的配置\n```javascript\n\t\t// Karma configuration\n\t\t// Generated on Tue Nov 01 2016 14:17:00 GMT+0800 (中国标准时间)\n\n\t\tmodule.exports = function(config) {\n\t\t  config.set({\n\t\t  // base path that will be used to resolve all patterns (eg. files, exclude)\n\t\t\tbasePath: '',\n\n        // frameworks to use\n        // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n        frameworks: ['jasmine'],\n    \n        // list of files / patterns to load in the browser\n        //需要加载入浏览器的js文件，包括基础的类库，被测试js文件和测试用例js文件\n        //如果需要测试angular代码，比如引入angular-mock.js，给angular代码进行mock。\n        //注意angular-mock的版本一定要和angular版本一致。可在cdn网站对应的angular版本列表中寻找\n        files: [\n            '../webapp/vender/jquery/jquery-1.10.2.min.js',\n            '../webapp/vender/angular/angular.min.js',\n            '../webapp/vender/angular/angular-ui-router.min.js',\n            'lib/angular-mocks.js',\n            '../webapp/common/*.js',\n            '../webapp/commont/template/*.html',\n            'tc/ut/**/*.js'\n        ],\n    \n        // list of files to exclude\n        exclude: [\n          //'../webapp/vender/**/*.js'\n        ],\n    \n        // test results reporter to use\n        // possible values: 'dots', 'progress'\n        // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n        //这里定义输出的报告\n        //html对应karma-html-reporter组件，输出测试用例执行报告\n        //coverage对应karma-coverage组件，输出测试用例执行报告\n        reporters: ['progress', 'html', 'junit', 'coverage'],\n        junitReporter: {  \n               // will be resolved to basePath (in the same way as files/exclude patterns)  \n              outputFile: 'report/ut/test-results.xml',\n              suite: 'UT',\n              useBrowserName: false \n        },  \n        htmlReporter: {\n          outputDir: 'report/ut',\n          reportName: 'result' //outputDir+reportName组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告\n        },\n        //定义需要统计覆盖率的文件\n        preprocessors: {\n            '../webapp/common/*.js':'coverage', \n            '../webapp/common/template/*.html': 'ng-html2js'\n        },\n        coverageReporter: {  \n            type: 'html', //将覆盖率报告类型type设置为cobertura 或者 html\n            subdir:'coverage', //dir+subdir组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告\n            dir: 'report/ut/'  //代码覆盖率报告生成地址\n        },\n    \n        // web server port\n        port: 9876,\n    \n        // enable / disable colors in the output (reporters and logs)\n        colors: true,\n    \n        // level of logging\n        // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n        logLevel: config.LOG_INFO,\n    \n        // enable / disable watching file and executing tests whenever any file changes\n        //karma自动自动监视被测试文件和测试用用例文件，如有修改，自动重新执行测试\n        autoWatch: true,\n        // Continuous Integration mode\n        // if true, Karma captures browsers, runs the tests and exits\n        //上一个参数为true，本参数为false，，则自动监视才生效。否则执行完测试用例后自动退出\n        singleRun: true,\n    \n        // start these browsers\n        // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n        //用来执行自动监听的浏览器，推荐chrome\n        browsers: ['Chrome'],\n    \n        // Concurrency level\n        // how many browser should be started simultaneous\n        concurrency: Infinity，\n       //自动将模板文件路径转换页面引入路径，以便注入用例中\n        ngHtml2JsPreprocessor: {\n             cacheIdFromPath: function(filepath) {\n                 var cacheId = filepath.substr(filepath.lastIndexOf('/webapp/')+7);\n                 // console.log(cacheId);\n                 return cacheId;\n               },\n           moduleName: 'template'\n        }\n\t\t})\n\t\t}\n```    \n3. 保存配置文件到测试目录\n\n### 测试用例编写\n#### 1、用例怎么写\n```javascript\ndescribe(\"A suite of Common/common.js\", function() {\n\t\n\tbeforeAll(function(){\n\t\tconsole.log('beforeAll');\n\t});\n   describe(\"extends of String\", function() {\t\n\t   var expected;\n\t\tbeforeEach(function(){\n\t\t\texpected = 'abcd';\n\t\t});\n\t\tit(\"trim\",function(){\n\t\t\texpect(expected).toEqual((\" abcd \").trim());\n\t\t});\n\t\tit(\"ltrim\",function(){\n\t\t\texpect(expected).toEqual((\" abcd\").ltrim());\n\t\t});\n\t\tit(\"rtrim\",function(){\n\t\t\texpect(expected).toEqual((\"abcd \").rtrim());\n\t\t});\n\t});\n});\n```\n上述例子中，\na. describe相当于一个测试套，可以嵌套。\nb. it('tc name',function(){})是一个测试用例。\nc. beforeAll和beforeEach是预置条件，前者一个测试套执行一次，后者每个测试用例执行一次。\nd. 当然还会有afterAll和afterEach\ne. expect是断言\n\n#### 2、 断言都有那些比较\n```javascript\nMatcher实现了断言的比较操作，将Expectation传入的实际值和Matcher传入的期望值比较。任何Matcher都能通过在expect调用Matcher前加上not来实现一个否定的断言（expect(a).not().toBe(false);）。\n常用的Matchers有：\ntoBe()：相当于= =比较。\ntoNotBe():相当于! =比较。\ntoBeDefined()：检查变量或属性是否已声明且赋值。\ntoBeUndefined()\ntoBeNull()：是否是null。\ntoBeTruthy()：如果转换为布尔值，是否为true。\ntoBeFalsy()\ntoBeLessThan()：数值比较，小于。\ntoBeGreaterThan()：数值比较，大于。\ntoEqual()：相当于==，注意与toBe()的区别。一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。\nexpect({}).not().toBe({});\nexpect({}).toEqual({});\ntoNotEqual()\ntoContain()：数组中是否包含元素（值）。只能用于数组，不能用于对象。\ntoBeCloseTo()：数值比较时定义精度，先四舍五入后再比较。\ntoHaveBeenCalled()\ntoHaveBeenCalledWith()\ntoMatch()：按正则表达式匹配。\ntoNotMatch()\ntoThrow()：检验一个函数是否会抛出一个错误\n```\n\n#### 3、 angular代码怎么写\n先看例子\n\n```javascript\ndescribe('Apply MainCtrl', function() {\n  var $scope,\n      $controller,\n      $httpBackend;\n     var MainCtrl;\n\n  beforeEach(module('applyApp'));\n\n  beforeEach(inject(function(_$controller_, $rootScope,  _$httpBackend_) {\n    $scope = $rootScope.$new();\n    $httpBackend = _$httpBackend_;\n    $controller = _$controller_;\n    $httpBackend.when('POST', /\\/api\\/wxcop\\/common\\/record.*/).respond({});      \n  }));\n\n    it('Check $scope assignments.', function() {\n      MainCtrl = $controller('MainController', {\n            $scope: $scope\n        });      \n      $httpBackend.flush();\n      $scope.gotoApplyHome();\n      $scope.judgeLogin();\n      expect($scope.typeSelect).toEqual([\"单行文本\",\"多行文本\",\"单选\",\"多选\"]);\n      expect($scope.getItemItems(\"1,2，3\")).toEqual([\"1\",\"2\",\"3\"]);\n    });\n});\n\n```\n注意，要测试angular必须引入angular-mock。\n说明\n1. beforeEach(module('applyApp'));  引入module 'applyApp'\n2. beforeEach(inject(function(_$controller_, $rootScope,  _$httpBackend_)  依赖注入和http测试打桩\n3.  $controller('MainController',  )初始化controller\n4. 直接调用scope，然后执行断言\n\n#### 5、 angular的相关特性如何测试\n##### 1、测试函数\na.  被测试代码\n```javascript\n$scope.functionTriger = false;\n$scope.doTest = function(){\n\t$scope.functionTriger = true;\n}\n```\nb. 测试用例\n```javascript\nit('function', function() {    \n    expect($scope.functionTriger).toBeFalsy();\n    $scope.doTest();\n    expect($scope.functionTriger).toBeTruthy();\n});\n```\n##### 2、测试监听\na.  被测试代码\n```javascript\n$scope.watchVar = false;\n$scope.watchedTrigeIndex = 0;\n$scope.$watch('watchVar', function() {\n    $scope.watchedTrigeIndex++;\n});\n```\nb. 测试用例\n```javascript\nit('watch', function() {    \n    expect($scope.watchedTrigeIndex).toBe(0);\n    $scope.watchVar = true;\n    $scope.$digest();\n    expect($scope.watchedTrigeIndex).toBe(1);\n    $scope.watchVar = false;\n    $scope.$digest();\n    expect($scope.watchedTrigeIndex).toBe(2);\n});\n```\n\n##### 3、测试广播\na.  被测试代码\n```javascript\n$scope.isHaveTriger = false;\n$scope.$on('ngRepeatFinished', function(){\n    $scope.isHaveTriger = true;\n});\n```\nb. 测试用例\n```javascript\n  it('broadcast', function() {    \n    expect($scope.isHaveTriger).toBeFalsy();\n    $scope.$broadcast('ngRepeatFinished');\n    expect($scope.isHaveTriger).toBeTruthy();\n  });\n```\n##### 4、测试路由切换\na.  被测试代码\n```javascript\n.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider){\n    $urlRouterProvider.otherwise(\"/detail\");\n    $stateProvider.state('detail', {\n        url:'/detail',\n        template:'<p></p>',\n        controller:'MainCtrl'\n    });\n}])\n```\nb. 测试用例\n```javascript\nit('route', function() {  \n    inject(function (_$injector_) {\n      $state = _$injector_.get('$state');\n    });  \n    var curState = $state.get('detail');\n    expect(curState.name).toEqual('detail');\n    expect(curState.url).toEqual('/detail');\n    expect(curState.controller).toEqual('MainCtrl');\n    expect(curState.template).toEqual('<p></p>');\n  });\n```\n\n##### 5、测试过滤器\na.  被测试代码\n```javascript\n.filter('myFilter', function(){\n    return function(data) {    \n        return data + 'lzw';\n    }\n})\n```\nb. 测试用例\n```javascript\n  it('filter', function() {\n    inject(function (_$injector_) {\n      $filter = _$injector_.get('$filter');\n    });\n      \n```\n\n##### 6、测试service\na.  被测试代码\n```javascript\n.service('foo', function() {\n    var thisIsPrivate = \"Private\";\n    function getPrivate() {\n        return thisIsPrivate;\n    }\n    return {\n        variable: \"This is public\",\n        getPrivate: getPrivate\n    };\n})\n```\nb. 测试用例\n```javascript\nit('service',function(){\n    var foo;\n    inject(function(_foo_) {\n        foo = _foo_;\n    });\n    expect(foo.variable).toBe('This is public');\n    expect(foo.getPrivate()).toBe('Private');\n  });\n```\n\n##### 7、测试指令\na.  被测试代码\n```javascript\n.directive('myDirective', function() {\n    return {\n        restrict: 'A',\n        replace: true,\n        template: '<p>11</p>',\n        link: function(scope) {}\n    };\n})\n.directive('dirButton', function() {\n    return {\n        template: '<button>Increment value!</button>',\n        link: function (scope, elem) {\n            elem.find('button').on('click', function(){\n                scope.value++;\n            });\n        }\n    };\n})\n.directive('dirScope', function() {\n    return {\n        scope:{\n            config: '=',\n            notify: '@',\n            onChange:'&'\n        },\n        link: function(scope){\n        }\n    };\n})\n```\nb. 测试用例\n```javascript\nit('directive', function(){    \n    var link = $compile('<p my-directive></p>');\n    var element = link($scope);\n    expect($(element).html()).toBe('11');\n  });\n\n  it('button directive', function () {\n    var directiveElem = $compile('<button dir-button></button>')($scope);\n    $scope.value=10;\n    var button = directiveElem.find('button');\n    button.triggerHandler('click');\n    $scope.$digest();\n    expect($scope.value).toEqual(11);\n  });\n\n  it('scope directive',function(){\n    $scope.config = {\n      prop: 'value'\n    };\n    $scope.notify = true;\n    $scope.onChange = jasmine.createSpy('onChange');\n    var directiveElem = $compile(angular.element('<p dir-scope config=\"config\" notify=\"notify\" on-change=\"onChange()\"></p>'))($scope);\n    $scope.$digest();\n    var isolatedScope = directiveElem.isolateScope();\n\n    //test =    \n    isolatedScope.config.prop = \"value2\";\n    expect($scope.config.prop).toEqual('value2');\n\n    //test @\n    isolatedScope.notify = false;\n    expect($scope.notify).toEqual(true);\n\n    //test &\n    expect(typeof(isolatedScope.onChange)).toEqual('function');\n    isolatedScope.onChange();\n    expect($scope.onChange).toHaveBeenCalled();\n\t\n   //调用指令的父controller。\n   directiveElem.scope().doFunction();\n  });\n  \n```\n### 关于mock\n#### $httpBackend\n$httpBackend对于代码中的http请求进行mock。常用方法：\n```javascript\n$httpBackend.when(method, url, [data], [headers]);\n$httpBackend.expect(method, url, [data], [headers]);\n```\nwhen和expect都有对应的快捷方法:\n```javascript\nwhenGET(url, [headers]);\nwhenHEAD(url, [headers]);\nwhenDELETE(url, [headers]);\nwhenPOST(url, [data], [headers]);\nwhenPUT(url, [data], [headers]);\nwhenJSONP(url);\nexpectGET(url, [headers]);\nexpectHEAD(url, [headers]);\nexpectDELETE(url, [headers]);\nexpectPOST(url, [data], [headers]);\nexpectPUT(url, [data], [headers]);\nexpectPATCH(url, [data], [headers]);\nexpectJSONP(url);\n```\nurl支持正则，比如：\n```javascript\n$httpBackend.when('POST', /\\/api\\/wxcop\\/common\\/record.*/).respond({});\n```\n注意：\n$httpBackend.when与$httpBackend.expect的区别在于：$httpBackend.expect的伪后台只能被调用一次(调用一次后会被清除)，第二次调用就会报错，而且$httpBackend.resetExpectations可以移除所有的expect而对when没有影响。\n\n### 常见异常处理\n##### Argument 'MainCtrl' is not a function, got undefined\n无法找到MainCtrl。可能原因：controller定义错误，app注入失败。\n##### Disconnected, because no message in 10000 ms.\najax请求超时。原因：$httpBackend.flush();要放在ajax发起请求后执行。\n##### 指令采用templateUrl方式加载模板失败\n可采用karma-ng-html2js-preprocessor插件自动注入。也可以采用$templateCache注入。注意，这两种方式都不支持模糊匹配\n\n\n### 参考资料\n[《AngularJS Testing Tips: Testing Directives》](https://www.sitepoint.com/angular-testing-tips-testing-directives/ \"《AngularJS Testing Tips: Testing Directives》\")\n[《Unit Testing in AngularJS: Services, Controllers & Providers》](https://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/)\n[《Unit Testing Services in AngularJS for Fun and for Profit》](https://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit/)","source":"_posts/FE/test/基于karma-jasmine的web前端自动化测试.md","raw":"---\ntitle: 基于karma+jasmine的web前端自动化测试\ndate: 2018-01-10 21:24:35\ntags: [JS,自动化,测试,工具]\n---\n本文介绍了基于karma+jasmine的web前端自动化测试的方案和详细操作指导。\n### 名词解释\n1. Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。\n2. Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。\n3. Jasmine 是一个简易的JS单元测试框架。Jasmine 不依赖于任何浏览器、DOM、或者是任何 JavaScript 而存在。它适用于所有网站、Node.js 项目，或者是任何能够在 JavaScript 上面运行的程序。\n\n### 环境安装\n1. 首先必须安装执行环境nodejs\n2. 安装浏览器，推荐chrome（用于运行监听程序，监听js文件变化，自动触发测试执行）\n3. 安装karma+jasmine\n\t\tnpm install karma -g\n\t\tnpm install karma-jasmine -g\n\t\tnpm install karma-chrome-launcher -g \n\t\tnpm install karma-cli -g \n\t\tnpm install karma-coverage -g \n\t\tnpm install karma-html-reporter -g \n4. 安装完成后执行karma -v，检查安装是否正常\n\n### 工程配置\n1. 可以使用karma init，自动生成配置文件，完成部分参数的设置，然后再手动修改。\n2. 当然最快的配置方法，复制下面的配置\n```javascript\n\t\t// Karma configuration\n\t\t// Generated on Tue Nov 01 2016 14:17:00 GMT+0800 (中国标准时间)\n\n\t\tmodule.exports = function(config) {\n\t\t  config.set({\n\t\t  // base path that will be used to resolve all patterns (eg. files, exclude)\n\t\t\tbasePath: '',\n\n        // frameworks to use\n        // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n        frameworks: ['jasmine'],\n    \n        // list of files / patterns to load in the browser\n        //需要加载入浏览器的js文件，包括基础的类库，被测试js文件和测试用例js文件\n        //如果需要测试angular代码，比如引入angular-mock.js，给angular代码进行mock。\n        //注意angular-mock的版本一定要和angular版本一致。可在cdn网站对应的angular版本列表中寻找\n        files: [\n            '../webapp/vender/jquery/jquery-1.10.2.min.js',\n            '../webapp/vender/angular/angular.min.js',\n            '../webapp/vender/angular/angular-ui-router.min.js',\n            'lib/angular-mocks.js',\n            '../webapp/common/*.js',\n            '../webapp/commont/template/*.html',\n            'tc/ut/**/*.js'\n        ],\n    \n        // list of files to exclude\n        exclude: [\n          //'../webapp/vender/**/*.js'\n        ],\n    \n        // test results reporter to use\n        // possible values: 'dots', 'progress'\n        // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n        //这里定义输出的报告\n        //html对应karma-html-reporter组件，输出测试用例执行报告\n        //coverage对应karma-coverage组件，输出测试用例执行报告\n        reporters: ['progress', 'html', 'junit', 'coverage'],\n        junitReporter: {  \n               // will be resolved to basePath (in the same way as files/exclude patterns)  \n              outputFile: 'report/ut/test-results.xml',\n              suite: 'UT',\n              useBrowserName: false \n        },  \n        htmlReporter: {\n          outputDir: 'report/ut',\n          reportName: 'result' //outputDir+reportName组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告\n        },\n        //定义需要统计覆盖率的文件\n        preprocessors: {\n            '../webapp/common/*.js':'coverage', \n            '../webapp/common/template/*.html': 'ng-html2js'\n        },\n        coverageReporter: {  \n            type: 'html', //将覆盖率报告类型type设置为cobertura 或者 html\n            subdir:'coverage', //dir+subdir组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告\n            dir: 'report/ut/'  //代码覆盖率报告生成地址\n        },\n    \n        // web server port\n        port: 9876,\n    \n        // enable / disable colors in the output (reporters and logs)\n        colors: true,\n    \n        // level of logging\n        // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n        logLevel: config.LOG_INFO,\n    \n        // enable / disable watching file and executing tests whenever any file changes\n        //karma自动自动监视被测试文件和测试用用例文件，如有修改，自动重新执行测试\n        autoWatch: true,\n        // Continuous Integration mode\n        // if true, Karma captures browsers, runs the tests and exits\n        //上一个参数为true，本参数为false，，则自动监视才生效。否则执行完测试用例后自动退出\n        singleRun: true,\n    \n        // start these browsers\n        // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n        //用来执行自动监听的浏览器，推荐chrome\n        browsers: ['Chrome'],\n    \n        // Concurrency level\n        // how many browser should be started simultaneous\n        concurrency: Infinity，\n       //自动将模板文件路径转换页面引入路径，以便注入用例中\n        ngHtml2JsPreprocessor: {\n             cacheIdFromPath: function(filepath) {\n                 var cacheId = filepath.substr(filepath.lastIndexOf('/webapp/')+7);\n                 // console.log(cacheId);\n                 return cacheId;\n               },\n           moduleName: 'template'\n        }\n\t\t})\n\t\t}\n```    \n3. 保存配置文件到测试目录\n\n### 测试用例编写\n#### 1、用例怎么写\n```javascript\ndescribe(\"A suite of Common/common.js\", function() {\n\t\n\tbeforeAll(function(){\n\t\tconsole.log('beforeAll');\n\t});\n   describe(\"extends of String\", function() {\t\n\t   var expected;\n\t\tbeforeEach(function(){\n\t\t\texpected = 'abcd';\n\t\t});\n\t\tit(\"trim\",function(){\n\t\t\texpect(expected).toEqual((\" abcd \").trim());\n\t\t});\n\t\tit(\"ltrim\",function(){\n\t\t\texpect(expected).toEqual((\" abcd\").ltrim());\n\t\t});\n\t\tit(\"rtrim\",function(){\n\t\t\texpect(expected).toEqual((\"abcd \").rtrim());\n\t\t});\n\t});\n});\n```\n上述例子中，\na. describe相当于一个测试套，可以嵌套。\nb. it('tc name',function(){})是一个测试用例。\nc. beforeAll和beforeEach是预置条件，前者一个测试套执行一次，后者每个测试用例执行一次。\nd. 当然还会有afterAll和afterEach\ne. expect是断言\n\n#### 2、 断言都有那些比较\n```javascript\nMatcher实现了断言的比较操作，将Expectation传入的实际值和Matcher传入的期望值比较。任何Matcher都能通过在expect调用Matcher前加上not来实现一个否定的断言（expect(a).not().toBe(false);）。\n常用的Matchers有：\ntoBe()：相当于= =比较。\ntoNotBe():相当于! =比较。\ntoBeDefined()：检查变量或属性是否已声明且赋值。\ntoBeUndefined()\ntoBeNull()：是否是null。\ntoBeTruthy()：如果转换为布尔值，是否为true。\ntoBeFalsy()\ntoBeLessThan()：数值比较，小于。\ntoBeGreaterThan()：数值比较，大于。\ntoEqual()：相当于==，注意与toBe()的区别。一个新建的Object不是（not to be）另一个新建的Object，但是它们是相等（to equal）的。\nexpect({}).not().toBe({});\nexpect({}).toEqual({});\ntoNotEqual()\ntoContain()：数组中是否包含元素（值）。只能用于数组，不能用于对象。\ntoBeCloseTo()：数值比较时定义精度，先四舍五入后再比较。\ntoHaveBeenCalled()\ntoHaveBeenCalledWith()\ntoMatch()：按正则表达式匹配。\ntoNotMatch()\ntoThrow()：检验一个函数是否会抛出一个错误\n```\n\n#### 3、 angular代码怎么写\n先看例子\n\n```javascript\ndescribe('Apply MainCtrl', function() {\n  var $scope,\n      $controller,\n      $httpBackend;\n     var MainCtrl;\n\n  beforeEach(module('applyApp'));\n\n  beforeEach(inject(function(_$controller_, $rootScope,  _$httpBackend_) {\n    $scope = $rootScope.$new();\n    $httpBackend = _$httpBackend_;\n    $controller = _$controller_;\n    $httpBackend.when('POST', /\\/api\\/wxcop\\/common\\/record.*/).respond({});      \n  }));\n\n    it('Check $scope assignments.', function() {\n      MainCtrl = $controller('MainController', {\n            $scope: $scope\n        });      \n      $httpBackend.flush();\n      $scope.gotoApplyHome();\n      $scope.judgeLogin();\n      expect($scope.typeSelect).toEqual([\"单行文本\",\"多行文本\",\"单选\",\"多选\"]);\n      expect($scope.getItemItems(\"1,2，3\")).toEqual([\"1\",\"2\",\"3\"]);\n    });\n});\n\n```\n注意，要测试angular必须引入angular-mock。\n说明\n1. beforeEach(module('applyApp'));  引入module 'applyApp'\n2. beforeEach(inject(function(_$controller_, $rootScope,  _$httpBackend_)  依赖注入和http测试打桩\n3.  $controller('MainController',  )初始化controller\n4. 直接调用scope，然后执行断言\n\n#### 5、 angular的相关特性如何测试\n##### 1、测试函数\na.  被测试代码\n```javascript\n$scope.functionTriger = false;\n$scope.doTest = function(){\n\t$scope.functionTriger = true;\n}\n```\nb. 测试用例\n```javascript\nit('function', function() {    \n    expect($scope.functionTriger).toBeFalsy();\n    $scope.doTest();\n    expect($scope.functionTriger).toBeTruthy();\n});\n```\n##### 2、测试监听\na.  被测试代码\n```javascript\n$scope.watchVar = false;\n$scope.watchedTrigeIndex = 0;\n$scope.$watch('watchVar', function() {\n    $scope.watchedTrigeIndex++;\n});\n```\nb. 测试用例\n```javascript\nit('watch', function() {    \n    expect($scope.watchedTrigeIndex).toBe(0);\n    $scope.watchVar = true;\n    $scope.$digest();\n    expect($scope.watchedTrigeIndex).toBe(1);\n    $scope.watchVar = false;\n    $scope.$digest();\n    expect($scope.watchedTrigeIndex).toBe(2);\n});\n```\n\n##### 3、测试广播\na.  被测试代码\n```javascript\n$scope.isHaveTriger = false;\n$scope.$on('ngRepeatFinished', function(){\n    $scope.isHaveTriger = true;\n});\n```\nb. 测试用例\n```javascript\n  it('broadcast', function() {    \n    expect($scope.isHaveTriger).toBeFalsy();\n    $scope.$broadcast('ngRepeatFinished');\n    expect($scope.isHaveTriger).toBeTruthy();\n  });\n```\n##### 4、测试路由切换\na.  被测试代码\n```javascript\n.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider){\n    $urlRouterProvider.otherwise(\"/detail\");\n    $stateProvider.state('detail', {\n        url:'/detail',\n        template:'<p></p>',\n        controller:'MainCtrl'\n    });\n}])\n```\nb. 测试用例\n```javascript\nit('route', function() {  \n    inject(function (_$injector_) {\n      $state = _$injector_.get('$state');\n    });  \n    var curState = $state.get('detail');\n    expect(curState.name).toEqual('detail');\n    expect(curState.url).toEqual('/detail');\n    expect(curState.controller).toEqual('MainCtrl');\n    expect(curState.template).toEqual('<p></p>');\n  });\n```\n\n##### 5、测试过滤器\na.  被测试代码\n```javascript\n.filter('myFilter', function(){\n    return function(data) {    \n        return data + 'lzw';\n    }\n})\n```\nb. 测试用例\n```javascript\n  it('filter', function() {\n    inject(function (_$injector_) {\n      $filter = _$injector_.get('$filter');\n    });\n      \n```\n\n##### 6、测试service\na.  被测试代码\n```javascript\n.service('foo', function() {\n    var thisIsPrivate = \"Private\";\n    function getPrivate() {\n        return thisIsPrivate;\n    }\n    return {\n        variable: \"This is public\",\n        getPrivate: getPrivate\n    };\n})\n```\nb. 测试用例\n```javascript\nit('service',function(){\n    var foo;\n    inject(function(_foo_) {\n        foo = _foo_;\n    });\n    expect(foo.variable).toBe('This is public');\n    expect(foo.getPrivate()).toBe('Private');\n  });\n```\n\n##### 7、测试指令\na.  被测试代码\n```javascript\n.directive('myDirective', function() {\n    return {\n        restrict: 'A',\n        replace: true,\n        template: '<p>11</p>',\n        link: function(scope) {}\n    };\n})\n.directive('dirButton', function() {\n    return {\n        template: '<button>Increment value!</button>',\n        link: function (scope, elem) {\n            elem.find('button').on('click', function(){\n                scope.value++;\n            });\n        }\n    };\n})\n.directive('dirScope', function() {\n    return {\n        scope:{\n            config: '=',\n            notify: '@',\n            onChange:'&'\n        },\n        link: function(scope){\n        }\n    };\n})\n```\nb. 测试用例\n```javascript\nit('directive', function(){    \n    var link = $compile('<p my-directive></p>');\n    var element = link($scope);\n    expect($(element).html()).toBe('11');\n  });\n\n  it('button directive', function () {\n    var directiveElem = $compile('<button dir-button></button>')($scope);\n    $scope.value=10;\n    var button = directiveElem.find('button');\n    button.triggerHandler('click');\n    $scope.$digest();\n    expect($scope.value).toEqual(11);\n  });\n\n  it('scope directive',function(){\n    $scope.config = {\n      prop: 'value'\n    };\n    $scope.notify = true;\n    $scope.onChange = jasmine.createSpy('onChange');\n    var directiveElem = $compile(angular.element('<p dir-scope config=\"config\" notify=\"notify\" on-change=\"onChange()\"></p>'))($scope);\n    $scope.$digest();\n    var isolatedScope = directiveElem.isolateScope();\n\n    //test =    \n    isolatedScope.config.prop = \"value2\";\n    expect($scope.config.prop).toEqual('value2');\n\n    //test @\n    isolatedScope.notify = false;\n    expect($scope.notify).toEqual(true);\n\n    //test &\n    expect(typeof(isolatedScope.onChange)).toEqual('function');\n    isolatedScope.onChange();\n    expect($scope.onChange).toHaveBeenCalled();\n\t\n   //调用指令的父controller。\n   directiveElem.scope().doFunction();\n  });\n  \n```\n### 关于mock\n#### $httpBackend\n$httpBackend对于代码中的http请求进行mock。常用方法：\n```javascript\n$httpBackend.when(method, url, [data], [headers]);\n$httpBackend.expect(method, url, [data], [headers]);\n```\nwhen和expect都有对应的快捷方法:\n```javascript\nwhenGET(url, [headers]);\nwhenHEAD(url, [headers]);\nwhenDELETE(url, [headers]);\nwhenPOST(url, [data], [headers]);\nwhenPUT(url, [data], [headers]);\nwhenJSONP(url);\nexpectGET(url, [headers]);\nexpectHEAD(url, [headers]);\nexpectDELETE(url, [headers]);\nexpectPOST(url, [data], [headers]);\nexpectPUT(url, [data], [headers]);\nexpectPATCH(url, [data], [headers]);\nexpectJSONP(url);\n```\nurl支持正则，比如：\n```javascript\n$httpBackend.when('POST', /\\/api\\/wxcop\\/common\\/record.*/).respond({});\n```\n注意：\n$httpBackend.when与$httpBackend.expect的区别在于：$httpBackend.expect的伪后台只能被调用一次(调用一次后会被清除)，第二次调用就会报错，而且$httpBackend.resetExpectations可以移除所有的expect而对when没有影响。\n\n### 常见异常处理\n##### Argument 'MainCtrl' is not a function, got undefined\n无法找到MainCtrl。可能原因：controller定义错误，app注入失败。\n##### Disconnected, because no message in 10000 ms.\najax请求超时。原因：$httpBackend.flush();要放在ajax发起请求后执行。\n##### 指令采用templateUrl方式加载模板失败\n可采用karma-ng-html2js-preprocessor插件自动注入。也可以采用$templateCache注入。注意，这两种方式都不支持模糊匹配\n\n\n### 参考资料\n[《AngularJS Testing Tips: Testing Directives》](https://www.sitepoint.com/angular-testing-tips-testing-directives/ \"《AngularJS Testing Tips: Testing Directives》\")\n[《Unit Testing in AngularJS: Services, Controllers & Providers》](https://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/)\n[《Unit Testing Services in AngularJS for Fun and for Profit》](https://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit/)","slug":"FE/test/基于karma-jasmine的web前端自动化测试","published":1,"updated":"2018-01-10T13:30:25.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjc95ci4e000r80cm915rhvhc","content":"<p>本文介绍了基于karma+jasmine的web前端自动化测试的方案和详细操作指导。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><ol>\n<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li>\n<li>Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。</li>\n<li>Jasmine 是一个简易的JS单元测试框架。Jasmine 不依赖于任何浏览器、DOM、或者是任何 JavaScript 而存在。它适用于所有网站、Node.js 项目，或者是任何能够在 JavaScript 上面运行的程序。</li>\n</ol>\n<h3 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h3><ol>\n<li>首先必须安装执行环境nodejs</li>\n<li>安装浏览器，推荐chrome（用于运行监听程序，监听js文件变化，自动触发测试执行）</li>\n<li>安装karma+jasmine<pre><code>npm install karma -g\nnpm install karma-jasmine -g\nnpm install karma-chrome-launcher -g \nnpm install karma-cli -g \nnpm install karma-coverage -g \nnpm install karma-html-reporter -g \n</code></pre></li>\n<li>安装完成后执行karma -v，检查安装是否正常</li>\n</ol>\n<h3 id=\"工程配置\"><a href=\"#工程配置\" class=\"headerlink\" title=\"工程配置\"></a>工程配置</h3><ol>\n<li>可以使用karma init，自动生成配置文件，完成部分参数的设置，然后再手动修改。</li>\n<li>当然最快的配置方法，复制下面的配置<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"comment\">// Karma configuration</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Generated on Tue Nov 01 2016 14:17:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">\t\t  config.set(&#123;</span><br><span class=\"line\">\t\t  <span class=\"comment\">// base path that will be used to resolve all patterns (eg. files, exclude)</span></span><br><span class=\"line\">\t\t\tbasePath: <span class=\"string\">''</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// frameworks to use</span></span><br><span class=\"line\">        <span class=\"comment\">// available frameworks: https://npmjs.org/browse/keyword/karma-adapter</span></span><br><span class=\"line\">        frameworks: [<span class=\"string\">'jasmine'</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// list of files / patterns to load in the browser</span></span><br><span class=\"line\">        <span class=\"comment\">//需要加载入浏览器的js文件，包括基础的类库，被测试js文件和测试用例js文件</span></span><br><span class=\"line\">        <span class=\"comment\">//如果需要测试angular代码，比如引入angular-mock.js，给angular代码进行mock。</span></span><br><span class=\"line\">        <span class=\"comment\">//注意angular-mock的版本一定要和angular版本一致。可在cdn网站对应的angular版本列表中寻找</span></span><br><span class=\"line\">        files: [</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/jquery/jquery-1.10.2.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/angular/angular.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/angular/angular-ui-router.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'lib/angular-mocks.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/*.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/commont/template/*.html'</span>,</span><br><span class=\"line\">            <span class=\"string\">'tc/ut/**/*.js'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// list of files to exclude</span></span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          <span class=\"comment\">//'../webapp/vender/**/*.js'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// test results reporter to use</span></span><br><span class=\"line\">        <span class=\"comment\">// possible values: 'dots', 'progress'</span></span><br><span class=\"line\">        <span class=\"comment\">// available reporters: https://npmjs.org/browse/keyword/karma-reporter</span></span><br><span class=\"line\">        <span class=\"comment\">//这里定义输出的报告</span></span><br><span class=\"line\">        <span class=\"comment\">//html对应karma-html-reporter组件，输出测试用例执行报告</span></span><br><span class=\"line\">        <span class=\"comment\">//coverage对应karma-coverage组件，输出测试用例执行报告</span></span><br><span class=\"line\">        reporters: [<span class=\"string\">'progress'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'junit'</span>, <span class=\"string\">'coverage'</span>],</span><br><span class=\"line\">        junitReporter: &#123;  </span><br><span class=\"line\">               <span class=\"comment\">// will be resolved to basePath (in the same way as files/exclude patterns)  </span></span><br><span class=\"line\">              outputFile: <span class=\"string\">'report/ut/test-results.xml'</span>,</span><br><span class=\"line\">              suite: <span class=\"string\">'UT'</span>,</span><br><span class=\"line\">              useBrowserName: <span class=\"literal\">false</span> </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        htmlReporter: &#123;</span><br><span class=\"line\">          outputDir: <span class=\"string\">'report/ut'</span>,</span><br><span class=\"line\">          reportName: <span class=\"string\">'result'</span> <span class=\"comment\">//outputDir+reportName组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//定义需要统计覆盖率的文件</span></span><br><span class=\"line\">        preprocessors: &#123;</span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/*.js'</span>:<span class=\"string\">'coverage'</span>, </span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/template/*.html'</span>: <span class=\"string\">'ng-html2js'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        coverageReporter: &#123;  </span><br><span class=\"line\">            type: <span class=\"string\">'html'</span>, <span class=\"comment\">//将覆盖率报告类型type设置为cobertura 或者 html</span></span><br><span class=\"line\">            subdir:<span class=\"string\">'coverage'</span>, <span class=\"comment\">//dir+subdir组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告</span></span><br><span class=\"line\">            dir: <span class=\"string\">'report/ut/'</span>  <span class=\"comment\">//代码覆盖率报告生成地址</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// web server port</span></span><br><span class=\"line\">        port: <span class=\"number\">9876</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// enable / disable colors in the output (reporters and logs)</span></span><br><span class=\"line\">        colors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// level of logging</span></span><br><span class=\"line\">        <span class=\"comment\">// possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG</span></span><br><span class=\"line\">        logLevel: config.LOG_INFO,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// enable / disable watching file and executing tests whenever any file changes</span></span><br><span class=\"line\">        <span class=\"comment\">//karma自动自动监视被测试文件和测试用用例文件，如有修改，自动重新执行测试</span></span><br><span class=\"line\">        autoWatch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// Continuous Integration mode</span></span><br><span class=\"line\">        <span class=\"comment\">// if true, Karma captures browsers, runs the tests and exits</span></span><br><span class=\"line\">        <span class=\"comment\">//上一个参数为true，本参数为false，，则自动监视才生效。否则执行完测试用例后自动退出</span></span><br><span class=\"line\">        singleRun: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// start these browsers</span></span><br><span class=\"line\">        <span class=\"comment\">// available browser launchers: https://npmjs.org/browse/keyword/karma-launcher</span></span><br><span class=\"line\">        <span class=\"comment\">//用来执行自动监听的浏览器，推荐chrome</span></span><br><span class=\"line\">        browsers: [<span class=\"string\">'Chrome'</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// Concurrency level</span></span><br><span class=\"line\">        <span class=\"comment\">// how many browser should be started simultaneous</span></span><br><span class=\"line\">        concurrency: <span class=\"literal\">Infinity</span>，</span><br><span class=\"line\">       <span class=\"comment\">//自动将模板文件路径转换页面引入路径，以便注入用例中</span></span><br><span class=\"line\">        ngHtml2JsPreprocessor: &#123;</span><br><span class=\"line\">             cacheIdFromPath: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filepath</span>) </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> cacheId = filepath.substr(filepath.lastIndexOf(<span class=\"string\">'/webapp/'</span>)+<span class=\"number\">7</span>);</span><br><span class=\"line\">                 <span class=\"comment\">// console.log(cacheId);</span></span><br><span class=\"line\">                 <span class=\"keyword\">return</span> cacheId;</span><br><span class=\"line\">               &#125;,</span><br><span class=\"line\">           moduleName: <span class=\"string\">'template'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">3. 保存配置文件到测试目录</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 测试用例编写</span></span><br><span class=\"line\"><span class=\"string\">#### 1、用例怎么写</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">describe(<span class=\"string\">\"A suite of Common/common.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tbeforeAll(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeAll'</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">   describe(<span class=\"string\">\"extends of String\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;\t</span><br><span class=\"line\">\t   <span class=\"keyword\">var</span> expected;</span><br><span class=\"line\">\t\tbeforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpected = <span class=\"string\">'abcd'</span>;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"trim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\" abcd \"</span>).trim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"ltrim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\" abcd\"</span>).ltrim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"rtrim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\"abcd \"</span>).rtrim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上述例子中，<br>a. describe相当于一个测试套，可以嵌套。<br>b. it(‘tc name’,function(){})是一个测试用例。<br>c. beforeAll和beforeEach是预置条件，前者一个测试套执行一次，后者每个测试用例执行一次。<br>d. 当然还会有afterAll和afterEach<br>e. expect是断言</p>\n<h4 id=\"2、-断言都有那些比较\"><a href=\"#2、-断言都有那些比较\" class=\"headerlink\" title=\"2、 断言都有那些比较\"></a>2、 断言都有那些比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matcher实现了断言的比较操作，将Expectation传入的实际值和Matcher传入的期望值比较。任何Matcher都能通过在expect调用Matcher前加上not来实现一个否定的断言（expect(a).not().toBe(<span class=\"literal\">false</span>);）。</span><br><span class=\"line\">常用的Matchers有：</span><br><span class=\"line\">toBe()：相当于= =比较。</span><br><span class=\"line\">toNotBe():相当于! =比较。</span><br><span class=\"line\">toBeDefined()：检查变量或属性是否已声明且赋值。</span><br><span class=\"line\">toBeUndefined()</span><br><span class=\"line\">toBeNull()：是否是<span class=\"literal\">null</span>。</span><br><span class=\"line\">toBeTruthy()：如果转换为布尔值，是否为<span class=\"literal\">true</span>。</span><br><span class=\"line\">toBeFalsy()</span><br><span class=\"line\">toBeLessThan()：数值比较，小于。</span><br><span class=\"line\">toBeGreaterThan()：数值比较，大于。</span><br><span class=\"line\">toEqual()：相当于==，注意与toBe()的区别。一个新建的<span class=\"built_in\">Object</span>不是（not to be）另一个新建的<span class=\"built_in\">Object</span>，但是它们是相等（to equal）的。</span><br><span class=\"line\">expect(&#123;&#125;).not().toBe(&#123;&#125;);</span><br><span class=\"line\">expect(&#123;&#125;).toEqual(&#123;&#125;);</span><br><span class=\"line\">toNotEqual()</span><br><span class=\"line\">toContain()：数组中是否包含元素（值）。只能用于数组，不能用于对象。</span><br><span class=\"line\">toBeCloseTo()：数值比较时定义精度，先四舍五入后再比较。</span><br><span class=\"line\">toHaveBeenCalled()</span><br><span class=\"line\">toHaveBeenCalledWith()</span><br><span class=\"line\">toMatch()：按正则表达式匹配。</span><br><span class=\"line\">toNotMatch()</span><br><span class=\"line\">toThrow()：检验一个函数是否会抛出一个错误</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、-angular代码怎么写\"><a href=\"#3、-angular代码怎么写\" class=\"headerlink\" title=\"3、 angular代码怎么写\"></a>3、 angular代码怎么写</h4><p>先看例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Apply MainCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $scope,</span><br><span class=\"line\">      $controller,</span><br><span class=\"line\">      $httpBackend;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> MainCtrl;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(<span class=\"built_in\">module</span>(<span class=\"string\">'applyApp'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(inject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_$controller_, $rootScope,  _$httpBackend_</span>) </span>&#123;</span><br><span class=\"line\">    $scope = $rootScope.$<span class=\"keyword\">new</span>();</span><br><span class=\"line\">    $httpBackend = _$httpBackend_;</span><br><span class=\"line\">    $controller = _$controller_;</span><br><span class=\"line\">    $httpBackend.when(<span class=\"string\">'POST'</span>, /\\/api\\/wxcop\\/common\\/record.*<span class=\"regexp\">/).respond(&#123;&#125;);      </span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;));</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    it('Check $scope assignments.', function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      MainCtrl = $controller('MainController', &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            $scope: $scope</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;);      </span></span><br><span class=\"line\"><span class=\"regexp\">      $httpBackend.flush();</span></span><br><span class=\"line\"><span class=\"regexp\">      $scope.gotoApplyHome();</span></span><br><span class=\"line\"><span class=\"regexp\">      $scope.judgeLogin();</span></span><br><span class=\"line\"><span class=\"regexp\">      expect($scope.typeSelect).toEqual([\"单行文本\",\"多行文本\",\"单选\",\"多选\"]);</span></span><br><span class=\"line\"><span class=\"regexp\">      expect($scope.getItemItems(\"1,2，3\")).toEqual([\"1\",\"2\",\"3\"]);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<p>注意，要测试angular必须引入angular-mock。<br>说明</p>\n<ol>\n<li>beforeEach(module(‘applyApp’));  引入module ‘applyApp’</li>\n<li>beforeEach(inject(function(<em>$controller</em>, $rootScope,  <em>$httpBackend</em>)  依赖注入和http测试打桩</li>\n<li>$controller(‘MainController’,  )初始化controller</li>\n<li>直接调用scope，然后执行断言</li>\n</ol>\n<h4 id=\"5、-angular的相关特性如何测试\"><a href=\"#5、-angular的相关特性如何测试\" class=\"headerlink\" title=\"5、 angular的相关特性如何测试\"></a>5、 angular的相关特性如何测试</h4><h5 id=\"1、测试函数\"><a href=\"#1、测试函数\" class=\"headerlink\" title=\"1、测试函数\"></a>1、测试函数</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.functionTriger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.doTest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t$scope.functionTriger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'function'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">    expect($scope.functionTriger).toBeFalsy();</span><br><span class=\"line\">    $scope.doTest();</span><br><span class=\"line\">    expect($scope.functionTriger).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2、测试监听\"><a href=\"#2、测试监听\" class=\"headerlink\" title=\"2、测试监听\"></a>2、测试监听</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.watchVar = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.watchedTrigeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">$scope.$watch(<span class=\"string\">'watchVar'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $scope.watchedTrigeIndex++;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'watch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">    $scope.watchVar = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">    $scope.watchVar = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3、测试广播\"><a href=\"#3、测试广播\" class=\"headerlink\" title=\"3、测试广播\"></a>3、测试广播</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.isHaveTriger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.$on(<span class=\"string\">'ngRepeatFinished'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $scope.isHaveTriger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'broadcast'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">  expect($scope.isHaveTriger).toBeFalsy();</span><br><span class=\"line\">  $scope.$broadcast(<span class=\"string\">'ngRepeatFinished'</span>);</span><br><span class=\"line\">  expect($scope.isHaveTriger).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4、测试路由切换\"><a href=\"#4、测试路由切换\" class=\"headerlink\" title=\"4、测试路由切换\"></a>4、测试路由切换</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.config([<span class=\"string\">'$stateProvider'</span>, <span class=\"string\">'$urlRouterProvider'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$stateProvider, $urlRouterProvider</span>)</span>&#123;</span><br><span class=\"line\">    $urlRouterProvider.otherwise(<span class=\"string\">\"/detail\"</span>);</span><br><span class=\"line\">    $stateProvider.state(<span class=\"string\">'detail'</span>, &#123;</span><br><span class=\"line\">        url:<span class=\"string\">'/detail'</span>,</span><br><span class=\"line\">        template:<span class=\"string\">'&lt;p&gt;&lt;/p&gt;'</span>,</span><br><span class=\"line\">        controller:<span class=\"string\">'MainCtrl'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;])</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'route'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    inject(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_$injector_</span>) </span>&#123;</span><br><span class=\"line\">      $state = _$injector_.get(<span class=\"string\">'$state'</span>);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> curState = $state.get(<span class=\"string\">'detail'</span>);</span><br><span class=\"line\">    expect(curState.name).toEqual(<span class=\"string\">'detail'</span>);</span><br><span class=\"line\">    expect(curState.url).toEqual(<span class=\"string\">'/detail'</span>);</span><br><span class=\"line\">    expect(curState.controller).toEqual(<span class=\"string\">'MainCtrl'</span>);</span><br><span class=\"line\">    expect(curState.template).toEqual(<span class=\"string\">'&lt;p&gt;&lt;/p&gt;'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5、测试过滤器\"><a href=\"#5、测试过滤器\" class=\"headerlink\" title=\"5、测试过滤器\"></a>5、测试过滤器</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.filter(<span class=\"string\">'myFilter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> data + <span class=\"string\">'lzw'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  inject(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_$injector_</span>) </span>&#123;</span><br><span class=\"line\">    $filter = _$injector_.get(<span class=\"string\">'$filter'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"6、测试service\"><a href=\"#6、测试service\" class=\"headerlink\" title=\"6、测试service\"></a>6、测试service</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.service(<span class=\"string\">'foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisIsPrivate = <span class=\"string\">\"Private\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> thisIsPrivate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        variable: <span class=\"string\">\"This is public\"</span>,</span><br><span class=\"line\">        getPrivate: getPrivate</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'service'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\">    inject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_foo_</span>) </span>&#123;</span><br><span class=\"line\">        foo = _foo_;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(foo.variable).toBe(<span class=\"string\">'This is public'</span>);</span><br><span class=\"line\">    expect(foo.getPrivate()).toBe(<span class=\"string\">'Private'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7、测试指令\"><a href=\"#7、测试指令\" class=\"headerlink\" title=\"7、测试指令\"></a>7、测试指令</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(<span class=\"string\">'myDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">        replace: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        template: <span class=\"string\">'&lt;p&gt;11&lt;/p&gt;'</span>,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.directive(<span class=\"string\">'dirButton'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        template: <span class=\"string\">'&lt;button&gt;Increment value!&lt;/button&gt;'</span>,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope, elem</span>) </span>&#123;</span><br><span class=\"line\">            elem.find(<span class=\"string\">'button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                scope.value++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.directive(<span class=\"string\">'dirScope'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        scope:&#123;</span><br><span class=\"line\">            config: <span class=\"string\">'='</span>,</span><br><span class=\"line\">            notify: <span class=\"string\">'@'</span>,</span><br><span class=\"line\">            onChange:<span class=\"string\">'&amp;'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>)</span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> link = $compile(<span class=\"string\">'&lt;p my-directive&gt;&lt;/p&gt;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> element = link($scope);</span><br><span class=\"line\">    expect($(element).html()).toBe(<span class=\"string\">'11'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'button directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> directiveElem = $compile(<span class=\"string\">'&lt;button dir-button&gt;&lt;/button&gt;'</span>)($scope);</span><br><span class=\"line\">    $scope.value=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = directiveElem.find(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">    button.triggerHandler(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.value).toEqual(<span class=\"number\">11</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'scope directive'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $scope.config = &#123;</span><br><span class=\"line\">      prop: <span class=\"string\">'value'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $scope.notify = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $scope.onChange = jasmine.createSpy(<span class=\"string\">'onChange'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> directiveElem = $compile(angular.element(<span class=\"string\">'&lt;p dir-scope config=\"config\" notify=\"notify\" on-change=\"onChange()\"&gt;&lt;/p&gt;'</span>))($scope);</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isolatedScope = directiveElem.isolateScope();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test =    </span></span><br><span class=\"line\">    isolatedScope.config.prop = <span class=\"string\">\"value2\"</span>;</span><br><span class=\"line\">    expect($scope.config.prop).toEqual(<span class=\"string\">'value2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test @</span></span><br><span class=\"line\">    isolatedScope.notify = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    expect($scope.notify).toEqual(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test &amp;</span></span><br><span class=\"line\">    expect(<span class=\"keyword\">typeof</span>(isolatedScope.onChange)).toEqual(<span class=\"string\">'function'</span>);</span><br><span class=\"line\">    isolatedScope.onChange();</span><br><span class=\"line\">    expect($scope.onChange).toHaveBeenCalled();</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"comment\">//调用指令的父controller。</span></span><br><span class=\"line\">   directiveElem.scope().doFunction();</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于mock\"><a href=\"#关于mock\" class=\"headerlink\" title=\"关于mock\"></a>关于mock</h3><h4 id=\"httpBackend\"><a href=\"#httpBackend\" class=\"headerlink\" title=\"$httpBackend\"></a>$httpBackend</h4><p>$httpBackend对于代码中的http请求进行mock。常用方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$httpBackend.when(method, url, [data], [headers]);</span><br><span class=\"line\">$httpBackend.expect(method, url, [data], [headers]);</span><br></pre></td></tr></table></figure></p>\n<p>when和expect都有对应的快捷方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whenGET(url, [headers]);</span><br><span class=\"line\">whenHEAD(url, [headers]);</span><br><span class=\"line\">whenDELETE(url, [headers]);</span><br><span class=\"line\">whenPOST(url, [data], [headers]);</span><br><span class=\"line\">whenPUT(url, [data], [headers]);</span><br><span class=\"line\">whenJSONP(url);</span><br><span class=\"line\">expectGET(url, [headers]);</span><br><span class=\"line\">expectHEAD(url, [headers]);</span><br><span class=\"line\">expectDELETE(url, [headers]);</span><br><span class=\"line\">expectPOST(url, [data], [headers]);</span><br><span class=\"line\">expectPUT(url, [data], [headers]);</span><br><span class=\"line\">expectPATCH(url, [data], [headers]);</span><br><span class=\"line\">expectJSONP(url);</span><br></pre></td></tr></table></figure></p>\n<p>url支持正则，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$httpBackend.when(<span class=\"string\">'POST'</span>, /\\/api\\/wxcop\\/common\\/record.*<span class=\"regexp\">/).respond(&#123;&#125;);</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>$httpBackend.when与$httpBackend.expect的区别在于：$httpBackend.expect的伪后台只能被调用一次(调用一次后会被清除)，第二次调用就会报错，而且$httpBackend.resetExpectations可以移除所有的expect而对when没有影响。</p>\n<h3 id=\"常见异常处理\"><a href=\"#常见异常处理\" class=\"headerlink\" title=\"常见异常处理\"></a>常见异常处理</h3><h5 id=\"Argument-‘MainCtrl’-is-not-a-function-got-undefined\"><a href=\"#Argument-‘MainCtrl’-is-not-a-function-got-undefined\" class=\"headerlink\" title=\"Argument ‘MainCtrl’ is not a function, got undefined\"></a>Argument ‘MainCtrl’ is not a function, got undefined</h5><p>无法找到MainCtrl。可能原因：controller定义错误，app注入失败。</p>\n<h5 id=\"Disconnected-because-no-message-in-10000-ms\"><a href=\"#Disconnected-because-no-message-in-10000-ms\" class=\"headerlink\" title=\"Disconnected, because no message in 10000 ms.\"></a>Disconnected, because no message in 10000 ms.</h5><p>ajax请求超时。原因：$httpBackend.flush();要放在ajax发起请求后执行。</p>\n<h5 id=\"指令采用templateUrl方式加载模板失败\"><a href=\"#指令采用templateUrl方式加载模板失败\" class=\"headerlink\" title=\"指令采用templateUrl方式加载模板失败\"></a>指令采用templateUrl方式加载模板失败</h5><p>可采用karma-ng-html2js-preprocessor插件自动注入。也可以采用$templateCache注入。注意，这两种方式都不支持模糊匹配</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.sitepoint.com/angular-testing-tips-testing-directives/\" title=\"《AngularJS Testing Tips: Testing Directives》\" target=\"_blank\" rel=\"noopener\">《AngularJS Testing Tips: Testing Directives》</a><br><a href=\"https://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/\" target=\"_blank\" rel=\"noopener\">《Unit Testing in AngularJS: Services, Controllers &amp; Providers》</a><br><a href=\"https://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit/\" target=\"_blank\" rel=\"noopener\">《Unit Testing Services in AngularJS for Fun and for Profit》</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍了基于karma+jasmine的web前端自动化测试的方案和详细操作指导。</p>\n<h3 id=\"名词解释\"><a href=\"#名词解释\" class=\"headerlink\" title=\"名词解释\"></a>名词解释</h3><ol>\n<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</li>\n<li>Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。该工具可用于测试所有主流Web浏览器，也可集成到CI（Continuous integration）工具，也可和其他代码编辑器一起使用。这个测试工具的一个强大特性就是，它可以监控(Watch)文件的变化，然后自行执行，通过console.log显示测试结果。</li>\n<li>Jasmine 是一个简易的JS单元测试框架。Jasmine 不依赖于任何浏览器、DOM、或者是任何 JavaScript 而存在。它适用于所有网站、Node.js 项目，或者是任何能够在 JavaScript 上面运行的程序。</li>\n</ol>\n<h3 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h3><ol>\n<li>首先必须安装执行环境nodejs</li>\n<li>安装浏览器，推荐chrome（用于运行监听程序，监听js文件变化，自动触发测试执行）</li>\n<li>安装karma+jasmine<pre><code>npm install karma -g\nnpm install karma-jasmine -g\nnpm install karma-chrome-launcher -g \nnpm install karma-cli -g \nnpm install karma-coverage -g \nnpm install karma-html-reporter -g \n</code></pre></li>\n<li>安装完成后执行karma -v，检查安装是否正常</li>\n</ol>\n<h3 id=\"工程配置\"><a href=\"#工程配置\" class=\"headerlink\" title=\"工程配置\"></a>工程配置</h3><ol>\n<li>可以使用karma init，自动生成配置文件，完成部分参数的设置，然后再手动修改。</li>\n<li>当然最快的配置方法，复制下面的配置<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t<span class=\"comment\">// Karma configuration</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// Generated on Tue Nov 01 2016 14:17:00 GMT+0800 (中国标准时间)</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">\t\t  config.set(&#123;</span><br><span class=\"line\">\t\t  <span class=\"comment\">// base path that will be used to resolve all patterns (eg. files, exclude)</span></span><br><span class=\"line\">\t\t\tbasePath: <span class=\"string\">''</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// frameworks to use</span></span><br><span class=\"line\">        <span class=\"comment\">// available frameworks: https://npmjs.org/browse/keyword/karma-adapter</span></span><br><span class=\"line\">        frameworks: [<span class=\"string\">'jasmine'</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// list of files / patterns to load in the browser</span></span><br><span class=\"line\">        <span class=\"comment\">//需要加载入浏览器的js文件，包括基础的类库，被测试js文件和测试用例js文件</span></span><br><span class=\"line\">        <span class=\"comment\">//如果需要测试angular代码，比如引入angular-mock.js，给angular代码进行mock。</span></span><br><span class=\"line\">        <span class=\"comment\">//注意angular-mock的版本一定要和angular版本一致。可在cdn网站对应的angular版本列表中寻找</span></span><br><span class=\"line\">        files: [</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/jquery/jquery-1.10.2.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/angular/angular.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/vender/angular/angular-ui-router.min.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'lib/angular-mocks.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/*.js'</span>,</span><br><span class=\"line\">            <span class=\"string\">'../webapp/commont/template/*.html'</span>,</span><br><span class=\"line\">            <span class=\"string\">'tc/ut/**/*.js'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// list of files to exclude</span></span><br><span class=\"line\">        exclude: [</span><br><span class=\"line\">          <span class=\"comment\">//'../webapp/vender/**/*.js'</span></span><br><span class=\"line\">        ],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// test results reporter to use</span></span><br><span class=\"line\">        <span class=\"comment\">// possible values: 'dots', 'progress'</span></span><br><span class=\"line\">        <span class=\"comment\">// available reporters: https://npmjs.org/browse/keyword/karma-reporter</span></span><br><span class=\"line\">        <span class=\"comment\">//这里定义输出的报告</span></span><br><span class=\"line\">        <span class=\"comment\">//html对应karma-html-reporter组件，输出测试用例执行报告</span></span><br><span class=\"line\">        <span class=\"comment\">//coverage对应karma-coverage组件，输出测试用例执行报告</span></span><br><span class=\"line\">        reporters: [<span class=\"string\">'progress'</span>, <span class=\"string\">'html'</span>, <span class=\"string\">'junit'</span>, <span class=\"string\">'coverage'</span>],</span><br><span class=\"line\">        junitReporter: &#123;  </span><br><span class=\"line\">               <span class=\"comment\">// will be resolved to basePath (in the same way as files/exclude patterns)  </span></span><br><span class=\"line\">              outputFile: <span class=\"string\">'report/ut/test-results.xml'</span>,</span><br><span class=\"line\">              suite: <span class=\"string\">'UT'</span>,</span><br><span class=\"line\">              useBrowserName: <span class=\"literal\">false</span> </span><br><span class=\"line\">        &#125;,  </span><br><span class=\"line\">        htmlReporter: &#123;</span><br><span class=\"line\">          outputDir: <span class=\"string\">'report/ut'</span>,</span><br><span class=\"line\">          reportName: <span class=\"string\">'result'</span> <span class=\"comment\">//outputDir+reportName组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//定义需要统计覆盖率的文件</span></span><br><span class=\"line\">        preprocessors: &#123;</span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/*.js'</span>:<span class=\"string\">'coverage'</span>, </span><br><span class=\"line\">            <span class=\"string\">'../webapp/common/template/*.html'</span>: <span class=\"string\">'ng-html2js'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        coverageReporter: &#123;  </span><br><span class=\"line\">            type: <span class=\"string\">'html'</span>, <span class=\"comment\">//将覆盖率报告类型type设置为cobertura 或者 html</span></span><br><span class=\"line\">            subdir:<span class=\"string\">'coverage'</span>, <span class=\"comment\">//dir+subdir组成完整的输出报告格式，如没有定义，会自动生成浏览器+OS信息的文件夹，不方便读取报告</span></span><br><span class=\"line\">            dir: <span class=\"string\">'report/ut/'</span>  <span class=\"comment\">//代码覆盖率报告生成地址</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// web server port</span></span><br><span class=\"line\">        port: <span class=\"number\">9876</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// enable / disable colors in the output (reporters and logs)</span></span><br><span class=\"line\">        colors: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// level of logging</span></span><br><span class=\"line\">        <span class=\"comment\">// possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG</span></span><br><span class=\"line\">        logLevel: config.LOG_INFO,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// enable / disable watching file and executing tests whenever any file changes</span></span><br><span class=\"line\">        <span class=\"comment\">//karma自动自动监视被测试文件和测试用用例文件，如有修改，自动重新执行测试</span></span><br><span class=\"line\">        autoWatch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// Continuous Integration mode</span></span><br><span class=\"line\">        <span class=\"comment\">// if true, Karma captures browsers, runs the tests and exits</span></span><br><span class=\"line\">        <span class=\"comment\">//上一个参数为true，本参数为false，，则自动监视才生效。否则执行完测试用例后自动退出</span></span><br><span class=\"line\">        singleRun: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// start these browsers</span></span><br><span class=\"line\">        <span class=\"comment\">// available browser launchers: https://npmjs.org/browse/keyword/karma-launcher</span></span><br><span class=\"line\">        <span class=\"comment\">//用来执行自动监听的浏览器，推荐chrome</span></span><br><span class=\"line\">        browsers: [<span class=\"string\">'Chrome'</span>],</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// Concurrency level</span></span><br><span class=\"line\">        <span class=\"comment\">// how many browser should be started simultaneous</span></span><br><span class=\"line\">        concurrency: <span class=\"literal\">Infinity</span>，</span><br><span class=\"line\">       <span class=\"comment\">//自动将模板文件路径转换页面引入路径，以便注入用例中</span></span><br><span class=\"line\">        ngHtml2JsPreprocessor: &#123;</span><br><span class=\"line\">             cacheIdFromPath: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filepath</span>) </span>&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">var</span> cacheId = filepath.substr(filepath.lastIndexOf(<span class=\"string\">'/webapp/'</span>)+<span class=\"number\">7</span>);</span><br><span class=\"line\">                 <span class=\"comment\">// console.log(cacheId);</span></span><br><span class=\"line\">                 <span class=\"keyword\">return</span> cacheId;</span><br><span class=\"line\">               &#125;,</span><br><span class=\"line\">           moduleName: <span class=\"string\">'template'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">3. 保存配置文件到测试目录</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 测试用例编写</span></span><br><span class=\"line\"><span class=\"string\">#### 1、用例怎么写</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">describe(<span class=\"string\">\"A suite of Common/common.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tbeforeAll(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'beforeAll'</span>);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">   describe(<span class=\"string\">\"extends of String\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;\t</span><br><span class=\"line\">\t   <span class=\"keyword\">var</span> expected;</span><br><span class=\"line\">\t\tbeforeEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpected = <span class=\"string\">'abcd'</span>;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"trim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\" abcd \"</span>).trim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"ltrim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\" abcd\"</span>).ltrim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tit(<span class=\"string\">\"rtrim\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t\texpect(expected).toEqual((<span class=\"string\">\"abcd \"</span>).rtrim());</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>上述例子中，<br>a. describe相当于一个测试套，可以嵌套。<br>b. it(‘tc name’,function(){})是一个测试用例。<br>c. beforeAll和beforeEach是预置条件，前者一个测试套执行一次，后者每个测试用例执行一次。<br>d. 当然还会有afterAll和afterEach<br>e. expect是断言</p>\n<h4 id=\"2、-断言都有那些比较\"><a href=\"#2、-断言都有那些比较\" class=\"headerlink\" title=\"2、 断言都有那些比较\"></a>2、 断言都有那些比较</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Matcher实现了断言的比较操作，将Expectation传入的实际值和Matcher传入的期望值比较。任何Matcher都能通过在expect调用Matcher前加上not来实现一个否定的断言（expect(a).not().toBe(<span class=\"literal\">false</span>);）。</span><br><span class=\"line\">常用的Matchers有：</span><br><span class=\"line\">toBe()：相当于= =比较。</span><br><span class=\"line\">toNotBe():相当于! =比较。</span><br><span class=\"line\">toBeDefined()：检查变量或属性是否已声明且赋值。</span><br><span class=\"line\">toBeUndefined()</span><br><span class=\"line\">toBeNull()：是否是<span class=\"literal\">null</span>。</span><br><span class=\"line\">toBeTruthy()：如果转换为布尔值，是否为<span class=\"literal\">true</span>。</span><br><span class=\"line\">toBeFalsy()</span><br><span class=\"line\">toBeLessThan()：数值比较，小于。</span><br><span class=\"line\">toBeGreaterThan()：数值比较，大于。</span><br><span class=\"line\">toEqual()：相当于==，注意与toBe()的区别。一个新建的<span class=\"built_in\">Object</span>不是（not to be）另一个新建的<span class=\"built_in\">Object</span>，但是它们是相等（to equal）的。</span><br><span class=\"line\">expect(&#123;&#125;).not().toBe(&#123;&#125;);</span><br><span class=\"line\">expect(&#123;&#125;).toEqual(&#123;&#125;);</span><br><span class=\"line\">toNotEqual()</span><br><span class=\"line\">toContain()：数组中是否包含元素（值）。只能用于数组，不能用于对象。</span><br><span class=\"line\">toBeCloseTo()：数值比较时定义精度，先四舍五入后再比较。</span><br><span class=\"line\">toHaveBeenCalled()</span><br><span class=\"line\">toHaveBeenCalledWith()</span><br><span class=\"line\">toMatch()：按正则表达式匹配。</span><br><span class=\"line\">toNotMatch()</span><br><span class=\"line\">toThrow()：检验一个函数是否会抛出一个错误</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、-angular代码怎么写\"><a href=\"#3、-angular代码怎么写\" class=\"headerlink\" title=\"3、 angular代码怎么写\"></a>3、 angular代码怎么写</h4><p>先看例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe(<span class=\"string\">'Apply MainCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> $scope,</span><br><span class=\"line\">      $controller,</span><br><span class=\"line\">      $httpBackend;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> MainCtrl;</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(<span class=\"built_in\">module</span>(<span class=\"string\">'applyApp'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  beforeEach(inject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_$controller_, $rootScope,  _$httpBackend_</span>) </span>&#123;</span><br><span class=\"line\">    $scope = $rootScope.$<span class=\"keyword\">new</span>();</span><br><span class=\"line\">    $httpBackend = _$httpBackend_;</span><br><span class=\"line\">    $controller = _$controller_;</span><br><span class=\"line\">    $httpBackend.when(<span class=\"string\">'POST'</span>, /\\/api\\/wxcop\\/common\\/record.*<span class=\"regexp\">/).respond(&#123;&#125;);      </span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;));</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    it('Check $scope assignments.', function() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      MainCtrl = $controller('MainController', &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">            $scope: $scope</span></span><br><span class=\"line\"><span class=\"regexp\">        &#125;);      </span></span><br><span class=\"line\"><span class=\"regexp\">      $httpBackend.flush();</span></span><br><span class=\"line\"><span class=\"regexp\">      $scope.gotoApplyHome();</span></span><br><span class=\"line\"><span class=\"regexp\">      $scope.judgeLogin();</span></span><br><span class=\"line\"><span class=\"regexp\">      expect($scope.typeSelect).toEqual([\"单行文本\",\"多行文本\",\"单选\",\"多选\"]);</span></span><br><span class=\"line\"><span class=\"regexp\">      expect($scope.getItemItems(\"1,2，3\")).toEqual([\"1\",\"2\",\"3\"]);</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;);</span></span><br></pre></td></tr></table></figure>\n<p>注意，要测试angular必须引入angular-mock。<br>说明</p>\n<ol>\n<li>beforeEach(module(‘applyApp’));  引入module ‘applyApp’</li>\n<li>beforeEach(inject(function(<em>$controller</em>, $rootScope,  <em>$httpBackend</em>)  依赖注入和http测试打桩</li>\n<li>$controller(‘MainController’,  )初始化controller</li>\n<li>直接调用scope，然后执行断言</li>\n</ol>\n<h4 id=\"5、-angular的相关特性如何测试\"><a href=\"#5、-angular的相关特性如何测试\" class=\"headerlink\" title=\"5、 angular的相关特性如何测试\"></a>5、 angular的相关特性如何测试</h4><h5 id=\"1、测试函数\"><a href=\"#1、测试函数\" class=\"headerlink\" title=\"1、测试函数\"></a>1、测试函数</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.functionTriger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.doTest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t$scope.functionTriger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'function'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">    expect($scope.functionTriger).toBeFalsy();</span><br><span class=\"line\">    $scope.doTest();</span><br><span class=\"line\">    expect($scope.functionTriger).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2、测试监听\"><a href=\"#2、测试监听\" class=\"headerlink\" title=\"2、测试监听\"></a>2、测试监听</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.watchVar = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.watchedTrigeIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">$scope.$watch(<span class=\"string\">'watchVar'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    $scope.watchedTrigeIndex++;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'watch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">    $scope.watchVar = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">    $scope.watchVar = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.watchedTrigeIndex).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3、测试广播\"><a href=\"#3、测试广播\" class=\"headerlink\" title=\"3、测试广播\"></a>3、测试广播</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$scope.isHaveTriger = <span class=\"literal\">false</span>;</span><br><span class=\"line\">$scope.$on(<span class=\"string\">'ngRepeatFinished'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $scope.isHaveTriger = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'broadcast'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">  expect($scope.isHaveTriger).toBeFalsy();</span><br><span class=\"line\">  $scope.$broadcast(<span class=\"string\">'ngRepeatFinished'</span>);</span><br><span class=\"line\">  expect($scope.isHaveTriger).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"4、测试路由切换\"><a href=\"#4、测试路由切换\" class=\"headerlink\" title=\"4、测试路由切换\"></a>4、测试路由切换</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.config([<span class=\"string\">'$stateProvider'</span>, <span class=\"string\">'$urlRouterProvider'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$stateProvider, $urlRouterProvider</span>)</span>&#123;</span><br><span class=\"line\">    $urlRouterProvider.otherwise(<span class=\"string\">\"/detail\"</span>);</span><br><span class=\"line\">    $stateProvider.state(<span class=\"string\">'detail'</span>, &#123;</span><br><span class=\"line\">        url:<span class=\"string\">'/detail'</span>,</span><br><span class=\"line\">        template:<span class=\"string\">'&lt;p&gt;&lt;/p&gt;'</span>,</span><br><span class=\"line\">        controller:<span class=\"string\">'MainCtrl'</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;])</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'route'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    inject(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_$injector_</span>) </span>&#123;</span><br><span class=\"line\">      $state = _$injector_.get(<span class=\"string\">'$state'</span>);</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">    <span class=\"keyword\">var</span> curState = $state.get(<span class=\"string\">'detail'</span>);</span><br><span class=\"line\">    expect(curState.name).toEqual(<span class=\"string\">'detail'</span>);</span><br><span class=\"line\">    expect(curState.url).toEqual(<span class=\"string\">'/detail'</span>);</span><br><span class=\"line\">    expect(curState.controller).toEqual(<span class=\"string\">'MainCtrl'</span>);</span><br><span class=\"line\">    expect(curState.template).toEqual(<span class=\"string\">'&lt;p&gt;&lt;/p&gt;'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"5、测试过滤器\"><a href=\"#5、测试过滤器\" class=\"headerlink\" title=\"5、测试过滤器\"></a>5、测试过滤器</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.filter(<span class=\"string\">'myFilter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">return</span> data + <span class=\"string\">'lzw'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'filter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  inject(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">_$injector_</span>) </span>&#123;</span><br><span class=\"line\">    $filter = _$injector_.get(<span class=\"string\">'$filter'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"6、测试service\"><a href=\"#6、测试service\" class=\"headerlink\" title=\"6、测试service\"></a>6、测试service</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.service(<span class=\"string\">'foo'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisIsPrivate = <span class=\"string\">\"Private\"</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPrivate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> thisIsPrivate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        variable: <span class=\"string\">\"This is public\"</span>,</span><br><span class=\"line\">        getPrivate: getPrivate</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'service'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\">    inject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_foo_</span>) </span>&#123;</span><br><span class=\"line\">        foo = _foo_;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(foo.variable).toBe(<span class=\"string\">'This is public'</span>);</span><br><span class=\"line\">    expect(foo.getPrivate()).toBe(<span class=\"string\">'Private'</span>);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7、测试指令\"><a href=\"#7、测试指令\" class=\"headerlink\" title=\"7、测试指令\"></a>7、测试指令</h5><p>a.  被测试代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.directive(<span class=\"string\">'myDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        restrict: <span class=\"string\">'A'</span>,</span><br><span class=\"line\">        replace: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        template: <span class=\"string\">'&lt;p&gt;11&lt;/p&gt;'</span>,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>) </span>&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.directive(<span class=\"string\">'dirButton'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        template: <span class=\"string\">'&lt;button&gt;Increment value!&lt;/button&gt;'</span>,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scope, elem</span>) </span>&#123;</span><br><span class=\"line\">            elem.find(<span class=\"string\">'button'</span>).on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                scope.value++;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.directive(<span class=\"string\">'dirScope'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        scope:&#123;</span><br><span class=\"line\">            config: <span class=\"string\">'='</span>,</span><br><span class=\"line\">            notify: <span class=\"string\">'@'</span>,</span><br><span class=\"line\">            onChange:<span class=\"string\">'&amp;'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>)</span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>b. 测试用例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it(<span class=\"string\">'directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> link = $compile(<span class=\"string\">'&lt;p my-directive&gt;&lt;/p&gt;'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> element = link($scope);</span><br><span class=\"line\">    expect($(element).html()).toBe(<span class=\"string\">'11'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'button directive'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> directiveElem = $compile(<span class=\"string\">'&lt;button dir-button&gt;&lt;/button&gt;'</span>)($scope);</span><br><span class=\"line\">    $scope.value=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = directiveElem.find(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">    button.triggerHandler(<span class=\"string\">'click'</span>);</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    expect($scope.value).toEqual(<span class=\"number\">11</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  it(<span class=\"string\">'scope directive'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    $scope.config = &#123;</span><br><span class=\"line\">      prop: <span class=\"string\">'value'</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $scope.notify = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $scope.onChange = jasmine.createSpy(<span class=\"string\">'onChange'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> directiveElem = $compile(angular.element(<span class=\"string\">'&lt;p dir-scope config=\"config\" notify=\"notify\" on-change=\"onChange()\"&gt;&lt;/p&gt;'</span>))($scope);</span><br><span class=\"line\">    $scope.$digest();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isolatedScope = directiveElem.isolateScope();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test =    </span></span><br><span class=\"line\">    isolatedScope.config.prop = <span class=\"string\">\"value2\"</span>;</span><br><span class=\"line\">    expect($scope.config.prop).toEqual(<span class=\"string\">'value2'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test @</span></span><br><span class=\"line\">    isolatedScope.notify = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    expect($scope.notify).toEqual(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//test &amp;</span></span><br><span class=\"line\">    expect(<span class=\"keyword\">typeof</span>(isolatedScope.onChange)).toEqual(<span class=\"string\">'function'</span>);</span><br><span class=\"line\">    isolatedScope.onChange();</span><br><span class=\"line\">    expect($scope.onChange).toHaveBeenCalled();</span><br><span class=\"line\">\t</span><br><span class=\"line\">   <span class=\"comment\">//调用指令的父controller。</span></span><br><span class=\"line\">   directiveElem.scope().doFunction();</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"关于mock\"><a href=\"#关于mock\" class=\"headerlink\" title=\"关于mock\"></a>关于mock</h3><h4 id=\"httpBackend\"><a href=\"#httpBackend\" class=\"headerlink\" title=\"$httpBackend\"></a>$httpBackend</h4><p>$httpBackend对于代码中的http请求进行mock。常用方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$httpBackend.when(method, url, [data], [headers]);</span><br><span class=\"line\">$httpBackend.expect(method, url, [data], [headers]);</span><br></pre></td></tr></table></figure></p>\n<p>when和expect都有对应的快捷方法:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whenGET(url, [headers]);</span><br><span class=\"line\">whenHEAD(url, [headers]);</span><br><span class=\"line\">whenDELETE(url, [headers]);</span><br><span class=\"line\">whenPOST(url, [data], [headers]);</span><br><span class=\"line\">whenPUT(url, [data], [headers]);</span><br><span class=\"line\">whenJSONP(url);</span><br><span class=\"line\">expectGET(url, [headers]);</span><br><span class=\"line\">expectHEAD(url, [headers]);</span><br><span class=\"line\">expectDELETE(url, [headers]);</span><br><span class=\"line\">expectPOST(url, [data], [headers]);</span><br><span class=\"line\">expectPUT(url, [data], [headers]);</span><br><span class=\"line\">expectPATCH(url, [data], [headers]);</span><br><span class=\"line\">expectJSONP(url);</span><br></pre></td></tr></table></figure></p>\n<p>url支持正则，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$httpBackend.when(<span class=\"string\">'POST'</span>, /\\/api\\/wxcop\\/common\\/record.*<span class=\"regexp\">/).respond(&#123;&#125;);</span></span><br></pre></td></tr></table></figure></p>\n<p>注意：<br>$httpBackend.when与$httpBackend.expect的区别在于：$httpBackend.expect的伪后台只能被调用一次(调用一次后会被清除)，第二次调用就会报错，而且$httpBackend.resetExpectations可以移除所有的expect而对when没有影响。</p>\n<h3 id=\"常见异常处理\"><a href=\"#常见异常处理\" class=\"headerlink\" title=\"常见异常处理\"></a>常见异常处理</h3><h5 id=\"Argument-‘MainCtrl’-is-not-a-function-got-undefined\"><a href=\"#Argument-‘MainCtrl’-is-not-a-function-got-undefined\" class=\"headerlink\" title=\"Argument ‘MainCtrl’ is not a function, got undefined\"></a>Argument ‘MainCtrl’ is not a function, got undefined</h5><p>无法找到MainCtrl。可能原因：controller定义错误，app注入失败。</p>\n<h5 id=\"Disconnected-because-no-message-in-10000-ms\"><a href=\"#Disconnected-because-no-message-in-10000-ms\" class=\"headerlink\" title=\"Disconnected, because no message in 10000 ms.\"></a>Disconnected, because no message in 10000 ms.</h5><p>ajax请求超时。原因：$httpBackend.flush();要放在ajax发起请求后执行。</p>\n<h5 id=\"指令采用templateUrl方式加载模板失败\"><a href=\"#指令采用templateUrl方式加载模板失败\" class=\"headerlink\" title=\"指令采用templateUrl方式加载模板失败\"></a>指令采用templateUrl方式加载模板失败</h5><p>可采用karma-ng-html2js-preprocessor插件自动注入。也可以采用$templateCache注入。注意，这两种方式都不支持模糊匹配</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://www.sitepoint.com/angular-testing-tips-testing-directives/\" title=\"《AngularJS Testing Tips: Testing Directives》\" target=\"_blank\" rel=\"noopener\">《AngularJS Testing Tips: Testing Directives》</a><br><a href=\"https://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/\" target=\"_blank\" rel=\"noopener\">《Unit Testing in AngularJS: Services, Controllers &amp; Providers》</a><br><a href=\"https://nathanleclaire.com/blog/2014/04/12/unit-testing-services-in-angularjs-for-fun-and-for-profit/\" target=\"_blank\" rel=\"noopener\">《Unit Testing Services in AngularJS for Fun and for Profit》</a></p>\n"},{"title":"WEB前端介绍","date":"2016-10-16T11:39:06.000Z","_content":"## **1、WEB前端是神马**\n\nWeb前端开发是从网页制作演变而来的，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。2005年以后，互联网进入Web2.0时代，各种类似桌面软件的Web应用大量涌现，网站的前端由此发生了翻天覆地的变化。网页不再只是承载单一的文字和图片，各种富媒体让网页的内容更加生动，网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。 以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站（Web App网页应用和Hybrid App混合应用）的界面更好地呈现给用户。\n\n## **2、前端技术**\n\n### **W3C标准**\n\nW3C标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括HTML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。\n\n简单来说就是： html（结构） + css（表现） + js（行为）\n\n学习资源：[http://www.w3school.com.cn/](http://www.w3school.com.cn/) \n名词解释：W3C——万维网联盟（World Wide Web Consortium）\n\n### **HTML——WEB应用的基石**\n\nHyperText Markup Language 超文本标记语言。超文本是用超链接的方法，将各种不同空间的信息组织在一起的网状文本。信息可以包含图片、链接，甚至音乐、程序等非文字元素。\n\n### **html文件示例如下：**\n![](https://upload-images.jianshu.io/upload_images/4944427-b0e4fe78a10f1245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **标签的基本格式如下：**\n![](https://upload-images.jianshu.io/upload_images/4944427-200c7bc7b8a12f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例中的标签是个闭合标签，有部分标签不是闭合标签。例如：<input type=\"text\" name=\"test\" value=\"test\"/>\n\n一个标准的html文件主要包括如下常用的标签：\n\n- !DOCTYPE:文档类型声明，它的目的是要告诉浏览器，它应该使用什么样的文档类型定义来解析文档。示例中所示的文档类型是html5。文档类型一般是向下兼容的，html5基本兼容html4.01.\n- html：文档的根节点。<html> 与 </html> 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。\n- head：<head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。\n- meta：<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎的关键词，文件编码类型，浏览器版本等。\n- title：文档标题，浏览器的标签页显示的内容。\n- link：<link>标签定义文档与外部资源的关系，最常见的用途是链接样式表（css文件），ICON。\n- script：<script>标签用于定义客户端脚本，比如 JavaScript。既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。\n- style：<style> 标签用于为 HTML 文档定义样式信息。\n- body:body 元素定义文档的主体。\n- h1~h6：<h1> 定义最大的标题。<h6> 定义最小的标题。\n- div：<div> 可定义文档中的分区或节，可以把文档分割为独立的、不同的部分\n- p：<p> 标签定义段落。\n- span：<span> 标签被用来组合文档中的行内元素。\n- a:<a> 标签定义超链接，用于从一张页面链接到另一张页面，最重要的属性是 href 属性，它指示链接的目标。\n- button：<button> 标签定义一个按钮。\n- img：img 元素向网页中嵌入一幅图像。\n- input：<input> 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、单选按钮、按钮等等。\n\n其他更多标签，请见：[http://www.w3school.com.cn/tags/tag_doctype.asp](#/_blank)\n\n### **文档流**\n![](https://upload-images.jianshu.io/upload_images/4944427-cc38e0d5778d1508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n冷知识：W3C规范中没有document flow这个概念，只有normal-flow, 文档流的叫法主要还是多数中文译者的翻译方式问题。据说来源于报纸的排版。\n\n什么是文档流？简单说就是元素按照其在HTML中决定标签位置顺序排布的过程。并且这种过程遵循标准的描述。html的文档流规则是将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素。\n\n### **块级标签和内联标签**\n\nHTML中的标签主要是块级标签或内联标签。块级标签一般是其他标签的容器标签，能容纳其他块标签或内联标签。简单来说，块标签就好比一个四方块，可以放其他的四方块，并可以呈现在页面上任何地方。默认情况下块标签，是独占一行的。常见的块标签：div、h1-h6标题、form（只能用来容纳其他块标签）、hr、p、table、ul、ol等。内联标签也叫内嵌标签或行内标签，一般都是基于语义级(semantic)的基本标签。内联标签只能容纳文本或者其他内联标签，常见内联标签有a和span。 \n\n块标签与内联标签的区别？ \n1. 块级标签，总是在新行上开始；内联标签，和其他标签都在一行上。\n2. 块级标签，能容纳其他块标签或内联标签；内联标签，只能容纳文本或者其他内联标签。 \n3. 块级标签中高度，行高以及顶和底边距都可控制；内联标签中高，行高及顶和底边距不可改变。\n\n在实际应用中，可以通过CSS修改标签的display属性转变标签的性质，进行相互转换。建议按照原始性质使用，尽量不进行转换。\n\n### **如何设计html？**\n\n如下图，通常先设计好结构图，然后根据结构图再进行标签的书写。\n![](https://upload-images.jianshu.io/upload_images/4944427-b5704c57de05413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## **HTML5**\n\nHTML4.01版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。多媒体的大量应用，各类app不断涌现。不同于HTML4.01完全由W3C制定。HTML5 是 W3C 与 WHATWG 合作的结果。WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。HTML5草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。最终在2014年定稿。\n\n注：W3C 指 World Wide Web Consortium，万维网联盟。\n注：WHATWG 指 Web Hypertext Application Technology Working Group，Web超文本应用技术工作组。\n\n### **HTML5建立的一些规则：**\n1. 新特性应该基于 HTML、CSS、DOM 以及 JavaScript。\n2. 减少对外部插件的需求（比如 Flash）\n3. 更优秀的错误处理\n4. 更多取代脚本的标记\n5. HTML5应该独立于设备\n\n### **HTML5中的新特性**\n1. 用于绘画的 canvas 元素\n2. 用于多媒体的 video 和 audio 元素\n3. 对本地离线存储的更好的支持\n4. 新的特殊内容元素，比如 article、footer、header、nav、section\n5. 新的表单控件，比如 calendar、date、time、email、url、search\n\n### **浏览器支持**\n最新版本的 Chrome、Firefox、Safari 以及 Opera 基本上完全支持 HTML5 特性。IE9开始支持某些 HTML5 特性。详细对比：\n[http://caniuse.com/#comparison](#/_blank)  \n[http://html5test.com/compare/browser/firefoxmobile-35/chrome-39/ie-8.html](#/_blank)\n\n### **HTML4.01和HTML5结构区别**\n ![](https://upload-images.jianshu.io/upload_images/4944427-86ac4ec9e255f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### **HTML5新特性简单示例**\n### **canvas**\ncanvas标签使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n代码示例：\n```\n<!DOCTYPE html>\n <html>\n     <body>\n         <canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #c3c3c3;\">\n             Your browser does not support the canvas element.\n         </canvas>\n         <script type=\"text/javascript\">\n             var c=document.getElementById(\"myCanvas\");\n             var cxt=c.getContext(\"2d\");//指定二维绘图，目前只支持2D绘图，后续可能会支持3D\n             cxt.moveTo(10,10);//绘制起点。（0，0）对应左上角，向右和向下递增\n             cxt.lineTo(150,50);//画一条直线（10,10）到（150,50）\n             cxt.lineTo(10,50);//画一条直线（150,50）到（10,50）\n             cxt.strokeStyle=\"green\"; //指定线条颜色\n             cxt.stroke();//显示绘图结果\n         </script>\n     </body>\n </html>\n```\n### **vedio/audio**\n在HTML5以前，如果您想在网页中嵌入在线观看的视频，一般都需要使用Flash视频流，通过使用 <object> 和 <embed> 标签，就可以通过浏览器播放swf、flv等格式视频文件，但是前提是浏览器必须安装第三方插件：Adobe Flash Player。而现代智能手机和iPad等一般都不支持Flash，所以无法浏览网页上的视频。而 HTML 5 改变了这一事实，Web开发者只需要使用 <video> 标签就可以轻松加载视频文件，而不需要任何第三方插件。\n\nvedio支持的视频格式有三种：\n1. Ogg  带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件\n2. MPEG4（MP4）带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\n3. WebM  带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\n\n代码示例：\n```\n <video id=\"coures-video\" class=\"vjs-tech\" preload=\"none\" \n     poster=\"http://demo.com/upload/course/20160104/1451886552971.jpg\"\n     controls=\"controls\" loop=\"loop\" width=\"640px\" height=\"480px;\"> \n      <source src=\"http://demo.com/upload/course/20160104/1451886551972.mp4\" type=\"video/mp4\">\n </video>\n```\naudio与vedio基本相同,不再赘述。\n\n### **Drag 和 Drop**\n拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。只需要简单的几个属性和响应函数即可实现拖放。\n\n代码示例：\n```\n<div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\">\n     <img src=\"http://demo.com/images/11.jpg\" draggable=\"true\"     ondragstart=\"drag(event)\" id=\"drag1\" />\n </div>\n <div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n```  \n```\n //ondragover 事件规定在何处放置被拖动的数据。\n function allowDrop(ev){\n     ev.preventDefault();\n }\n //移动响应事件，获取正在移动的标签ID\n function drag(ev){\n     ev.dataTransfer.setData(\"Text\",ev.target.id);\n }\n //进行放置 响应事件\n function drop(ev) {\n     ev.preventDefault();\n     var data=ev.dataTransfer.getData(\"Text\");\n     ev.target.appendChild(document.getElementById(data));\n }\n```\n### **INPUT新类型**\nHTML5 拥有多个新的表单输入类型，这些新特性提供了更好的输入控制和验证。email，url，number，range，Date pickers (date, month, week, time, datetime, datetime-local)，search，color 。\n- email 类型用于应该包含 e-mail 地址的输入域，在提交表单时，会自动验证 email 域的值：\n    <input type=\"email\" name=\"user_email\" />\n- number 类型用于应该包含数值的输入域，还能够设定对所接受的数字的限定：\n   <input type=\"number\" name=\"points\" min=\"1\" max=\"10\" />\n- Date Pickers（日期选择器）拥有多个可供选取日期和时间的新输入类型：\ndate - 选取日、月、年\nmonth - 选取月、年\nweek - 选取周和年\ntime - 选取时间（小时和分钟）\ndatetime - 选取时间、日、月、年（UTC 时间）\ndatetime-local - 选取时间、日、月、年（本地时间）\n <input type=\"date\" name=\"user_date\" />\n\n### **本地存储**\n说到本地存储，真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：\n![](https://upload-images.jianshu.io/upload_images/4944427-e930aa1ef64979c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最早的Cookies大小约4KB，而且IE6只支持每个域名20个cookies。优势就是大家都支持，而且支持得还比较好。后来IE又推出了userData，现在用的比较多的是Flash，空间是Cookie的25倍，基本够用。再之后Google推出了Gears，虽然没有限制，但是要装额外的插件。到了HTML5把这些都统一了，官方建议是每个网站5MB。所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较适合的。\n\n对于重复的数据，HTML5可以直接从本地存储中读取数据，不必每次都向服务器发起请求从服务器获取。从而大幅提高网站性能和支持离线运行。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。\n\nHTML5 提供了两种在客户端存储数据的方法：\n1. localStorage - 没有时间限制的数据存储\n2. sessionStorage - 针对一个 session 的数据存储\n\nHTML5 使用 JavaScript 来存储和访问数据。使用方法如下：\n```\nif (localStorage.pagecount){ \n    localStorage.pagecount=Number(localStorage.pagecount) +1;\n } else {\n     localStorage.pagecount=1;\n }\n document.write(\"Visits: \" + localStorage.pagecount + \" time(s).\");\n```\n## **CSS**\n层叠样式表 (Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，有较强的易读性，被称为程序员的画笔。\n### **如何使用样式表？**\n\n有三种方法可以在网页上使用样式表：\n\n1.  外联式Linking（也叫外部样式）\n当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。\n```\n<head>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n</head>\n```\n2. 嵌入式Embedding（也叫内页样式）\n当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 <style> 标签定义内部样式表。\n```\n<head>\n  <style type=\"text/css\"> \n    body {background-color: red} \n    p {margin-left: 20px}\n  </style>\n</head>\n```\n3. 内联式Inline（也叫行内样式）\n当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。\n```\n<p style=\"color: red; margin-left: 20px\"> \nThis is a paragraph \n</p>\n```\n### **如何定义样式表**\n\nCSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。如下图所示\n\n![](https://upload-images.jianshu.io/upload_images/4944427-df91f0bb24f4066a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### **选择器类型：**\n1. 标签选择器 p  <p></p>\n2. 类选择器 .my-class  <p class=\"my-class\"></p>\n3. ID选择器 #myDiv  <div id=\"myDiv\"></div>\n4. 属性选择器 [type=\"radio\"] <input type=\"radio\" />\n5. 伪类/伪元素选择器 a:hover\n6. 以及上述各种选择器的组合。\n\n更多介绍，详见：[http://www.w3school.com.cn/cssref/css_selectors.asp](#/_blank)\n\n### **盒模型**\n网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)。这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。盒模型的模型如下图\n![](https://upload-images.jianshu.io/upload_images/4944427-57b0c88cb9d4c137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/4944427-1ba2ba1a7fb9259f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **display属性**\ndisplay 属性规定了元素应该生成的框的类型。在上面html章节中我们提到了块级标签和内联标签，这只是默认属性，通过CSS中的display进行修改。还可以通过display控制标签是否显示。\ndisplay常见的属性值如下：\n| 值 | 描述|\n|--|--|\n|none|此元素不会被显示。 |\n|block|此元素将显示为块级元素，此元素前后会带有换行符。|\n|inline|默认。此元素会被显示为内联元素，元素前后没有换行符。 |\n|inline-block|行内块元素。（CSS2.1 新增的值）|\n|table|此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。|\n\n### **position属性**\n\nposition 属性规定元素的定位类型。这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在文档流中的默认位置偏移。\n| 值 | 描述 |\n|--|--|\n| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。|\n| fixed | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n|relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 |\n| static | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |\n| inherit | 规定应该从父元素继承 position 属性的值。 |\n\n示例：\n![](https://upload-images.jianshu.io/upload_images/4944427-41ae02b45dade8ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/4944427-40d3d157ccdd74d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n参考资料：[http://blog.jobbole.com/49320/](#/_blank)\n\n### **float属性**\nfloat 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。\n|值|描述| \n|--|--| \n|left|元素向左浮动。|\n|right|元素向右浮动。 |\n| none| 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |\n| inherit | 规定应该从父元素继承 float 属性的值。|\n\n示例：\n\n- 正常文档流\n![](https://upload-images.jianshu.io/upload_images/4944427-aa0d8c1aa75d3d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 设置float，浏览器的宽度“不够长”时 ![图片18.png](https://upload-images.jianshu.io/upload_images/4944427-423465a304018193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 设置float，浏览器的宽度“足够长”时\n![图片19.png](https://upload-images.jianshu.io/upload_images/4944427-7a9ebd1861bad959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n参考资料：[http://www.cnblogs.com/polk6/archive/2013/07/25/3142187.html](#/_blank)\n\n### **浮动子标签撑开父标签**\n\n子标签如果都设置为float，会导致父标签没有高度值。导致结构错乱。\n\n如下两种方法可以解决：\n\n1. 添加一个空的div，设置clear属性为both\n![](https://upload-images.jianshu.io/upload_images/4944427-bc7177b5998354f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 父标签增加伪类，设置clear属性为both\n![图片21.png](https://upload-images.jianshu.io/upload_images/4944427-c2171dea0bb5eeec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **其他常用属性**\n```\n background-color: gray;  /*背景颜色*/\nborder: 2px solid #e4e4e4; /*边框尺寸、类型、颜色*/\n font-family: 宋体;  /*字体*/\ncolor: #234567; /*文字颜色*/\nfont-size: 13px;  /*文字大小*/\nwidth: 70px;  /*宽度*/\nheight: 70px;  /*高度*/\n```\n### **CSS优先级**\n由于CSS选择器可以有多种形式，可以继承，可以重复定义。所以具体哪个样式生效需要计算优先级。注意：优先级相同时，晚定义的样式有效。\n通常情况下，给每个选择器设置一个数值，数值越大，优先级越高。实际没有这个数值，只是一种近似。\nhtml标签 （1）\nclass  （10）\nid  （100）\n计算示例：\ndiv p     1+1 = 2\nspan.test 1+10 = 11\n#id.test     100 + 10 = 110\n不同引入方式引入的CSS，优先级也不同。排序规则如下：!important > inline >id > class > tag\n\n### **CSS3**\nCSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。\n\n参考：[http://www.w3school.com.cn/css3/](#/_blank)\n\n## **javascript**\n\n**java ≠ javascript  就像 马 ≠ 海马**\n\nJavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。JavaScript是甲骨文公司的注册商标，最初由Netscape的Brendan Eich设计。Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。\n\nJavaScript脚本语言具有以下特点:\n1. 脚本语言。JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。\n2. 基于对象。JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。\n3. 简单。JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。\n4. 动态性。JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。\n5. 跨平台性。JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，部署成本小。\n\n不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。\n\n而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。\n\nJavaScript被Netscape公司提交给ECMA(European Computer Manufacturers Association)制定为标准，称之为ECMAScript，标准编号ECMA-262。目前最新版为2015年发布的ECMAScript 6。\n\n下面对javascript的常用操作进行举例：\n\n### **写入 HTML 输出**\n```\ndocument.write(\"<h1>This is a heading</h1>\");\ndocument.write(\"<p>This is a paragraph</p>\");\n```\n### **对事件作出反应**\n```\n<button type=\"button\" onclick=\"alert('Welcome!')\">点击这里</button>\n```\nalert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。\nonclick 鼠标点击事件。\n\n### **改变 HTML 内容**\n```\nx=document.getElementById(\"demo\")  //查找元素\nx.innerHTML=\"Hello JavaScript\";    //改变内容\nvar img=document.getElementById(\"myImg\")  //查找元素\nimg.src=\"/i/eg_bulbon.gif\";\n```\n您会经常看到 document.getElementByID(\"some id\")。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。\n\n### **改变 HTML 样式**\n```\nx=document.getElementById(\"demo\")  //找到元素\nx.style.color=\"#ff0000\";           //改变样式\n```\n### **验证输入**\n```\nif isNaN(x) {alert(\"Not Numeric\")};\n```\n详细的语言特性，参考：[http://www.w3school.com.cn/js/index.asp](#/_blank)\n\n### **jQuery**\n\nJQuery一个优秀的轻量级的Javascript库。它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。目前，绝大多数网站都在使用jQuery。\n\n示例：\n```\n$(\"#h01\").attr(\"style\",\"color:red\").html(\"Hello jQuery\")\n```\n详细的语言特性，参考：[http://www.w3school.com.cn/jquery/](#/_blank)\n\n## **浏览器兼容**\n\n浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。因为不同浏览器使用内核及所支持的HTML，JS，CSS标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。最常见的问题就是网页元素位置混乱，错位，动态效果失效等等。\n\n举例：\n1. IE的盒模型与W3C标准不符。\n2. IE8不支持html5的vedio，只能使用flash播放视频。\n3. IE8不支持图片圆角\n4. DOM 个别操作不一致\n```\nvar obj = document.getElementById('objId');\nobj.setAttribute('onclick','funcitonname();'); //FIREFOX支持，IE不支持 \nobj.onclick=function(){fucntionname();}; //都支持\n```\n## **前端调试工具**\n\n推荐使用Chrome devtools。\n\n## **关于UX和前端**\n\n在前端开发过程中一般会引入比较成熟的前端框架，例如：Bootstarp（[http://v3.bootcss.com/getting-started/](#/_blank)）。所以在UI设计时需要进行沟通，一旦选择了框架，尽量能和框架风格保持一致。当然也可以完全重新定义风格和自己开发。\n\n同样在图标使用上，一般也会选择成熟的图标库，例如：Font Awesome，Glyphicons。（[http://www.bootcss.com/p/font-awesome/](#/_blank)）\n\n上面提到的兼容性设计问题。如果要支持IE8这类古董浏览器。再设计时很多新特性都无法支持，如果一定要支持，成本会很大。\n","source":"_posts/FE/web前端介绍.md","raw":"---\ntitle: WEB前端介绍\ndate: 2016-10-16 19:39:06\ntags: [前端]\n---\n## **1、WEB前端是神马**\n\nWeb前端开发是从网页制作演变而来的，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。2005年以后，互联网进入Web2.0时代，各种类似桌面软件的Web应用大量涌现，网站的前端由此发生了翻天覆地的变化。网页不再只是承载单一的文字和图片，各种富媒体让网页的内容更加生动，网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。 以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站（Web App网页应用和Hybrid App混合应用）的界面更好地呈现给用户。\n\n## **2、前端技术**\n\n### **W3C标准**\n\nW3C标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括HTML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。\n\n简单来说就是： html（结构） + css（表现） + js（行为）\n\n学习资源：[http://www.w3school.com.cn/](http://www.w3school.com.cn/) \n名词解释：W3C——万维网联盟（World Wide Web Consortium）\n\n### **HTML——WEB应用的基石**\n\nHyperText Markup Language 超文本标记语言。超文本是用超链接的方法，将各种不同空间的信息组织在一起的网状文本。信息可以包含图片、链接，甚至音乐、程序等非文字元素。\n\n### **html文件示例如下：**\n![](https://upload-images.jianshu.io/upload_images/4944427-b0e4fe78a10f1245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **标签的基本格式如下：**\n![](https://upload-images.jianshu.io/upload_images/4944427-200c7bc7b8a12f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n示例中的标签是个闭合标签，有部分标签不是闭合标签。例如：<input type=\"text\" name=\"test\" value=\"test\"/>\n\n一个标准的html文件主要包括如下常用的标签：\n\n- !DOCTYPE:文档类型声明，它的目的是要告诉浏览器，它应该使用什么样的文档类型定义来解析文档。示例中所示的文档类型是html5。文档类型一般是向下兼容的，html5基本兼容html4.01.\n- html：文档的根节点。<html> 与 </html> 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。\n- head：<head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。\n- meta：<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎的关键词，文件编码类型，浏览器版本等。\n- title：文档标题，浏览器的标签页显示的内容。\n- link：<link>标签定义文档与外部资源的关系，最常见的用途是链接样式表（css文件），ICON。\n- script：<script>标签用于定义客户端脚本，比如 JavaScript。既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。\n- style：<style> 标签用于为 HTML 文档定义样式信息。\n- body:body 元素定义文档的主体。\n- h1~h6：<h1> 定义最大的标题。<h6> 定义最小的标题。\n- div：<div> 可定义文档中的分区或节，可以把文档分割为独立的、不同的部分\n- p：<p> 标签定义段落。\n- span：<span> 标签被用来组合文档中的行内元素。\n- a:<a> 标签定义超链接，用于从一张页面链接到另一张页面，最重要的属性是 href 属性，它指示链接的目标。\n- button：<button> 标签定义一个按钮。\n- img：img 元素向网页中嵌入一幅图像。\n- input：<input> 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、单选按钮、按钮等等。\n\n其他更多标签，请见：[http://www.w3school.com.cn/tags/tag_doctype.asp](#/_blank)\n\n### **文档流**\n![](https://upload-images.jianshu.io/upload_images/4944427-cc38e0d5778d1508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n冷知识：W3C规范中没有document flow这个概念，只有normal-flow, 文档流的叫法主要还是多数中文译者的翻译方式问题。据说来源于报纸的排版。\n\n什么是文档流？简单说就是元素按照其在HTML中决定标签位置顺序排布的过程。并且这种过程遵循标准的描述。html的文档流规则是将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素。\n\n### **块级标签和内联标签**\n\nHTML中的标签主要是块级标签或内联标签。块级标签一般是其他标签的容器标签，能容纳其他块标签或内联标签。简单来说，块标签就好比一个四方块，可以放其他的四方块，并可以呈现在页面上任何地方。默认情况下块标签，是独占一行的。常见的块标签：div、h1-h6标题、form（只能用来容纳其他块标签）、hr、p、table、ul、ol等。内联标签也叫内嵌标签或行内标签，一般都是基于语义级(semantic)的基本标签。内联标签只能容纳文本或者其他内联标签，常见内联标签有a和span。 \n\n块标签与内联标签的区别？ \n1. 块级标签，总是在新行上开始；内联标签，和其他标签都在一行上。\n2. 块级标签，能容纳其他块标签或内联标签；内联标签，只能容纳文本或者其他内联标签。 \n3. 块级标签中高度，行高以及顶和底边距都可控制；内联标签中高，行高及顶和底边距不可改变。\n\n在实际应用中，可以通过CSS修改标签的display属性转变标签的性质，进行相互转换。建议按照原始性质使用，尽量不进行转换。\n\n### **如何设计html？**\n\n如下图，通常先设计好结构图，然后根据结构图再进行标签的书写。\n![](https://upload-images.jianshu.io/upload_images/4944427-b5704c57de05413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## **HTML5**\n\nHTML4.01版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。多媒体的大量应用，各类app不断涌现。不同于HTML4.01完全由W3C制定。HTML5 是 W3C 与 WHATWG 合作的结果。WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。HTML5草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。最终在2014年定稿。\n\n注：W3C 指 World Wide Web Consortium，万维网联盟。\n注：WHATWG 指 Web Hypertext Application Technology Working Group，Web超文本应用技术工作组。\n\n### **HTML5建立的一些规则：**\n1. 新特性应该基于 HTML、CSS、DOM 以及 JavaScript。\n2. 减少对外部插件的需求（比如 Flash）\n3. 更优秀的错误处理\n4. 更多取代脚本的标记\n5. HTML5应该独立于设备\n\n### **HTML5中的新特性**\n1. 用于绘画的 canvas 元素\n2. 用于多媒体的 video 和 audio 元素\n3. 对本地离线存储的更好的支持\n4. 新的特殊内容元素，比如 article、footer、header、nav、section\n5. 新的表单控件，比如 calendar、date、time、email、url、search\n\n### **浏览器支持**\n最新版本的 Chrome、Firefox、Safari 以及 Opera 基本上完全支持 HTML5 特性。IE9开始支持某些 HTML5 特性。详细对比：\n[http://caniuse.com/#comparison](#/_blank)  \n[http://html5test.com/compare/browser/firefoxmobile-35/chrome-39/ie-8.html](#/_blank)\n\n### **HTML4.01和HTML5结构区别**\n ![](https://upload-images.jianshu.io/upload_images/4944427-86ac4ec9e255f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### **HTML5新特性简单示例**\n### **canvas**\ncanvas标签使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n代码示例：\n```\n<!DOCTYPE html>\n <html>\n     <body>\n         <canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #c3c3c3;\">\n             Your browser does not support the canvas element.\n         </canvas>\n         <script type=\"text/javascript\">\n             var c=document.getElementById(\"myCanvas\");\n             var cxt=c.getContext(\"2d\");//指定二维绘图，目前只支持2D绘图，后续可能会支持3D\n             cxt.moveTo(10,10);//绘制起点。（0，0）对应左上角，向右和向下递增\n             cxt.lineTo(150,50);//画一条直线（10,10）到（150,50）\n             cxt.lineTo(10,50);//画一条直线（150,50）到（10,50）\n             cxt.strokeStyle=\"green\"; //指定线条颜色\n             cxt.stroke();//显示绘图结果\n         </script>\n     </body>\n </html>\n```\n### **vedio/audio**\n在HTML5以前，如果您想在网页中嵌入在线观看的视频，一般都需要使用Flash视频流，通过使用 <object> 和 <embed> 标签，就可以通过浏览器播放swf、flv等格式视频文件，但是前提是浏览器必须安装第三方插件：Adobe Flash Player。而现代智能手机和iPad等一般都不支持Flash，所以无法浏览网页上的视频。而 HTML 5 改变了这一事实，Web开发者只需要使用 <video> 标签就可以轻松加载视频文件，而不需要任何第三方插件。\n\nvedio支持的视频格式有三种：\n1. Ogg  带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件\n2. MPEG4（MP4）带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件\n3. WebM  带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件\n\n代码示例：\n```\n <video id=\"coures-video\" class=\"vjs-tech\" preload=\"none\" \n     poster=\"http://demo.com/upload/course/20160104/1451886552971.jpg\"\n     controls=\"controls\" loop=\"loop\" width=\"640px\" height=\"480px;\"> \n      <source src=\"http://demo.com/upload/course/20160104/1451886551972.mp4\" type=\"video/mp4\">\n </video>\n```\naudio与vedio基本相同,不再赘述。\n\n### **Drag 和 Drop**\n拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。只需要简单的几个属性和响应函数即可实现拖放。\n\n代码示例：\n```\n<div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\">\n     <img src=\"http://demo.com/images/11.jpg\" draggable=\"true\"     ondragstart=\"drag(event)\" id=\"drag1\" />\n </div>\n <div id=\"div2\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n```  \n```\n //ondragover 事件规定在何处放置被拖动的数据。\n function allowDrop(ev){\n     ev.preventDefault();\n }\n //移动响应事件，获取正在移动的标签ID\n function drag(ev){\n     ev.dataTransfer.setData(\"Text\",ev.target.id);\n }\n //进行放置 响应事件\n function drop(ev) {\n     ev.preventDefault();\n     var data=ev.dataTransfer.getData(\"Text\");\n     ev.target.appendChild(document.getElementById(data));\n }\n```\n### **INPUT新类型**\nHTML5 拥有多个新的表单输入类型，这些新特性提供了更好的输入控制和验证。email，url，number，range，Date pickers (date, month, week, time, datetime, datetime-local)，search，color 。\n- email 类型用于应该包含 e-mail 地址的输入域，在提交表单时，会自动验证 email 域的值：\n    <input type=\"email\" name=\"user_email\" />\n- number 类型用于应该包含数值的输入域，还能够设定对所接受的数字的限定：\n   <input type=\"number\" name=\"points\" min=\"1\" max=\"10\" />\n- Date Pickers（日期选择器）拥有多个可供选取日期和时间的新输入类型：\ndate - 选取日、月、年\nmonth - 选取月、年\nweek - 选取周和年\ntime - 选取时间（小时和分钟）\ndatetime - 选取时间、日、月、年（UTC 时间）\ndatetime-local - 选取时间、日、月、年（本地时间）\n <input type=\"date\" name=\"user_date\" />\n\n### **本地存储**\n说到本地存储，真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：\n![](https://upload-images.jianshu.io/upload_images/4944427-e930aa1ef64979c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n最早的Cookies大小约4KB，而且IE6只支持每个域名20个cookies。优势就是大家都支持，而且支持得还比较好。后来IE又推出了userData，现在用的比较多的是Flash，空间是Cookie的25倍，基本够用。再之后Google推出了Gears，虽然没有限制，但是要装额外的插件。到了HTML5把这些都统一了，官方建议是每个网站5MB。所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较适合的。\n\n对于重复的数据，HTML5可以直接从本地存储中读取数据，不必每次都向服务器发起请求从服务器获取。从而大幅提高网站性能和支持离线运行。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。\n\nHTML5 提供了两种在客户端存储数据的方法：\n1. localStorage - 没有时间限制的数据存储\n2. sessionStorage - 针对一个 session 的数据存储\n\nHTML5 使用 JavaScript 来存储和访问数据。使用方法如下：\n```\nif (localStorage.pagecount){ \n    localStorage.pagecount=Number(localStorage.pagecount) +1;\n } else {\n     localStorage.pagecount=1;\n }\n document.write(\"Visits: \" + localStorage.pagecount + \" time(s).\");\n```\n## **CSS**\n层叠样式表 (Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，有较强的易读性，被称为程序员的画笔。\n### **如何使用样式表？**\n\n有三种方法可以在网页上使用样式表：\n\n1.  外联式Linking（也叫外部样式）\n当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。\n```\n<head>\n<link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\">\n</head>\n```\n2. 嵌入式Embedding（也叫内页样式）\n当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 <style> 标签定义内部样式表。\n```\n<head>\n  <style type=\"text/css\"> \n    body {background-color: red} \n    p {margin-left: 20px}\n  </style>\n</head>\n```\n3. 内联式Inline（也叫行内样式）\n当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。\n```\n<p style=\"color: red; margin-left: 20px\"> \nThis is a paragraph \n</p>\n```\n### **如何定义样式表**\n\nCSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。如下图所示\n\n![](https://upload-images.jianshu.io/upload_images/4944427-df91f0bb24f4066a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### **选择器类型：**\n1. 标签选择器 p  <p></p>\n2. 类选择器 .my-class  <p class=\"my-class\"></p>\n3. ID选择器 #myDiv  <div id=\"myDiv\"></div>\n4. 属性选择器 [type=\"radio\"] <input type=\"radio\" />\n5. 伪类/伪元素选择器 a:hover\n6. 以及上述各种选择器的组合。\n\n更多介绍，详见：[http://www.w3school.com.cn/cssref/css_selectors.asp](#/_blank)\n\n### **盒模型**\n网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)。这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。盒模型的模型如下图\n![](https://upload-images.jianshu.io/upload_images/4944427-57b0c88cb9d4c137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/4944427-1ba2ba1a7fb9259f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **display属性**\ndisplay 属性规定了元素应该生成的框的类型。在上面html章节中我们提到了块级标签和内联标签，这只是默认属性，通过CSS中的display进行修改。还可以通过display控制标签是否显示。\ndisplay常见的属性值如下：\n| 值 | 描述|\n|--|--|\n|none|此元素不会被显示。 |\n|block|此元素将显示为块级元素，此元素前后会带有换行符。|\n|inline|默认。此元素会被显示为内联元素，元素前后没有换行符。 |\n|inline-block|行内块元素。（CSS2.1 新增的值）|\n|table|此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。|\n\n### **position属性**\n\nposition 属性规定元素的定位类型。这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在文档流中的默认位置偏移。\n| 值 | 描述 |\n|--|--|\n| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。|\n| fixed | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 \"left\", \"top\", \"right\" 以及 \"bottom\" 属性进行规定。 |\n|relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，\"left:20\" 会向元素的 LEFT 位置添加 20 像素。 |\n| static | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |\n| inherit | 规定应该从父元素继承 position 属性的值。 |\n\n示例：\n![](https://upload-images.jianshu.io/upload_images/4944427-41ae02b45dade8ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](https://upload-images.jianshu.io/upload_images/4944427-40d3d157ccdd74d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n参考资料：[http://blog.jobbole.com/49320/](#/_blank)\n\n### **float属性**\nfloat 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。\n|值|描述| \n|--|--| \n|left|元素向左浮动。|\n|right|元素向右浮动。 |\n| none| 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |\n| inherit | 规定应该从父元素继承 float 属性的值。|\n\n示例：\n\n- 正常文档流\n![](https://upload-images.jianshu.io/upload_images/4944427-aa0d8c1aa75d3d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 设置float，浏览器的宽度“不够长”时 ![图片18.png](https://upload-images.jianshu.io/upload_images/4944427-423465a304018193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 设置float，浏览器的宽度“足够长”时\n![图片19.png](https://upload-images.jianshu.io/upload_images/4944427-7a9ebd1861bad959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n参考资料：[http://www.cnblogs.com/polk6/archive/2013/07/25/3142187.html](#/_blank)\n\n### **浮动子标签撑开父标签**\n\n子标签如果都设置为float，会导致父标签没有高度值。导致结构错乱。\n\n如下两种方法可以解决：\n\n1. 添加一个空的div，设置clear属性为both\n![](https://upload-images.jianshu.io/upload_images/4944427-bc7177b5998354f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 父标签增加伪类，设置clear属性为both\n![图片21.png](https://upload-images.jianshu.io/upload_images/4944427-c2171dea0bb5eeec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### **其他常用属性**\n```\n background-color: gray;  /*背景颜色*/\nborder: 2px solid #e4e4e4; /*边框尺寸、类型、颜色*/\n font-family: 宋体;  /*字体*/\ncolor: #234567; /*文字颜色*/\nfont-size: 13px;  /*文字大小*/\nwidth: 70px;  /*宽度*/\nheight: 70px;  /*高度*/\n```\n### **CSS优先级**\n由于CSS选择器可以有多种形式，可以继承，可以重复定义。所以具体哪个样式生效需要计算优先级。注意：优先级相同时，晚定义的样式有效。\n通常情况下，给每个选择器设置一个数值，数值越大，优先级越高。实际没有这个数值，只是一种近似。\nhtml标签 （1）\nclass  （10）\nid  （100）\n计算示例：\ndiv p     1+1 = 2\nspan.test 1+10 = 11\n#id.test     100 + 10 = 110\n不同引入方式引入的CSS，优先级也不同。排序规则如下：!important > inline >id > class > tag\n\n### **CSS3**\nCSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。\n\n参考：[http://www.w3school.com.cn/css3/](#/_blank)\n\n## **javascript**\n\n**java ≠ javascript  就像 马 ≠ 海马**\n\nJavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。JavaScript是甲骨文公司的注册商标，最初由Netscape的Brendan Eich设计。Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。\n\nJavaScript脚本语言具有以下特点:\n1. 脚本语言。JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。\n2. 基于对象。JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。\n3. 简单。JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。\n4. 动态性。JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。\n5. 跨平台性。JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，部署成本小。\n\n不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。\n\n而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。\n\nJavaScript被Netscape公司提交给ECMA(European Computer Manufacturers Association)制定为标准，称之为ECMAScript，标准编号ECMA-262。目前最新版为2015年发布的ECMAScript 6。\n\n下面对javascript的常用操作进行举例：\n\n### **写入 HTML 输出**\n```\ndocument.write(\"<h1>This is a heading</h1>\");\ndocument.write(\"<p>This is a paragraph</p>\");\n```\n### **对事件作出反应**\n```\n<button type=\"button\" onclick=\"alert('Welcome!')\">点击这里</button>\n```\nalert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。\nonclick 鼠标点击事件。\n\n### **改变 HTML 内容**\n```\nx=document.getElementById(\"demo\")  //查找元素\nx.innerHTML=\"Hello JavaScript\";    //改变内容\nvar img=document.getElementById(\"myImg\")  //查找元素\nimg.src=\"/i/eg_bulbon.gif\";\n```\n您会经常看到 document.getElementByID(\"some id\")。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。\n\n### **改变 HTML 样式**\n```\nx=document.getElementById(\"demo\")  //找到元素\nx.style.color=\"#ff0000\";           //改变样式\n```\n### **验证输入**\n```\nif isNaN(x) {alert(\"Not Numeric\")};\n```\n详细的语言特性，参考：[http://www.w3school.com.cn/js/index.asp](#/_blank)\n\n### **jQuery**\n\nJQuery一个优秀的轻量级的Javascript库。它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。目前，绝大多数网站都在使用jQuery。\n\n示例：\n```\n$(\"#h01\").attr(\"style\",\"color:red\").html(\"Hello jQuery\")\n```\n详细的语言特性，参考：[http://www.w3school.com.cn/jquery/](#/_blank)\n\n## **浏览器兼容**\n\n浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。因为不同浏览器使用内核及所支持的HTML，JS，CSS标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。最常见的问题就是网页元素位置混乱，错位，动态效果失效等等。\n\n举例：\n1. IE的盒模型与W3C标准不符。\n2. IE8不支持html5的vedio，只能使用flash播放视频。\n3. IE8不支持图片圆角\n4. DOM 个别操作不一致\n```\nvar obj = document.getElementById('objId');\nobj.setAttribute('onclick','funcitonname();'); //FIREFOX支持，IE不支持 \nobj.onclick=function(){fucntionname();}; //都支持\n```\n## **前端调试工具**\n\n推荐使用Chrome devtools。\n\n## **关于UX和前端**\n\n在前端开发过程中一般会引入比较成熟的前端框架，例如：Bootstarp（[http://v3.bootcss.com/getting-started/](#/_blank)）。所以在UI设计时需要进行沟通，一旦选择了框架，尽量能和框架风格保持一致。当然也可以完全重新定义风格和自己开发。\n\n同样在图标使用上，一般也会选择成熟的图标库，例如：Font Awesome，Glyphicons。（[http://www.bootcss.com/p/font-awesome/](#/_blank)）\n\n上面提到的兼容性设计问题。如果要支持IE8这类古董浏览器。再设计时很多新特性都无法支持，如果一定要支持，成本会很大。\n","slug":"FE/web前端介绍","published":1,"updated":"2018-03-11T14:08:01.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvxp0000tccml2nsc0dh","content":"<h2 id=\"1、WEB前端是神马\"><a href=\"#1、WEB前端是神马\" class=\"headerlink\" title=\"1、WEB前端是神马\"></a><strong>1、WEB前端是神马</strong></h2><p>Web前端开发是从网页制作演变而来的，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。2005年以后，互联网进入Web2.0时代，各种类似桌面软件的Web应用大量涌现，网站的前端由此发生了翻天覆地的变化。网页不再只是承载单一的文字和图片，各种富媒体让网页的内容更加生动，网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。 以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站（Web App网页应用和Hybrid App混合应用）的界面更好地呈现给用户。</p>\n<h2 id=\"2、前端技术\"><a href=\"#2、前端技术\" class=\"headerlink\" title=\"2、前端技术\"></a><strong>2、前端技术</strong></h2><h3 id=\"W3C标准\"><a href=\"#W3C标准\" class=\"headerlink\" title=\"W3C标准\"></a><strong>W3C标准</strong></h3><p>W3C标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括HTML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。</p>\n<p>简单来说就是： html（结构） + css（表现） + js（行为）</p>\n<p>学习资源：<a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/</a><br>名词解释：W3C——万维网联盟（World Wide Web Consortium）</p>\n<h3 id=\"HTML——WEB应用的基石\"><a href=\"#HTML——WEB应用的基石\" class=\"headerlink\" title=\"HTML——WEB应用的基石\"></a><strong>HTML——WEB应用的基石</strong></h3><p>HyperText Markup Language 超文本标记语言。超文本是用超链接的方法，将各种不同空间的信息组织在一起的网状文本。信息可以包含图片、链接，甚至音乐、程序等非文字元素。</p>\n<h3 id=\"html文件示例如下：\"><a href=\"#html文件示例如下：\" class=\"headerlink\" title=\"html文件示例如下：\"></a><strong>html文件示例如下：</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-b0e4fe78a10f1245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"标签的基本格式如下：\"><a href=\"#标签的基本格式如下：\" class=\"headerlink\" title=\"标签的基本格式如下：\"></a><strong>标签的基本格式如下：</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-200c7bc7b8a12f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>示例中的标签是个闭合标签，有部分标签不是闭合标签。例如：<input type=\"text\" name=\"test\" value=\"test\"></p>\n<p>一个标准的html文件主要包括如下常用的标签：</p>\n<ul>\n<li>!DOCTYPE:文档类型声明，它的目的是要告诉浏览器，它应该使用什么样的文档类型定义来解析文档。示例中所示的文档类型是html5。文档类型一般是向下兼容的，html5基本兼容html4.01.</li>\n<li>html：文档的根节点。<html> 与 </html> 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。</li>\n<li>head：<head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</head></head></li>\n<li>meta：<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎的关键词，文件编码类型，浏览器版本等。</li>\n<li>title：文档标题，浏览器的标签页显示的内容。</li>\n<li>link：<link>标签定义文档与外部资源的关系，最常见的用途是链接样式表（css文件），ICON。</li>\n<li>script：<script>标签用于定义客户端脚本，比如 JavaScript。既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。</li>\n<li>style：<style> 标签用于为 HTML 文档定义样式信息。</li>\n<li>body:body 元素定义文档的主体。</li>\n<li>h1~h6：<h1> 定义最大的标题。<h6> 定义最小的标题。</li>\n<li>div：<div> 可定义文档中的分区或节，可以把文档分割为独立的、不同的部分</li>\n<li>p：<p> 标签定义段落。</li>\n<li>span：<span> 标签被用来组合文档中的行内元素。</li>\n<li>a:<a> 标签定义超链接，用于从一张页面链接到另一张页面，最重要的属性是 href 属性，它指示链接的目标。</li>\n<li>button：<button> 标签定义一个按钮。</li>\n<li>img：img 元素向网页中嵌入一幅图像。</li>\n<li>input：<input> 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、单选按钮、按钮等等。</li>\n</ul>\n<p>其他更多标签，请见：<a href=\"#/_blank\">http://www.w3school.com.cn/tags/tag_doctype.asp</a></p>\n<h3 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a><strong>文档流</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-cc38e0d5778d1508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>冷知识：W3C规范中没有document flow这个概念，只有normal-flow, 文档流的叫法主要还是多数中文译者的翻译方式问题。据说来源于报纸的排版。</p>\n<p>什么是文档流？简单说就是元素按照其在HTML中决定标签位置顺序排布的过程。并且这种过程遵循标准的描述。html的文档流规则是将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素。</p>\n<h3 id=\"块级标签和内联标签\"><a href=\"#块级标签和内联标签\" class=\"headerlink\" title=\"块级标签和内联标签\"></a><strong>块级标签和内联标签</strong></h3><p>HTML中的标签主要是块级标签或内联标签。块级标签一般是其他标签的容器标签，能容纳其他块标签或内联标签。简单来说，块标签就好比一个四方块，可以放其他的四方块，并可以呈现在页面上任何地方。默认情况下块标签，是独占一行的。常见的块标签：div、h1-h6标题、form（只能用来容纳其他块标签）、hr、p、table、ul、ol等。内联标签也叫内嵌标签或行内标签，一般都是基于语义级(semantic)的基本标签。内联标签只能容纳文本或者其他内联标签，常见内联标签有a和span。 </p>\n<p>块标签与内联标签的区别？ </p>\n<ol>\n<li>块级标签，总是在新行上开始；内联标签，和其他标签都在一行上。</li>\n<li>块级标签，能容纳其他块标签或内联标签；内联标签，只能容纳文本或者其他内联标签。 </li>\n<li>块级标签中高度，行高以及顶和底边距都可控制；内联标签中高，行高及顶和底边距不可改变。</li>\n</ol>\n<p>在实际应用中，可以通过CSS修改标签的display属性转变标签的性质，进行相互转换。建议按照原始性质使用，尽量不进行转换。</p>\n<h3 id=\"如何设计html？\"><a href=\"#如何设计html？\" class=\"headerlink\" title=\"如何设计html？\"></a><strong>如何设计html？</strong></h3><p>如下图，通常先设计好结构图，然后根据结构图再进行标签的书写。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-b5704c57de05413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a><strong>HTML5</strong></h2><p>HTML4.01版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。多媒体的大量应用，各类app不断涌现。不同于HTML4.01完全由W3C制定。HTML5 是 W3C 与 WHATWG 合作的结果。WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。HTML5草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。最终在2014年定稿。</p>\n<p>注：W3C 指 World Wide Web Consortium，万维网联盟。<br>注：WHATWG 指 Web Hypertext Application Technology Working Group，Web超文本应用技术工作组。</p>\n<h3 id=\"HTML5建立的一些规则：\"><a href=\"#HTML5建立的一些规则：\" class=\"headerlink\" title=\"HTML5建立的一些规则：\"></a><strong>HTML5建立的一些规则：</strong></h3><ol>\n<li>新特性应该基于 HTML、CSS、DOM 以及 JavaScript。</li>\n<li>减少对外部插件的需求（比如 Flash）</li>\n<li>更优秀的错误处理</li>\n<li>更多取代脚本的标记</li>\n<li>HTML5应该独立于设备</li>\n</ol>\n<h3 id=\"HTML5中的新特性\"><a href=\"#HTML5中的新特性\" class=\"headerlink\" title=\"HTML5中的新特性\"></a><strong>HTML5中的新特性</strong></h3><ol>\n<li>用于绘画的 canvas 元素</li>\n<li>用于多媒体的 video 和 audio 元素</li>\n<li>对本地离线存储的更好的支持</li>\n<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>\n<li>新的表单控件，比如 calendar、date、time、email、url、search</li>\n</ol>\n<h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a><strong>浏览器支持</strong></h3><p>最新版本的 Chrome、Firefox、Safari 以及 Opera 基本上完全支持 HTML5 特性。IE9开始支持某些 HTML5 特性。详细对比：<br><a href=\"#/_blank\">http://caniuse.com/#comparison</a><br><a href=\"#/_blank\">http://html5test.com/compare/browser/firefoxmobile-35/chrome-39/ie-8.html</a></p>\n<h3 id=\"HTML4-01和HTML5结构区别\"><a href=\"#HTML4-01和HTML5结构区别\" class=\"headerlink\" title=\"HTML4.01和HTML5结构区别\"></a><strong>HTML4.01和HTML5结构区别</strong></h3><p> <img src=\"https://upload-images.jianshu.io/upload_images/4944427-86ac4ec9e255f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"HTML5新特性简单示例\"><a href=\"#HTML5新特性简单示例\" class=\"headerlink\" title=\"HTML5新特性简单示例\"></a><strong>HTML5新特性简单示例</strong></h3><h3 id=\"canvas\"><a href=\"#canvas\" class=\"headerlink\" title=\"canvas\"></a><strong>canvas</strong></h3><p>canvas标签使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。<br>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\"> &lt;html&gt;</span><br><span class=\"line\">     &lt;body&gt;</span><br><span class=\"line\">         &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #c3c3c3;&quot;&gt;</span><br><span class=\"line\">             Your browser does not support the canvas element.</span><br><span class=\"line\">         &lt;/canvas&gt;</span><br><span class=\"line\">         &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">             var c=document.getElementById(&quot;myCanvas&quot;);</span><br><span class=\"line\">             var cxt=c.getContext(&quot;2d&quot;);//指定二维绘图，目前只支持2D绘图，后续可能会支持3D</span><br><span class=\"line\">             cxt.moveTo(10,10);//绘制起点。（0，0）对应左上角，向右和向下递增</span><br><span class=\"line\">             cxt.lineTo(150,50);//画一条直线（10,10）到（150,50）</span><br><span class=\"line\">             cxt.lineTo(10,50);//画一条直线（150,50）到（10,50）</span><br><span class=\"line\">             cxt.strokeStyle=&quot;green&quot;; //指定线条颜色</span><br><span class=\"line\">             cxt.stroke();//显示绘图结果</span><br><span class=\"line\">         &lt;/script&gt;</span><br><span class=\"line\">     &lt;/body&gt;</span><br><span class=\"line\"> &lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"vedio-audio\"><a href=\"#vedio-audio\" class=\"headerlink\" title=\"vedio/audio\"></a><strong>vedio/audio</strong></h3><p>在HTML5以前，如果您想在网页中嵌入在线观看的视频，一般都需要使用Flash视频流，通过使用 <object> 和 <embed> 标签，就可以通过浏览器播放swf、flv等格式视频文件，但是前提是浏览器必须安装第三方插件：Adobe Flash Player。而现代智能手机和iPad等一般都不支持Flash，所以无法浏览网页上的视频。而 HTML 5 改变了这一事实，Web开发者只需要使用 <video> 标签就可以轻松加载视频文件，而不需要任何第三方插件。</p>\n<p>vedio支持的视频格式有三种：</p>\n<ol>\n<li>Ogg  带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li>\n<li>MPEG4（MP4）带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li>\n<li>WebM  带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li>\n</ol>\n<p>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;video id=&quot;coures-video&quot; class=&quot;vjs-tech&quot; preload=&quot;none&quot; </span><br><span class=\"line\">     poster=&quot;http://demo.com/upload/course/20160104/1451886552971.jpg&quot;</span><br><span class=\"line\">     controls=&quot;controls&quot; loop=&quot;loop&quot; width=&quot;640px&quot; height=&quot;480px;&quot;&gt; </span><br><span class=\"line\">      &lt;source src=&quot;http://demo.com/upload/course/20160104/1451886551972.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\"> &lt;/video&gt;</span><br></pre></td></tr></table></figure></p>\n<p>audio与vedio基本相同,不再赘述。</p>\n<h3 id=\"Drag-和-Drop\"><a href=\"#Drag-和-Drop\" class=\"headerlink\" title=\"Drag 和 Drop\"></a><strong>Drag 和 Drop</strong></h3><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。只需要简单的几个属性和响应函数即可实现拖放。</p>\n<p>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;</span><br><span class=\"line\">     &lt;img src=&quot;http://demo.com/images/11.jpg&quot; draggable=&quot;true&quot;     ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; /&gt;</span><br><span class=\"line\"> &lt;/div&gt;</span><br><span class=\"line\"> &lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure></p>\n<p> //ondragover 事件规定在何处放置被拖动的数据。<br> function allowDrop(ev){<br>     ev.preventDefault();<br> }<br> //移动响应事件，获取正在移动的标签ID<br> function drag(ev){<br>     ev.dataTransfer.setData(“Text”,ev.target.id);<br> }<br> //进行放置 响应事件<br> function drop(ev) {<br>     ev.preventDefault();<br>     var data=ev.dataTransfer.getData(“Text”);<br>     ev.target.appendChild(document.getElementById(data));<br> }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **INPUT新类型**</span><br><span class=\"line\">HTML5 拥有多个新的表单输入类型，这些新特性提供了更好的输入控制和验证。email，url，number，range，Date pickers (date, month, week, time, datetime, datetime-local)，search，color 。</span><br><span class=\"line\">- email 类型用于应该包含 e-mail 地址的输入域，在提交表单时，会自动验证 email 域的值：</span><br><span class=\"line\">    &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</span><br><span class=\"line\">- number 类型用于应该包含数值的输入域，还能够设定对所接受的数字的限定：</span><br><span class=\"line\">   &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</span><br><span class=\"line\">- Date Pickers（日期选择器）拥有多个可供选取日期和时间的新输入类型：</span><br><span class=\"line\">date - 选取日、月、年</span><br><span class=\"line\">month - 选取月、年</span><br><span class=\"line\">week - 选取周和年</span><br><span class=\"line\">time - 选取时间（小时和分钟）</span><br><span class=\"line\">datetime - 选取时间、日、月、年（UTC 时间）</span><br><span class=\"line\">datetime-local - 选取时间、日、月、年（本地时间）</span><br><span class=\"line\"> &lt;input type=&quot;date&quot; name=&quot;user_date&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">### **本地存储**</span><br><span class=\"line\">说到本地存储，真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-e930aa1ef64979c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">最早的Cookies大小约4KB，而且IE6只支持每个域名20个cookies。优势就是大家都支持，而且支持得还比较好。后来IE又推出了userData，现在用的比较多的是Flash，空间是Cookie的25倍，基本够用。再之后Google推出了Gears，虽然没有限制，但是要装额外的插件。到了HTML5把这些都统一了，官方建议是每个网站5MB。所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较适合的。</span><br><span class=\"line\"></span><br><span class=\"line\">对于重复的数据，HTML5可以直接从本地存储中读取数据，不必每次都向服务器发起请求从服务器获取。从而大幅提高网站性能和支持离线运行。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">HTML5 提供了两种在客户端存储数据的方法：</span><br><span class=\"line\">1. localStorage - 没有时间限制的数据存储</span><br><span class=\"line\">2. sessionStorage - 针对一个 session 的数据存储</span><br><span class=\"line\"></span><br><span class=\"line\">HTML5 使用 JavaScript 来存储和访问数据。使用方法如下：</span><br></pre></td></tr></table></figure></p>\n<p>if (localStorage.pagecount){<br>    localStorage.pagecount=Number(localStorage.pagecount) +1;<br> } else {<br>     localStorage.pagecount=1;<br> }<br> document.write(“Visits: “ + localStorage.pagecount + “ time(s).”);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## **CSS**</span><br><span class=\"line\">层叠样式表 (Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，有较强的易读性，被称为程序员的画笔。</span><br><span class=\"line\">### **如何使用样式表？**</span><br><span class=\"line\"></span><br><span class=\"line\">有三种方法可以在网页上使用样式表：</span><br><span class=\"line\"></span><br><span class=\"line\">1.  外联式Linking（也叫外部样式）</span><br><span class=\"line\">当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</span><br></pre></td></tr></table></figure></p>\n<p><head></p>\n<p><link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"><br></head><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 嵌入式Embedding（也叫内页样式）</span><br><span class=\"line\">当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 &lt;style&gt; 标签定义内部样式表。</span><br></pre></td></tr></table></figure></p>\n<p><head><br>  <style type=\"text/css\"><br>    body {background-color: red}<br>    p {margin-left: 20px}<br>  </style><br></head><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. 内联式Inline（也叫行内样式）</span><br><span class=\"line\">当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</span><br></pre></td></tr></table></figure></p>\n<p><p style=\"color: red; margin-left: 20px\"><br>This is a paragraph<br></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **如何定义样式表**</span><br><span class=\"line\"></span><br><span class=\"line\">CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。如下图所示</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-df91f0bb24f4066a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### **选择器类型：**</span><br><span class=\"line\">1. 标签选择器 p  &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">2. 类选择器 .my-class  &lt;p class=&quot;my-class&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">3. ID选择器 #myDiv  &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">4. 属性选择器 [type=&quot;radio&quot;] &lt;input type=&quot;radio&quot; /&gt;</span><br><span class=\"line\">5. 伪类/伪元素选择器 a:hover</span><br><span class=\"line\">6. 以及上述各种选择器的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">更多介绍，详见：[http://www.w3school.com.cn/cssref/css_selectors.asp](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **盒模型**</span><br><span class=\"line\">网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)。这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。盒模型的模型如下图</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-57b0c88cb9d4c137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-1ba2ba1a7fb9259f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">### **display属性**</span><br><span class=\"line\">display 属性规定了元素应该生成的框的类型。在上面html章节中我们提到了块级标签和内联标签，这只是默认属性，通过CSS中的display进行修改。还可以通过display控制标签是否显示。</span><br><span class=\"line\">display常见的属性值如下：</span><br><span class=\"line\">| 值 | 描述|</span><br><span class=\"line\">|--|--|</span><br><span class=\"line\">|none|此元素不会被显示。 |</span><br><span class=\"line\">|block|此元素将显示为块级元素，此元素前后会带有换行符。|</span><br><span class=\"line\">|inline|默认。此元素会被显示为内联元素，元素前后没有换行符。 |</span><br><span class=\"line\">|inline-block|行内块元素。（CSS2.1 新增的值）|</span><br><span class=\"line\">|table|此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。|</span><br><span class=\"line\"></span><br><span class=\"line\">### **position属性**</span><br><span class=\"line\"></span><br><span class=\"line\">position 属性规定元素的定位类型。这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在文档流中的默认位置偏移。</span><br><span class=\"line\">| 值 | 描述 |</span><br><span class=\"line\">|--|--|</span><br><span class=\"line\">| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。|</span><br><span class=\"line\">| fixed | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。 |</span><br><span class=\"line\">|relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。 |</span><br><span class=\"line\">| static | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |</span><br><span class=\"line\">| inherit | 规定应该从父元素继承 position 属性的值。 |</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-41ae02b45dade8ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-40d3d157ccdd74d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">参考资料：[http://blog.jobbole.com/49320/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **float属性**</span><br><span class=\"line\">float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。</span><br><span class=\"line\">|值|描述| </span><br><span class=\"line\">|--|--| </span><br><span class=\"line\">|left|元素向左浮动。|</span><br><span class=\"line\">|right|元素向右浮动。 |</span><br><span class=\"line\">| none| 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |</span><br><span class=\"line\">| inherit | 规定应该从父元素继承 float 属性的值。|</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\"></span><br><span class=\"line\">- 正常文档流</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-aa0d8c1aa75d3d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">- 设置float，浏览器的宽度“不够长”时 ![图片18.png](https://upload-images.jianshu.io/upload_images/4944427-423465a304018193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">- 设置float，浏览器的宽度“足够长”时</span><br><span class=\"line\">![图片19.png](https://upload-images.jianshu.io/upload_images/4944427-7a9ebd1861bad959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">参考资料：[http://www.cnblogs.com/polk6/archive/2013/07/25/3142187.html](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **浮动子标签撑开父标签**</span><br><span class=\"line\"></span><br><span class=\"line\">子标签如果都设置为float，会导致父标签没有高度值。导致结构错乱。</span><br><span class=\"line\"></span><br><span class=\"line\">如下两种方法可以解决：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 添加一个空的div，设置clear属性为both</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-bc7177b5998354f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">2. 父标签增加伪类，设置clear属性为both</span><br><span class=\"line\">![图片21.png](https://upload-images.jianshu.io/upload_images/4944427-c2171dea0bb5eeec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">### **其他常用属性**</span><br></pre></td></tr></table></figure></p>\n<p> background-color: gray;  /<em>背景颜色</em>/<br>border: 2px solid #e4e4e4; /<em>边框尺寸、类型、颜色</em>/<br> font-family: 宋体;  /<em>字体</em>/<br>color: #234567; /<em>文字颜色</em>/<br>font-size: 13px;  /<em>文字大小</em>/<br>width: 70px;  /<em>宽度</em>/<br>height: 70px;  /<em>高度</em>/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **CSS优先级**</span><br><span class=\"line\">由于CSS选择器可以有多种形式，可以继承，可以重复定义。所以具体哪个样式生效需要计算优先级。注意：优先级相同时，晚定义的样式有效。</span><br><span class=\"line\">通常情况下，给每个选择器设置一个数值，数值越大，优先级越高。实际没有这个数值，只是一种近似。</span><br><span class=\"line\">html标签 （1）</span><br><span class=\"line\">class  （10）</span><br><span class=\"line\">id  （100）</span><br><span class=\"line\">计算示例：</span><br><span class=\"line\">div p     1+1 = 2</span><br><span class=\"line\">span.test 1+10 = 11</span><br><span class=\"line\">#id.test     100 + 10 = 110</span><br><span class=\"line\">不同引入方式引入的CSS，优先级也不同。排序规则如下：!important &gt; inline &gt;id &gt; class &gt; tag</span><br><span class=\"line\"></span><br><span class=\"line\">### **CSS3**</span><br><span class=\"line\">CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。</span><br><span class=\"line\"></span><br><span class=\"line\">参考：[http://www.w3school.com.cn/css3/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">## **javascript**</span><br><span class=\"line\"></span><br><span class=\"line\">**java ≠ javascript  就像 马 ≠ 海马**</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。JavaScript是甲骨文公司的注册商标，最初由Netscape的Brendan Eich设计。Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript脚本语言具有以下特点:</span><br><span class=\"line\">1. 脚本语言。JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。</span><br><span class=\"line\">2. 基于对象。JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。</span><br><span class=\"line\">3. 简单。JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。</span><br><span class=\"line\">4. 动态性。JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。</span><br><span class=\"line\">5. 跨平台性。JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，部署成本小。</span><br><span class=\"line\"></span><br><span class=\"line\">不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。</span><br><span class=\"line\"></span><br><span class=\"line\">而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript被Netscape公司提交给ECMA(European Computer Manufacturers Association)制定为标准，称之为ECMAScript，标准编号ECMA-262。目前最新版为2015年发布的ECMAScript 6。</span><br><span class=\"line\"></span><br><span class=\"line\">下面对javascript的常用操作进行举例：</span><br><span class=\"line\"></span><br><span class=\"line\">### **写入 HTML 输出**</span><br></pre></td></tr></table></figure></p>\n<p>document.write(“<h1>This is a heading</h1>“);<br>document.write(“<p>This is a paragraph</p>“);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **对事件作出反应**</span><br></pre></td></tr></table></figure></p>\n<p><button type=\"button\" onclick=\"alert('Welcome!')\">点击这里</button><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</span><br><span class=\"line\">onclick 鼠标点击事件。</span><br><span class=\"line\"></span><br><span class=\"line\">### **改变 HTML 内容**</span><br></pre></td></tr></table></figure></p>\n<p>x=document.getElementById(“demo”)  //查找元素<br>x.innerHTML=”Hello JavaScript”;    //改变内容<br>var img=document.getElementById(“myImg”)  //查找元素<br>img.src=”/i/eg_bulbon.gif”;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您会经常看到 document.getElementByID(&quot;some id&quot;)。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。</span><br><span class=\"line\"></span><br><span class=\"line\">### **改变 HTML 样式**</span><br></pre></td></tr></table></figure></p>\n<p>x=document.getElementById(“demo”)  //找到元素<br>x.style.color=”#ff0000”;           //改变样式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **验证输入**</span><br></pre></td></tr></table></figure></p>\n<p>if isNaN(x) {alert(“Not Numeric”)};<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细的语言特性，参考：[http://www.w3school.com.cn/js/index.asp](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **jQuery**</span><br><span class=\"line\"></span><br><span class=\"line\">JQuery一个优秀的轻量级的Javascript库。它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。目前，绝大多数网站都在使用jQuery。</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br></pre></td></tr></table></figure></p>\n<p>$(“#h01”).attr(“style”,”color:red”).html(“Hello jQuery”)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细的语言特性，参考：[http://www.w3school.com.cn/jquery/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">## **浏览器兼容**</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。因为不同浏览器使用内核及所支持的HTML，JS，CSS标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。最常见的问题就是网页元素位置混乱，错位，动态效果失效等等。</span><br><span class=\"line\"></span><br><span class=\"line\">举例：</span><br><span class=\"line\">1. IE的盒模型与W3C标准不符。</span><br><span class=\"line\">2. IE8不支持html5的vedio，只能使用flash播放视频。</span><br><span class=\"line\">3. IE8不支持图片圆角</span><br><span class=\"line\">4. DOM 个别操作不一致</span><br></pre></td></tr></table></figure></p>\n<p>var obj = document.getElementById(‘objId’);<br>obj.setAttribute(‘onclick’,’funcitonname();’); //FIREFOX支持，IE不支持<br>obj.onclick=function(){fucntionname();}; //都支持<br>```</p>\n<h2 id=\"前端调试工具\"><a href=\"#前端调试工具\" class=\"headerlink\" title=\"前端调试工具\"></a><strong>前端调试工具</strong></h2><p>推荐使用Chrome devtools。</p>\n<h2 id=\"关于UX和前端\"><a href=\"#关于UX和前端\" class=\"headerlink\" title=\"关于UX和前端\"></a><strong>关于UX和前端</strong></h2><p>在前端开发过程中一般会引入比较成熟的前端框架，例如：Bootstarp（<a href=\"#/_blank\">http://v3.bootcss.com/getting-started/</a>）。所以在UI设计时需要进行沟通，一旦选择了框架，尽量能和框架风格保持一致。当然也可以完全重新定义风格和自己开发。</p>\n<p>同样在图标使用上，一般也会选择成熟的图标库，例如：Font Awesome，Glyphicons。（<a href=\"#/_blank\">http://www.bootcss.com/p/font-awesome/</a>）</p>\n<p>上面提到的兼容性设计问题。如果要支持IE8这类古董浏览器。再设计时很多新特性都无法支持，如果一定要支持，成本会很大。</p>\n</script></li></ul>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1、WEB前端是神马\"><a href=\"#1、WEB前端是神马\" class=\"headerlink\" title=\"1、WEB前端是神马\"></a><strong>1、WEB前端是神马</strong></h2><p>Web前端开发是从网页制作演变而来的，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，那时网站的主要内容都是静态的，用户使用网站的行为也以浏览为主。2005年以后，互联网进入Web2.0时代，各种类似桌面软件的Web应用大量涌现，网站的前端由此发生了翻天覆地的变化。网页不再只是承载单一的文字和图片，各种富媒体让网页的内容更加生动，网页上软件化的交互形式为用户提供了更好的使用体验，这些都是基于前端技术实现的。 以前会Photoshop和Dreamweaver就可以制作网页，现在只掌握这些已经远远不够了。无论是开发难度上，还是开发方式上，现在的网页制作都更接近传统的网站后台开发，所以现在不再叫网页制作，而是叫Web前端开发。Web前端开发在产品开发环节中的作用变得越来越重要，而且需要专业的前端工程师才能做好。Web前端开发是一项很特殊的工作，涵盖的知识面非常广，既有具体的技术，又有抽象的理念。简单地说，它的主要职能就是把网站（Web App网页应用和Hybrid App混合应用）的界面更好地呈现给用户。</p>\n<h2 id=\"2、前端技术\"><a href=\"#2、前端技术\" class=\"headerlink\" title=\"2、前端技术\"></a><strong>2、前端技术</strong></h2><h3 id=\"W3C标准\"><a href=\"#W3C标准\" class=\"headerlink\" title=\"W3C标准\"></a><strong>W3C标准</strong></h3><p>W3C标准不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括HTML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。</p>\n<p>简单来说就是： html（结构） + css（表现） + js（行为）</p>\n<p>学习资源：<a href=\"http://www.w3school.com.cn/\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/</a><br>名词解释：W3C——万维网联盟（World Wide Web Consortium）</p>\n<h3 id=\"HTML——WEB应用的基石\"><a href=\"#HTML——WEB应用的基石\" class=\"headerlink\" title=\"HTML——WEB应用的基石\"></a><strong>HTML——WEB应用的基石</strong></h3><p>HyperText Markup Language 超文本标记语言。超文本是用超链接的方法，将各种不同空间的信息组织在一起的网状文本。信息可以包含图片、链接，甚至音乐、程序等非文字元素。</p>\n<h3 id=\"html文件示例如下：\"><a href=\"#html文件示例如下：\" class=\"headerlink\" title=\"html文件示例如下：\"></a><strong>html文件示例如下：</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-b0e4fe78a10f1245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"标签的基本格式如下：\"><a href=\"#标签的基本格式如下：\" class=\"headerlink\" title=\"标签的基本格式如下：\"></a><strong>标签的基本格式如下：</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-200c7bc7b8a12f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>示例中的标签是个闭合标签，有部分标签不是闭合标签。例如：<input type=\"text\" name=\"test\" value=\"test\"></p>\n<p>一个标准的html文件主要包括如下常用的标签：</p>\n<ul>\n<li>!DOCTYPE:文档类型声明，它的目的是要告诉浏览器，它应该使用什么样的文档类型定义来解析文档。示例中所示的文档类型是html5。文档类型一般是向下兼容的，html5基本兼容html4.01.</li>\n<li>html：文档的根节点。<html> 与 </html> 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。</li>\n<li>head：<head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</head></head></li>\n<li>meta：<meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎的关键词，文件编码类型，浏览器版本等。</li>\n<li>title：文档标题，浏览器的标签页显示的内容。</li>\n<li>link：<link>标签定义文档与外部资源的关系，最常见的用途是链接样式表（css文件），ICON。</li>\n<li>script：<script>标签用于定义客户端脚本，比如 JavaScript。既可以包含脚本语句，也可以通过 src 属性指向外部脚本文件。</li>\n<li>style：<style> 标签用于为 HTML 文档定义样式信息。</li>\n<li>body:body 元素定义文档的主体。</li>\n<li>h1~h6：<h1> 定义最大的标题。<h6> 定义最小的标题。</li>\n<li>div：<div> 可定义文档中的分区或节，可以把文档分割为独立的、不同的部分</li>\n<li>p：<p> 标签定义段落。</li>\n<li>span：<span> 标签被用来组合文档中的行内元素。</li>\n<li>a:<a> 标签定义超链接，用于从一张页面链接到另一张页面，最重要的属性是 href 属性，它指示链接的目标。</li>\n<li>button：<button> 标签定义一个按钮。</li>\n<li>img：img 元素向网页中嵌入一幅图像。</li>\n<li>input：<input> 标签用于搜集用户信息。根据不同的 type 属性值，输入字段拥有很多种形式。输入字段可以是文本字段、复选框、单选按钮、按钮等等。</li>\n</ul>\n<p>其他更多标签，请见：<a href=\"#/_blank\">http://www.w3school.com.cn/tags/tag_doctype.asp</a></p>\n<h3 id=\"文档流\"><a href=\"#文档流\" class=\"headerlink\" title=\"文档流\"></a><strong>文档流</strong></h3><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-cc38e0d5778d1508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>冷知识：W3C规范中没有document flow这个概念，只有normal-flow, 文档流的叫法主要还是多数中文译者的翻译方式问题。据说来源于报纸的排版。</p>\n<p>什么是文档流？简单说就是元素按照其在HTML中决定标签位置顺序排布的过程。并且这种过程遵循标准的描述。html的文档流规则是将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素。</p>\n<h3 id=\"块级标签和内联标签\"><a href=\"#块级标签和内联标签\" class=\"headerlink\" title=\"块级标签和内联标签\"></a><strong>块级标签和内联标签</strong></h3><p>HTML中的标签主要是块级标签或内联标签。块级标签一般是其他标签的容器标签，能容纳其他块标签或内联标签。简单来说，块标签就好比一个四方块，可以放其他的四方块，并可以呈现在页面上任何地方。默认情况下块标签，是独占一行的。常见的块标签：div、h1-h6标题、form（只能用来容纳其他块标签）、hr、p、table、ul、ol等。内联标签也叫内嵌标签或行内标签，一般都是基于语义级(semantic)的基本标签。内联标签只能容纳文本或者其他内联标签，常见内联标签有a和span。 </p>\n<p>块标签与内联标签的区别？ </p>\n<ol>\n<li>块级标签，总是在新行上开始；内联标签，和其他标签都在一行上。</li>\n<li>块级标签，能容纳其他块标签或内联标签；内联标签，只能容纳文本或者其他内联标签。 </li>\n<li>块级标签中高度，行高以及顶和底边距都可控制；内联标签中高，行高及顶和底边距不可改变。</li>\n</ol>\n<p>在实际应用中，可以通过CSS修改标签的display属性转变标签的性质，进行相互转换。建议按照原始性质使用，尽量不进行转换。</p>\n<h3 id=\"如何设计html？\"><a href=\"#如何设计html？\" class=\"headerlink\" title=\"如何设计html？\"></a><strong>如何设计html？</strong></h3><p>如下图，通常先设计好结构图，然后根据结构图再进行标签的书写。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-b5704c57de05413d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"HTML5\"><a href=\"#HTML5\" class=\"headerlink\" title=\"HTML5\"></a><strong>HTML5</strong></h2><p>HTML4.01版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。多媒体的大量应用，各类app不断涌现。不同于HTML4.01完全由W3C制定。HTML5 是 W3C 与 WHATWG 合作的结果。WHATWG 致力于 web 表单和应用程序，而 W3C 专注于 XHTML 2.0。HTML5草案的前身名为 Web Applications 1.0，于2004年被WHATWG提出，于2007年被W3C接纳，并成立了新的 HTML 工作团队。HTML5 的第一份正式草案已于2008年1月22日公布。最终在2014年定稿。</p>\n<p>注：W3C 指 World Wide Web Consortium，万维网联盟。<br>注：WHATWG 指 Web Hypertext Application Technology Working Group，Web超文本应用技术工作组。</p>\n<h3 id=\"HTML5建立的一些规则：\"><a href=\"#HTML5建立的一些规则：\" class=\"headerlink\" title=\"HTML5建立的一些规则：\"></a><strong>HTML5建立的一些规则：</strong></h3><ol>\n<li>新特性应该基于 HTML、CSS、DOM 以及 JavaScript。</li>\n<li>减少对外部插件的需求（比如 Flash）</li>\n<li>更优秀的错误处理</li>\n<li>更多取代脚本的标记</li>\n<li>HTML5应该独立于设备</li>\n</ol>\n<h3 id=\"HTML5中的新特性\"><a href=\"#HTML5中的新特性\" class=\"headerlink\" title=\"HTML5中的新特性\"></a><strong>HTML5中的新特性</strong></h3><ol>\n<li>用于绘画的 canvas 元素</li>\n<li>用于多媒体的 video 和 audio 元素</li>\n<li>对本地离线存储的更好的支持</li>\n<li>新的特殊内容元素，比如 article、footer、header、nav、section</li>\n<li>新的表单控件，比如 calendar、date、time、email、url、search</li>\n</ol>\n<h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a><strong>浏览器支持</strong></h3><p>最新版本的 Chrome、Firefox、Safari 以及 Opera 基本上完全支持 HTML5 特性。IE9开始支持某些 HTML5 特性。详细对比：<br><a href=\"#/_blank\">http://caniuse.com/#comparison</a><br><a href=\"#/_blank\">http://html5test.com/compare/browser/firefoxmobile-35/chrome-39/ie-8.html</a></p>\n<h3 id=\"HTML4-01和HTML5结构区别\"><a href=\"#HTML4-01和HTML5结构区别\" class=\"headerlink\" title=\"HTML4.01和HTML5结构区别\"></a><strong>HTML4.01和HTML5结构区别</strong></h3><p> <img src=\"https://upload-images.jianshu.io/upload_images/4944427-86ac4ec9e255f77a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"HTML5新特性简单示例\"><a href=\"#HTML5新特性简单示例\" class=\"headerlink\" title=\"HTML5新特性简单示例\"></a><strong>HTML5新特性简单示例</strong></h3><h3 id=\"canvas\"><a href=\"#canvas\" class=\"headerlink\" title=\"canvas\"></a><strong>canvas</strong></h3><p>canvas标签使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。<br>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\"> &lt;html&gt;</span><br><span class=\"line\">     &lt;body&gt;</span><br><span class=\"line\">         &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid #c3c3c3;&quot;&gt;</span><br><span class=\"line\">             Your browser does not support the canvas element.</span><br><span class=\"line\">         &lt;/canvas&gt;</span><br><span class=\"line\">         &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">             var c=document.getElementById(&quot;myCanvas&quot;);</span><br><span class=\"line\">             var cxt=c.getContext(&quot;2d&quot;);//指定二维绘图，目前只支持2D绘图，后续可能会支持3D</span><br><span class=\"line\">             cxt.moveTo(10,10);//绘制起点。（0，0）对应左上角，向右和向下递增</span><br><span class=\"line\">             cxt.lineTo(150,50);//画一条直线（10,10）到（150,50）</span><br><span class=\"line\">             cxt.lineTo(10,50);//画一条直线（150,50）到（10,50）</span><br><span class=\"line\">             cxt.strokeStyle=&quot;green&quot;; //指定线条颜色</span><br><span class=\"line\">             cxt.stroke();//显示绘图结果</span><br><span class=\"line\">         &lt;/script&gt;</span><br><span class=\"line\">     &lt;/body&gt;</span><br><span class=\"line\"> &lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"vedio-audio\"><a href=\"#vedio-audio\" class=\"headerlink\" title=\"vedio/audio\"></a><strong>vedio/audio</strong></h3><p>在HTML5以前，如果您想在网页中嵌入在线观看的视频，一般都需要使用Flash视频流，通过使用 <object> 和 <embed> 标签，就可以通过浏览器播放swf、flv等格式视频文件，但是前提是浏览器必须安装第三方插件：Adobe Flash Player。而现代智能手机和iPad等一般都不支持Flash，所以无法浏览网页上的视频。而 HTML 5 改变了这一事实，Web开发者只需要使用 <video> 标签就可以轻松加载视频文件，而不需要任何第三方插件。</p>\n<p>vedio支持的视频格式有三种：</p>\n<ol>\n<li>Ogg  带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件</li>\n<li>MPEG4（MP4）带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件</li>\n<li>WebM  带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件</li>\n</ol>\n<p>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;video id=&quot;coures-video&quot; class=&quot;vjs-tech&quot; preload=&quot;none&quot; </span><br><span class=\"line\">     poster=&quot;http://demo.com/upload/course/20160104/1451886552971.jpg&quot;</span><br><span class=\"line\">     controls=&quot;controls&quot; loop=&quot;loop&quot; width=&quot;640px&quot; height=&quot;480px;&quot;&gt; </span><br><span class=\"line\">      &lt;source src=&quot;http://demo.com/upload/course/20160104/1451886551972.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class=\"line\"> &lt;/video&gt;</span><br></pre></td></tr></table></figure></p>\n<p>audio与vedio基本相同,不再赘述。</p>\n<h3 id=\"Drag-和-Drop\"><a href=\"#Drag-和-Drop\" class=\"headerlink\" title=\"Drag 和 Drop\"></a><strong>Drag 和 Drop</strong></h3><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。只需要简单的几个属性和响应函数即可实现拖放。</p>\n<p>代码示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;</span><br><span class=\"line\">     &lt;img src=&quot;http://demo.com/images/11.jpg&quot; draggable=&quot;true&quot;     ondragstart=&quot;drag(event)&quot; id=&quot;drag1&quot; /&gt;</span><br><span class=\"line\"> &lt;/div&gt;</span><br><span class=\"line\"> &lt;div id=&quot;div2&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">```</span><br></pre></td></tr></table></figure></p>\n<p> //ondragover 事件规定在何处放置被拖动的数据。<br> function allowDrop(ev){<br>     ev.preventDefault();<br> }<br> //移动响应事件，获取正在移动的标签ID<br> function drag(ev){<br>     ev.dataTransfer.setData(“Text”,ev.target.id);<br> }<br> //进行放置 响应事件<br> function drop(ev) {<br>     ev.preventDefault();<br>     var data=ev.dataTransfer.getData(“Text”);<br>     ev.target.appendChild(document.getElementById(data));<br> }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **INPUT新类型**</span><br><span class=\"line\">HTML5 拥有多个新的表单输入类型，这些新特性提供了更好的输入控制和验证。email，url，number，range，Date pickers (date, month, week, time, datetime, datetime-local)，search，color 。</span><br><span class=\"line\">- email 类型用于应该包含 e-mail 地址的输入域，在提交表单时，会自动验证 email 域的值：</span><br><span class=\"line\">    &lt;input type=&quot;email&quot; name=&quot;user_email&quot; /&gt;</span><br><span class=\"line\">- number 类型用于应该包含数值的输入域，还能够设定对所接受的数字的限定：</span><br><span class=\"line\">   &lt;input type=&quot;number&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot; /&gt;</span><br><span class=\"line\">- Date Pickers（日期选择器）拥有多个可供选取日期和时间的新输入类型：</span><br><span class=\"line\">date - 选取日、月、年</span><br><span class=\"line\">month - 选取月、年</span><br><span class=\"line\">week - 选取周和年</span><br><span class=\"line\">time - 选取时间（小时和分钟）</span><br><span class=\"line\">datetime - 选取时间、日、月、年（UTC 时间）</span><br><span class=\"line\">datetime-local - 选取时间、日、月、年（本地时间）</span><br><span class=\"line\"> &lt;input type=&quot;date&quot; name=&quot;user_date&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">### **本地存储**</span><br><span class=\"line\">说到本地存储，真是历尽千辛万苦才走到HTML5这一步，之前的历史大概如下图所示：</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-e930aa1ef64979c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">最早的Cookies大小约4KB，而且IE6只支持每个域名20个cookies。优势就是大家都支持，而且支持得还比较好。后来IE又推出了userData，现在用的比较多的是Flash，空间是Cookie的25倍，基本够用。再之后Google推出了Gears，虽然没有限制，但是要装额外的插件。到了HTML5把这些都统一了，官方建议是每个网站5MB。所有支持的浏览器目前都采用的5MB，尽管有一些浏览器可以让用户设置，但对于网页制作者来说，目前的形势就5MB来考虑是比较适合的。</span><br><span class=\"line\"></span><br><span class=\"line\">对于重复的数据，HTML5可以直接从本地存储中读取数据，不必每次都向服务器发起请求从服务器获取。从而大幅提高网站性能和支持离线运行。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">HTML5 提供了两种在客户端存储数据的方法：</span><br><span class=\"line\">1. localStorage - 没有时间限制的数据存储</span><br><span class=\"line\">2. sessionStorage - 针对一个 session 的数据存储</span><br><span class=\"line\"></span><br><span class=\"line\">HTML5 使用 JavaScript 来存储和访问数据。使用方法如下：</span><br></pre></td></tr></table></figure></p>\n<p>if (localStorage.pagecount){<br>    localStorage.pagecount=Number(localStorage.pagecount) +1;<br> } else {<br>     localStorage.pagecount=1;<br> }<br> document.write(“Visits: “ + localStorage.pagecount + “ time(s).”);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## **CSS**</span><br><span class=\"line\">层叠样式表 (Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言。CSS目前最新版本为CSS3，是能够真正做到网页表现与内容分离的一种样式设计语言。相对于传统HTML的表现而言，CSS能够对网页中的对象的位置排版进行像素级的精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力，并能够进行初步交互设计，有较强的易读性，被称为程序员的画笔。</span><br><span class=\"line\">### **如何使用样式表？**</span><br><span class=\"line\"></span><br><span class=\"line\">有三种方法可以在网页上使用样式表：</span><br><span class=\"line\"></span><br><span class=\"line\">1.  外联式Linking（也叫外部样式）</span><br><span class=\"line\">当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</span><br></pre></td></tr></table></figure></p>\n<p><head></p>\n<p><link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"><br></head><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2. 嵌入式Embedding（也叫内页样式）</span><br><span class=\"line\">当单个文件需要特别样式时，就可以使用内部样式表。你可以在 head 部分通过 &lt;style&gt; 标签定义内部样式表。</span><br></pre></td></tr></table></figure></p>\n<p><head><br>  <style type=\"text/css\"><br>    body {background-color: red}<br>    p {margin-left: 20px}<br>  </style><br></head><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3. 内联式Inline（也叫行内样式）</span><br><span class=\"line\">当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</span><br></pre></td></tr></table></figure></p>\n<p><p style=\"color: red; margin-left: 20px\"><br>This is a paragraph<br></p><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **如何定义样式表**</span><br><span class=\"line\"></span><br><span class=\"line\">CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。如下图所示</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-df91f0bb24f4066a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### **选择器类型：**</span><br><span class=\"line\">1. 标签选择器 p  &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">2. 类选择器 .my-class  &lt;p class=&quot;my-class&quot;&gt;&lt;/p&gt;</span><br><span class=\"line\">3. ID选择器 #myDiv  &lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">4. 属性选择器 [type=&quot;radio&quot;] &lt;input type=&quot;radio&quot; /&gt;</span><br><span class=\"line\">5. 伪类/伪元素选择器 a:hover</span><br><span class=\"line\">6. 以及上述各种选择器的组合。</span><br><span class=\"line\"></span><br><span class=\"line\">更多介绍，详见：[http://www.w3school.com.cn/cssref/css_selectors.asp](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **盒模型**</span><br><span class=\"line\">网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)。这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。盒模型的模型如下图</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-57b0c88cb9d4c137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-1ba2ba1a7fb9259f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">### **display属性**</span><br><span class=\"line\">display 属性规定了元素应该生成的框的类型。在上面html章节中我们提到了块级标签和内联标签，这只是默认属性，通过CSS中的display进行修改。还可以通过display控制标签是否显示。</span><br><span class=\"line\">display常见的属性值如下：</span><br><span class=\"line\">| 值 | 描述|</span><br><span class=\"line\">|--|--|</span><br><span class=\"line\">|none|此元素不会被显示。 |</span><br><span class=\"line\">|block|此元素将显示为块级元素，此元素前后会带有换行符。|</span><br><span class=\"line\">|inline|默认。此元素会被显示为内联元素，元素前后没有换行符。 |</span><br><span class=\"line\">|inline-block|行内块元素。（CSS2.1 新增的值）|</span><br><span class=\"line\">|table|此元素会作为块级表格来显示（类似 &lt;table&gt;），表格前后带有换行符。|</span><br><span class=\"line\"></span><br><span class=\"line\">### **position属性**</span><br><span class=\"line\"></span><br><span class=\"line\">position 属性规定元素的定位类型。这个属性定义建立元素布局所用的定位机制。任何元素都可以定位，不过绝对或固定元素会生成一个块级框，而不论该元素本身是什么类型。相对定位元素会相对于它在文档流中的默认位置偏移。</span><br><span class=\"line\">| 值 | 描述 |</span><br><span class=\"line\">|--|--|</span><br><span class=\"line\">| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。|</span><br><span class=\"line\">| fixed | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。 |</span><br><span class=\"line\">|relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。 |</span><br><span class=\"line\">| static | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |</span><br><span class=\"line\">| inherit | 规定应该从父元素继承 position 属性的值。 |</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-41ae02b45dade8ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-40d3d157ccdd74d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">参考资料：[http://blog.jobbole.com/49320/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **float属性**</span><br><span class=\"line\">float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。假如在一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行，这个过程会持续到某一行拥有足够的空间为止。</span><br><span class=\"line\">|值|描述| </span><br><span class=\"line\">|--|--| </span><br><span class=\"line\">|left|元素向左浮动。|</span><br><span class=\"line\">|right|元素向右浮动。 |</span><br><span class=\"line\">| none| 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |</span><br><span class=\"line\">| inherit | 规定应该从父元素继承 float 属性的值。|</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\"></span><br><span class=\"line\">- 正常文档流</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-aa0d8c1aa75d3d99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">- 设置float，浏览器的宽度“不够长”时 ![图片18.png](https://upload-images.jianshu.io/upload_images/4944427-423465a304018193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">- 设置float，浏览器的宽度“足够长”时</span><br><span class=\"line\">![图片19.png](https://upload-images.jianshu.io/upload_images/4944427-7a9ebd1861bad959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">参考资料：[http://www.cnblogs.com/polk6/archive/2013/07/25/3142187.html](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **浮动子标签撑开父标签**</span><br><span class=\"line\"></span><br><span class=\"line\">子标签如果都设置为float，会导致父标签没有高度值。导致结构错乱。</span><br><span class=\"line\"></span><br><span class=\"line\">如下两种方法可以解决：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 添加一个空的div，设置clear属性为both</span><br><span class=\"line\">![](https://upload-images.jianshu.io/upload_images/4944427-bc7177b5998354f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\">2. 父标签增加伪类，设置clear属性为both</span><br><span class=\"line\">![图片21.png](https://upload-images.jianshu.io/upload_images/4944427-c2171dea0bb5eeec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class=\"line\"></span><br><span class=\"line\">### **其他常用属性**</span><br></pre></td></tr></table></figure></p>\n<p> background-color: gray;  /<em>背景颜色</em>/<br>border: 2px solid #e4e4e4; /<em>边框尺寸、类型、颜色</em>/<br> font-family: 宋体;  /<em>字体</em>/<br>color: #234567; /<em>文字颜色</em>/<br>font-size: 13px;  /<em>文字大小</em>/<br>width: 70px;  /<em>宽度</em>/<br>height: 70px;  /<em>高度</em>/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **CSS优先级**</span><br><span class=\"line\">由于CSS选择器可以有多种形式，可以继承，可以重复定义。所以具体哪个样式生效需要计算优先级。注意：优先级相同时，晚定义的样式有效。</span><br><span class=\"line\">通常情况下，给每个选择器设置一个数值，数值越大，优先级越高。实际没有这个数值，只是一种近似。</span><br><span class=\"line\">html标签 （1）</span><br><span class=\"line\">class  （10）</span><br><span class=\"line\">id  （100）</span><br><span class=\"line\">计算示例：</span><br><span class=\"line\">div p     1+1 = 2</span><br><span class=\"line\">span.test 1+10 = 11</span><br><span class=\"line\">#id.test     100 + 10 = 110</span><br><span class=\"line\">不同引入方式引入的CSS，优先级也不同。排序规则如下：!important &gt; inline &gt;id &gt; class &gt; tag</span><br><span class=\"line\"></span><br><span class=\"line\">### **CSS3**</span><br><span class=\"line\">CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。</span><br><span class=\"line\"></span><br><span class=\"line\">参考：[http://www.w3school.com.cn/css3/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">## **javascript**</span><br><span class=\"line\"></span><br><span class=\"line\">**java ≠ javascript  就像 马 ≠ 海马**</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。JavaScript是甲骨文公司的注册商标，最初由Netscape的Brendan Eich设计。Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript脚本语言具有以下特点:</span><br><span class=\"line\">1. 脚本语言。JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中逐行进行解释。</span><br><span class=\"line\">2. 基于对象。JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。</span><br><span class=\"line\">3. 简单。JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。</span><br><span class=\"line\">4. 动态性。JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。在访问一个网页时,鼠标在网页中进行鼠标点击或上下移、窗口移动等操作JavaScript都可直接对这些事件给出相应的响应。</span><br><span class=\"line\">5. 跨平台性。JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持。因此一个JavaScript脚本在编写后可以带到任意机器上使用，部署成本小。</span><br><span class=\"line\"></span><br><span class=\"line\">不同于服务器端脚本语言，例如PHP与ASP，JavaScript主要被作为客户端脚本语言在用户的浏览器上运行，不需要服务器的支持。所以在早期程序员比较青睐于JavaScript以减少对服务器的负担，而与此同时也带来另一个问题：安全性。</span><br><span class=\"line\"></span><br><span class=\"line\">而随着服务器的强壮，虽然程序员更喜欢运行于服务端的脚本以保证安全，但JavaScript仍然以其跨平台、容易上手等优势大行其道。同时，有些特殊功能（如AJAX）必须依赖Javascript在客户端进行支持。随着引擎如V8和框架如Node.js的发展，及其事件驱动及异步IO等特性，JavaScript逐渐被用来编写服务器端程序。</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript被Netscape公司提交给ECMA(European Computer Manufacturers Association)制定为标准，称之为ECMAScript，标准编号ECMA-262。目前最新版为2015年发布的ECMAScript 6。</span><br><span class=\"line\"></span><br><span class=\"line\">下面对javascript的常用操作进行举例：</span><br><span class=\"line\"></span><br><span class=\"line\">### **写入 HTML 输出**</span><br></pre></td></tr></table></figure></p>\n<p>document.write(“<h1>This is a heading</h1>“);<br>document.write(“<p>This is a paragraph</p>“);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **对事件作出反应**</span><br></pre></td></tr></table></figure></p>\n<p><button type=\"button\" onclick=\"alert('Welcome!')\">点击这里</button><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</span><br><span class=\"line\">onclick 鼠标点击事件。</span><br><span class=\"line\"></span><br><span class=\"line\">### **改变 HTML 内容**</span><br></pre></td></tr></table></figure></p>\n<p>x=document.getElementById(“demo”)  //查找元素<br>x.innerHTML=”Hello JavaScript”;    //改变内容<br>var img=document.getElementById(“myImg”)  //查找元素<br>img.src=”/i/eg_bulbon.gif”;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">您会经常看到 document.getElementByID(&quot;some id&quot;)。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。</span><br><span class=\"line\"></span><br><span class=\"line\">### **改变 HTML 样式**</span><br></pre></td></tr></table></figure></p>\n<p>x=document.getElementById(“demo”)  //找到元素<br>x.style.color=”#ff0000”;           //改变样式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### **验证输入**</span><br></pre></td></tr></table></figure></p>\n<p>if isNaN(x) {alert(“Not Numeric”)};<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细的语言特性，参考：[http://www.w3school.com.cn/js/index.asp](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">### **jQuery**</span><br><span class=\"line\"></span><br><span class=\"line\">JQuery一个优秀的轻量级的Javascript库。它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理HTML、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。目前，绝大多数网站都在使用jQuery。</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br></pre></td></tr></table></figure></p>\n<p>$(“#h01”).attr(“style”,”color:red”).html(“Hello jQuery”)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细的语言特性，参考：[http://www.w3school.com.cn/jquery/](#/_blank)</span><br><span class=\"line\"></span><br><span class=\"line\">## **浏览器兼容**</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器兼容性问题又被称为网页兼容性或网站兼容性问题，指网页在各种浏览器上的显示效果可能不一致而产生浏览器和网页间的兼容问题。在网站的设计和制作中，做好浏览器兼容，才能够让网站在不同的浏览器下都正常显示。因为不同浏览器使用内核及所支持的HTML，JS，CSS标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。最常见的问题就是网页元素位置混乱，错位，动态效果失效等等。</span><br><span class=\"line\"></span><br><span class=\"line\">举例：</span><br><span class=\"line\">1. IE的盒模型与W3C标准不符。</span><br><span class=\"line\">2. IE8不支持html5的vedio，只能使用flash播放视频。</span><br><span class=\"line\">3. IE8不支持图片圆角</span><br><span class=\"line\">4. DOM 个别操作不一致</span><br></pre></td></tr></table></figure></p>\n<p>var obj = document.getElementById(‘objId’);<br>obj.setAttribute(‘onclick’,’funcitonname();’); //FIREFOX支持，IE不支持<br>obj.onclick=function(){fucntionname();}; //都支持<br>```</p>\n<h2 id=\"前端调试工具\"><a href=\"#前端调试工具\" class=\"headerlink\" title=\"前端调试工具\"></a><strong>前端调试工具</strong></h2><p>推荐使用Chrome devtools。</p>\n<h2 id=\"关于UX和前端\"><a href=\"#关于UX和前端\" class=\"headerlink\" title=\"关于UX和前端\"></a><strong>关于UX和前端</strong></h2><p>在前端开发过程中一般会引入比较成熟的前端框架，例如：Bootstarp（<a href=\"#/_blank\">http://v3.bootcss.com/getting-started/</a>）。所以在UI设计时需要进行沟通，一旦选择了框架，尽量能和框架风格保持一致。当然也可以完全重新定义风格和自己开发。</p>\n<p>同样在图标使用上，一般也会选择成熟的图标库，例如：Font Awesome，Glyphicons。（<a href=\"#/_blank\">http://www.bootcss.com/p/font-awesome/</a>）</p>\n<p>上面提到的兼容性设计问题。如果要支持IE8这类古董浏览器。再设计时很多新特性都无法支持，如果一定要支持，成本会很大。</p>\n</script></li></ul>"},{"title":"spring boot开发经验汇总","date":"2016-07-09T06:24:08.000Z","_content":"本文记录了Spring boot开发过程中遇到的一些坑，整理一下，希望能够帮助大家\n# spring boot工程在Eclipse中发布\n导出jar包方式（以demo工程为例）\n1. 工程右键，选择export-》java-》Runnbale JAR file![](https://upload-images.jianshu.io/upload_images/4944427-43adf772b1f7a9b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 选择launch configuration,设置输出目标文件，勾选依赖库导入到单独目录（demo_lib）\n3. 将工程属性文件，例如application.properties拷贝到jar文件所在目录。\n完成的发布包应该包括：demo.jar，demo_lib，application.properties等文件\n执行 java -jar demo.jar即可启动整个项目\n\n# 已有数据表如何导入入到项目的Entity\n使用jpa工具导入\n在 eclipse matketpalce里搜索jpa，选择 JPA Diagram Editor进行安装\n在工程的属性里，选择 project facets 再选中JPA\n工程右键，选择JPA Tools->Generate Entities from Tables。然后配置数据库连接字，选择数据表，生成entity\n\n# 上传文件大小最大值设置\nSpring boot默认最大上传文件是10Mb，如果要改变这个阈值需要自己设置。不同Spring boot版本存在差别。举例如下：\n```\n//例如在application.properties\n//Spring Boot 1.3.x或者之前\nmultipart.maxFileSize=500Mb\nmultipart.maxRequestSize=1000Mb\n//Spring Boot 1.4.x或者之后\nspring.http.multipart.maxFileSize=500Mb\nspring.http.multipart.maxRequestSize=1000Mb\n//Spring Boot 2.0.x或者之后\nspring.servlet.multipart.maxFileSize=500Mb\nspring.servlet.multipart.maxRequestSize=1000Mb\n```\n注意：如果有使用zuul路由服务，还需要设置zuul的相关参数。\n\n# EntityNotFoundException\n使用ManyToOne进行表关联且懒加载时，如果被关联的记录不存在时，序列化时报如下异常：\n```\n//关联定义如下\n@JoinColumn(name=\"topic_id\")\n@JsonView(JsonViews.Public.class)\n@ManyToOne(fetch=FetchType.LAZY)\npublic Topic getTopic() {\n    return topic;\n}\n```\n异常信息如下：\nCould not write content: Unable to find com.demo.entity.topic.Topic with id 14363\n//跟踪代码，能发现\njavax.persistence.EntityNotFoundException: Unable to find xxx\n如果关联记录不存在，还需要返回结果，增加@NotFound(action= NotFoundAction.IGNORE)，解决方案：\n```\n@JoinColumn(name=\"topic_id\")\n@ManyToOne(fetch=FetchType.LAZY)\n@NotFound(action= NotFoundAction.IGNORE)\npublic Topic getTopic() {\n    return topic;\n}\n```\n# 无法下载maven依赖库\n现象\n下载依赖库失败。 Failure to transfer org.apache.maven.plugins:maven-compiler-plugin:pom:2.0.2 from http://repo1.maven.org/maven2 was cached in the local repository\n\n解决办法\n在下面两个文件中的mirrors 组中增加自己公司里的私有仓库\nThe Maven install: $M2_HOME/conf/settings.xml\nA user’s install: ${user.home}/.m2/settings.xml\n```\n<mirrors>\n<mirror>\n <id>nexus-demo</id>\n <mirrorOf>*</mirrorOf>\n <name>Nexus demo</name>\n <url>http://maven.demo.com.cn/content/groups/public</url>\n</mirror>\n</mirrors>\n```\n然后重新update，注意勾上强制更新。\nSTS里如果更新失败，可以尝试直接命令行 mvn clean & mvn install\n\n# 其他异常\n## Not an managed type: class com.demo.entity.Approve\nclass Approve定义没有添加注解@Entity\n\n## No qualifying bean of type [com.demo.service.ApplyService] found for dependency\n没有在config/JPAConfig.java里正确配置package信息。或者是没有给加上@Service注解。","source":"_posts/java/spring boot开发经验汇总.md","raw":"---\ntitle: spring boot开发经验汇总\ndate: 2016-07-09 14:24:08\ntags: [spring,java]\n---\n本文记录了Spring boot开发过程中遇到的一些坑，整理一下，希望能够帮助大家\n# spring boot工程在Eclipse中发布\n导出jar包方式（以demo工程为例）\n1. 工程右键，选择export-》java-》Runnbale JAR file![](https://upload-images.jianshu.io/upload_images/4944427-43adf772b1f7a9b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n2. 选择launch configuration,设置输出目标文件，勾选依赖库导入到单独目录（demo_lib）\n3. 将工程属性文件，例如application.properties拷贝到jar文件所在目录。\n完成的发布包应该包括：demo.jar，demo_lib，application.properties等文件\n执行 java -jar demo.jar即可启动整个项目\n\n# 已有数据表如何导入入到项目的Entity\n使用jpa工具导入\n在 eclipse matketpalce里搜索jpa，选择 JPA Diagram Editor进行安装\n在工程的属性里，选择 project facets 再选中JPA\n工程右键，选择JPA Tools->Generate Entities from Tables。然后配置数据库连接字，选择数据表，生成entity\n\n# 上传文件大小最大值设置\nSpring boot默认最大上传文件是10Mb，如果要改变这个阈值需要自己设置。不同Spring boot版本存在差别。举例如下：\n```\n//例如在application.properties\n//Spring Boot 1.3.x或者之前\nmultipart.maxFileSize=500Mb\nmultipart.maxRequestSize=1000Mb\n//Spring Boot 1.4.x或者之后\nspring.http.multipart.maxFileSize=500Mb\nspring.http.multipart.maxRequestSize=1000Mb\n//Spring Boot 2.0.x或者之后\nspring.servlet.multipart.maxFileSize=500Mb\nspring.servlet.multipart.maxRequestSize=1000Mb\n```\n注意：如果有使用zuul路由服务，还需要设置zuul的相关参数。\n\n# EntityNotFoundException\n使用ManyToOne进行表关联且懒加载时，如果被关联的记录不存在时，序列化时报如下异常：\n```\n//关联定义如下\n@JoinColumn(name=\"topic_id\")\n@JsonView(JsonViews.Public.class)\n@ManyToOne(fetch=FetchType.LAZY)\npublic Topic getTopic() {\n    return topic;\n}\n```\n异常信息如下：\nCould not write content: Unable to find com.demo.entity.topic.Topic with id 14363\n//跟踪代码，能发现\njavax.persistence.EntityNotFoundException: Unable to find xxx\n如果关联记录不存在，还需要返回结果，增加@NotFound(action= NotFoundAction.IGNORE)，解决方案：\n```\n@JoinColumn(name=\"topic_id\")\n@ManyToOne(fetch=FetchType.LAZY)\n@NotFound(action= NotFoundAction.IGNORE)\npublic Topic getTopic() {\n    return topic;\n}\n```\n# 无法下载maven依赖库\n现象\n下载依赖库失败。 Failure to transfer org.apache.maven.plugins:maven-compiler-plugin:pom:2.0.2 from http://repo1.maven.org/maven2 was cached in the local repository\n\n解决办法\n在下面两个文件中的mirrors 组中增加自己公司里的私有仓库\nThe Maven install: $M2_HOME/conf/settings.xml\nA user’s install: ${user.home}/.m2/settings.xml\n```\n<mirrors>\n<mirror>\n <id>nexus-demo</id>\n <mirrorOf>*</mirrorOf>\n <name>Nexus demo</name>\n <url>http://maven.demo.com.cn/content/groups/public</url>\n</mirror>\n</mirrors>\n```\n然后重新update，注意勾上强制更新。\nSTS里如果更新失败，可以尝试直接命令行 mvn clean & mvn install\n\n# 其他异常\n## Not an managed type: class com.demo.entity.Approve\nclass Approve定义没有添加注解@Entity\n\n## No qualifying bean of type [com.demo.service.ApplyService] found for dependency\n没有在config/JPAConfig.java里正确配置package信息。或者是没有给加上@Service注解。","slug":"java/spring boot开发经验汇总","published":1,"updated":"2018-03-11T07:19:34.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvy50003tccmu9l1somi","content":"<p>本文记录了Spring boot开发过程中遇到的一些坑，整理一下，希望能够帮助大家</p>\n<h1 id=\"spring-boot工程在Eclipse中发布\"><a href=\"#spring-boot工程在Eclipse中发布\" class=\"headerlink\" title=\"spring boot工程在Eclipse中发布\"></a>spring boot工程在Eclipse中发布</h1><p>导出jar包方式（以demo工程为例）</p>\n<ol>\n<li>工程右键，选择export-》java-》Runnbale JAR file<img src=\"https://upload-images.jianshu.io/upload_images/4944427-43adf772b1f7a9b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>选择launch configuration,设置输出目标文件，勾选依赖库导入到单独目录（demo_lib）</li>\n<li>将工程属性文件，例如application.properties拷贝到jar文件所在目录。<br>完成的发布包应该包括：demo.jar，demo_lib，application.properties等文件<br>执行 java -jar demo.jar即可启动整个项目</li>\n</ol>\n<h1 id=\"已有数据表如何导入入到项目的Entity\"><a href=\"#已有数据表如何导入入到项目的Entity\" class=\"headerlink\" title=\"已有数据表如何导入入到项目的Entity\"></a>已有数据表如何导入入到项目的Entity</h1><p>使用jpa工具导入<br>在 eclipse matketpalce里搜索jpa，选择 JPA Diagram Editor进行安装<br>在工程的属性里，选择 project facets 再选中JPA<br>工程右键，选择JPA Tools-&gt;Generate Entities from Tables。然后配置数据库连接字，选择数据表，生成entity</p>\n<h1 id=\"上传文件大小最大值设置\"><a href=\"#上传文件大小最大值设置\" class=\"headerlink\" title=\"上传文件大小最大值设置\"></a>上传文件大小最大值设置</h1><p>Spring boot默认最大上传文件是10Mb，如果要改变这个阈值需要自己设置。不同Spring boot版本存在差别。举例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例如在application.properties</span><br><span class=\"line\">//Spring Boot 1.3.x或者之前</span><br><span class=\"line\">multipart.maxFileSize=500Mb</span><br><span class=\"line\">multipart.maxRequestSize=1000Mb</span><br><span class=\"line\">//Spring Boot 1.4.x或者之后</span><br><span class=\"line\">spring.http.multipart.maxFileSize=500Mb</span><br><span class=\"line\">spring.http.multipart.maxRequestSize=1000Mb</span><br><span class=\"line\">//Spring Boot 2.0.x或者之后</span><br><span class=\"line\">spring.servlet.multipart.maxFileSize=500Mb</span><br><span class=\"line\">spring.servlet.multipart.maxRequestSize=1000Mb</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果有使用zuul路由服务，还需要设置zuul的相关参数。</p>\n<h1 id=\"EntityNotFoundException\"><a href=\"#EntityNotFoundException\" class=\"headerlink\" title=\"EntityNotFoundException\"></a>EntityNotFoundException</h1><p>使用ManyToOne进行表关联且懒加载时，如果被关联的记录不存在时，序列化时报如下异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//关联定义如下</span><br><span class=\"line\">@JoinColumn(name=&quot;topic_id&quot;)</span><br><span class=\"line\">@JsonView(JsonViews.Public.class)</span><br><span class=\"line\">@ManyToOne(fetch=FetchType.LAZY)</span><br><span class=\"line\">public Topic getTopic() &#123;</span><br><span class=\"line\">    return topic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异常信息如下：<br>Could not write content: Unable to find com.demo.entity.topic.Topic with id 14363<br>//跟踪代码，能发现<br>javax.persistence.EntityNotFoundException: Unable to find xxx<br>如果关联记录不存在，还需要返回结果，增加@NotFound(action= NotFoundAction.IGNORE)，解决方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@JoinColumn(name=&quot;topic_id&quot;)</span><br><span class=\"line\">@ManyToOne(fetch=FetchType.LAZY)</span><br><span class=\"line\">@NotFound(action= NotFoundAction.IGNORE)</span><br><span class=\"line\">public Topic getTopic() &#123;</span><br><span class=\"line\">    return topic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"无法下载maven依赖库\"><a href=\"#无法下载maven依赖库\" class=\"headerlink\" title=\"无法下载maven依赖库\"></a>无法下载maven依赖库</h1><p>现象<br>下载依赖库失败。 Failure to transfer org.apache.maven.plugins:maven-compiler-plugin:pom:2.0.2 from <a href=\"http://repo1.maven.org/maven2\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2</a> was cached in the local repository</p>\n<p>解决办法<br>在下面两个文件中的mirrors 组中增加自己公司里的私有仓库<br>The Maven install: $M2_HOME/conf/settings.xml<br>A user’s install: ${user.home}/.m2/settings.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mirrors&gt;</span><br><span class=\"line\">&lt;mirror&gt;</span><br><span class=\"line\"> &lt;id&gt;nexus-demo&lt;/id&gt;</span><br><span class=\"line\"> &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class=\"line\"> &lt;name&gt;Nexus demo&lt;/name&gt;</span><br><span class=\"line\"> &lt;url&gt;http://maven.demo.com.cn/content/groups/public&lt;/url&gt;</span><br><span class=\"line\">&lt;/mirror&gt;</span><br><span class=\"line\">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后重新update，注意勾上强制更新。<br>STS里如果更新失败，可以尝试直接命令行 mvn clean &amp; mvn install</p>\n<h1 id=\"其他异常\"><a href=\"#其他异常\" class=\"headerlink\" title=\"其他异常\"></a>其他异常</h1><h2 id=\"Not-an-managed-type-class-com-demo-entity-Approve\"><a href=\"#Not-an-managed-type-class-com-demo-entity-Approve\" class=\"headerlink\" title=\"Not an managed type: class com.demo.entity.Approve\"></a>Not an managed type: class com.demo.entity.Approve</h2><p>class Approve定义没有添加注解@Entity</p>\n<h2 id=\"No-qualifying-bean-of-type-com-demo-service-ApplyService-found-for-dependency\"><a href=\"#No-qualifying-bean-of-type-com-demo-service-ApplyService-found-for-dependency\" class=\"headerlink\" title=\"No qualifying bean of type [com.demo.service.ApplyService] found for dependency\"></a>No qualifying bean of type [com.demo.service.ApplyService] found for dependency</h2><p>没有在config/JPAConfig.java里正确配置package信息。或者是没有给加上@Service注解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录了Spring boot开发过程中遇到的一些坑，整理一下，希望能够帮助大家</p>\n<h1 id=\"spring-boot工程在Eclipse中发布\"><a href=\"#spring-boot工程在Eclipse中发布\" class=\"headerlink\" title=\"spring boot工程在Eclipse中发布\"></a>spring boot工程在Eclipse中发布</h1><p>导出jar包方式（以demo工程为例）</p>\n<ol>\n<li>工程右键，选择export-》java-》Runnbale JAR file<img src=\"https://upload-images.jianshu.io/upload_images/4944427-43adf772b1f7a9b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>选择launch configuration,设置输出目标文件，勾选依赖库导入到单独目录（demo_lib）</li>\n<li>将工程属性文件，例如application.properties拷贝到jar文件所在目录。<br>完成的发布包应该包括：demo.jar，demo_lib，application.properties等文件<br>执行 java -jar demo.jar即可启动整个项目</li>\n</ol>\n<h1 id=\"已有数据表如何导入入到项目的Entity\"><a href=\"#已有数据表如何导入入到项目的Entity\" class=\"headerlink\" title=\"已有数据表如何导入入到项目的Entity\"></a>已有数据表如何导入入到项目的Entity</h1><p>使用jpa工具导入<br>在 eclipse matketpalce里搜索jpa，选择 JPA Diagram Editor进行安装<br>在工程的属性里，选择 project facets 再选中JPA<br>工程右键，选择JPA Tools-&gt;Generate Entities from Tables。然后配置数据库连接字，选择数据表，生成entity</p>\n<h1 id=\"上传文件大小最大值设置\"><a href=\"#上传文件大小最大值设置\" class=\"headerlink\" title=\"上传文件大小最大值设置\"></a>上传文件大小最大值设置</h1><p>Spring boot默认最大上传文件是10Mb，如果要改变这个阈值需要自己设置。不同Spring boot版本存在差别。举例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例如在application.properties</span><br><span class=\"line\">//Spring Boot 1.3.x或者之前</span><br><span class=\"line\">multipart.maxFileSize=500Mb</span><br><span class=\"line\">multipart.maxRequestSize=1000Mb</span><br><span class=\"line\">//Spring Boot 1.4.x或者之后</span><br><span class=\"line\">spring.http.multipart.maxFileSize=500Mb</span><br><span class=\"line\">spring.http.multipart.maxRequestSize=1000Mb</span><br><span class=\"line\">//Spring Boot 2.0.x或者之后</span><br><span class=\"line\">spring.servlet.multipart.maxFileSize=500Mb</span><br><span class=\"line\">spring.servlet.multipart.maxRequestSize=1000Mb</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果有使用zuul路由服务，还需要设置zuul的相关参数。</p>\n<h1 id=\"EntityNotFoundException\"><a href=\"#EntityNotFoundException\" class=\"headerlink\" title=\"EntityNotFoundException\"></a>EntityNotFoundException</h1><p>使用ManyToOne进行表关联且懒加载时，如果被关联的记录不存在时，序列化时报如下异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//关联定义如下</span><br><span class=\"line\">@JoinColumn(name=&quot;topic_id&quot;)</span><br><span class=\"line\">@JsonView(JsonViews.Public.class)</span><br><span class=\"line\">@ManyToOne(fetch=FetchType.LAZY)</span><br><span class=\"line\">public Topic getTopic() &#123;</span><br><span class=\"line\">    return topic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>异常信息如下：<br>Could not write content: Unable to find com.demo.entity.topic.Topic with id 14363<br>//跟踪代码，能发现<br>javax.persistence.EntityNotFoundException: Unable to find xxx<br>如果关联记录不存在，还需要返回结果，增加@NotFound(action= NotFoundAction.IGNORE)，解决方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@JoinColumn(name=&quot;topic_id&quot;)</span><br><span class=\"line\">@ManyToOne(fetch=FetchType.LAZY)</span><br><span class=\"line\">@NotFound(action= NotFoundAction.IGNORE)</span><br><span class=\"line\">public Topic getTopic() &#123;</span><br><span class=\"line\">    return topic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"无法下载maven依赖库\"><a href=\"#无法下载maven依赖库\" class=\"headerlink\" title=\"无法下载maven依赖库\"></a>无法下载maven依赖库</h1><p>现象<br>下载依赖库失败。 Failure to transfer org.apache.maven.plugins:maven-compiler-plugin:pom:2.0.2 from <a href=\"http://repo1.maven.org/maven2\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2</a> was cached in the local repository</p>\n<p>解决办法<br>在下面两个文件中的mirrors 组中增加自己公司里的私有仓库<br>The Maven install: $M2_HOME/conf/settings.xml<br>A user’s install: ${user.home}/.m2/settings.xml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mirrors&gt;</span><br><span class=\"line\">&lt;mirror&gt;</span><br><span class=\"line\"> &lt;id&gt;nexus-demo&lt;/id&gt;</span><br><span class=\"line\"> &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class=\"line\"> &lt;name&gt;Nexus demo&lt;/name&gt;</span><br><span class=\"line\"> &lt;url&gt;http://maven.demo.com.cn/content/groups/public&lt;/url&gt;</span><br><span class=\"line\">&lt;/mirror&gt;</span><br><span class=\"line\">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后重新update，注意勾上强制更新。<br>STS里如果更新失败，可以尝试直接命令行 mvn clean &amp; mvn install</p>\n<h1 id=\"其他异常\"><a href=\"#其他异常\" class=\"headerlink\" title=\"其他异常\"></a>其他异常</h1><h2 id=\"Not-an-managed-type-class-com-demo-entity-Approve\"><a href=\"#Not-an-managed-type-class-com-demo-entity-Approve\" class=\"headerlink\" title=\"Not an managed type: class com.demo.entity.Approve\"></a>Not an managed type: class com.demo.entity.Approve</h2><p>class Approve定义没有添加注解@Entity</p>\n<h2 id=\"No-qualifying-bean-of-type-com-demo-service-ApplyService-found-for-dependency\"><a href=\"#No-qualifying-bean-of-type-com-demo-service-ApplyService-found-for-dependency\" class=\"headerlink\" title=\"No qualifying bean of type [com.demo.service.ApplyService] found for dependency\"></a>No qualifying bean of type [com.demo.service.ApplyService] found for dependency</h2><p>没有在config/JPAConfig.java里正确配置package信息。或者是没有给加上@Service注解。</p>\n"},{"title":"centos安装mysql过程记录","date":"2017-01-10T11:39:06.000Z","_content":"软件版本：centos7，mysql5.6\n\n具体安装过程：\n\n# 1、通过ssh上传rpm安装文件\n\n# 2、由于centos默认安装了mariadb，需要先卸载。\n\n    查询是否已安装：\n\n     $ rpm -qa |grep mariadb \n\n    如果已经安装，则卸载：\n\n    $ rpm -e --nodeps mariadb-libs-5.5.47-1.el7_2.x86_64\n\n# 3、分别安装mysql server/client/devel。\n\n    切换到安装包目录：    \n\n    $ cd /usr/local/sw/MySql5.6\n\n     执行安装命令：\n\n    $ rpm -ivh MySQL-server-5.6.13-1.el6.x86_64.rpm\n\n     $ rpm -ivh MySQL-client-5.6.13-1.el6.x86_64.rpm\n\n     $ rpm -ivh MySQL-devel-5.6.13-1.el6.x86_64.rpm\n\n# 4、复制服务启动文件\n    $ cp /usr/share/mysql/mysql.server /etc/init.d/mysqld\n\n# 5、启动mysql服务\n    $ /etc/init.d/mysqld start\n\n    检查mysql 是否已经启动:$ netstat -atln | grep 3306\n\n# 6、把mysql加入开机自启动:\n    $ chkconfig  --add mysqld  \n\n# 7、设置账号密码\n\n    关闭mysql：$ /etc/init.d/mysql stop\n\n    进入mysql安全模式: $ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &\n\n    设置root账号密码，允许root远程连接，开发所有权限：\n\n    mysql -u root\n\n    mysql> use mysql;\n\n    mysql> UPDATE user SET Password=PASSWORD('newpassword') where USER='root';\n\n    mysql> INSERT INTO mysql.user (Host,User,Password,ssl_cipher,x509_issuer,x509_subject) VALUES ('%','root',PASSWORD('newpassword'),\"\",\"\",\"\"); \n\n    mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'newpassword' WITH GRANT OPTION;\n\n    mysql> FLUSH PRIVILEGES;\n\n    mysql> quit","source":"_posts/db/centos安装mysql过程记录.md","raw":"---\ntitle: centos安装mysql过程记录\ndate: 2017-01-10 19:39:06\ntags: [工具,MySQL]\n---\n软件版本：centos7，mysql5.6\n\n具体安装过程：\n\n# 1、通过ssh上传rpm安装文件\n\n# 2、由于centos默认安装了mariadb，需要先卸载。\n\n    查询是否已安装：\n\n     $ rpm -qa |grep mariadb \n\n    如果已经安装，则卸载：\n\n    $ rpm -e --nodeps mariadb-libs-5.5.47-1.el7_2.x86_64\n\n# 3、分别安装mysql server/client/devel。\n\n    切换到安装包目录：    \n\n    $ cd /usr/local/sw/MySql5.6\n\n     执行安装命令：\n\n    $ rpm -ivh MySQL-server-5.6.13-1.el6.x86_64.rpm\n\n     $ rpm -ivh MySQL-client-5.6.13-1.el6.x86_64.rpm\n\n     $ rpm -ivh MySQL-devel-5.6.13-1.el6.x86_64.rpm\n\n# 4、复制服务启动文件\n    $ cp /usr/share/mysql/mysql.server /etc/init.d/mysqld\n\n# 5、启动mysql服务\n    $ /etc/init.d/mysqld start\n\n    检查mysql 是否已经启动:$ netstat -atln | grep 3306\n\n# 6、把mysql加入开机自启动:\n    $ chkconfig  --add mysqld  \n\n# 7、设置账号密码\n\n    关闭mysql：$ /etc/init.d/mysql stop\n\n    进入mysql安全模式: $ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &\n\n    设置root账号密码，允许root远程连接，开发所有权限：\n\n    mysql -u root\n\n    mysql> use mysql;\n\n    mysql> UPDATE user SET Password=PASSWORD('newpassword') where USER='root';\n\n    mysql> INSERT INTO mysql.user (Host,User,Password,ssl_cipher,x509_issuer,x509_subject) VALUES ('%','root',PASSWORD('newpassword'),\"\",\"\",\"\"); \n\n    mysql> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'newpassword' WITH GRANT OPTION;\n\n    mysql> FLUSH PRIVILEGES;\n\n    mysql> quit","slug":"db/centos安装mysql过程记录","published":1,"updated":"2018-03-11T06:58:11.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl0004tccmipsgh3kz","content":"<p>软件版本：centos7，mysql5.6</p>\n<p>具体安装过程：</p>\n<h1 id=\"1、通过ssh上传rpm安装文件\"><a href=\"#1、通过ssh上传rpm安装文件\" class=\"headerlink\" title=\"1、通过ssh上传rpm安装文件\"></a>1、通过ssh上传rpm安装文件</h1><h1 id=\"2、由于centos默认安装了mariadb，需要先卸载。\"><a href=\"#2、由于centos默认安装了mariadb，需要先卸载。\" class=\"headerlink\" title=\"2、由于centos默认安装了mariadb，需要先卸载。\"></a>2、由于centos默认安装了mariadb，需要先卸载。</h1><pre><code>查询是否已安装：\n\n $ rpm -qa |grep mariadb \n\n如果已经安装，则卸载：\n\n$ rpm -e --nodeps mariadb-libs-5.5.47-1.el7_2.x86_64\n</code></pre><h1 id=\"3、分别安装mysql-server-client-devel。\"><a href=\"#3、分别安装mysql-server-client-devel。\" class=\"headerlink\" title=\"3、分别安装mysql server/client/devel。\"></a>3、分别安装mysql server/client/devel。</h1><pre><code>切换到安装包目录：    \n\n$ cd /usr/local/sw/MySql5.6\n\n 执行安装命令：\n\n$ rpm -ivh MySQL-server-5.6.13-1.el6.x86_64.rpm\n\n $ rpm -ivh MySQL-client-5.6.13-1.el6.x86_64.rpm\n\n $ rpm -ivh MySQL-devel-5.6.13-1.el6.x86_64.rpm\n</code></pre><h1 id=\"4、复制服务启动文件\"><a href=\"#4、复制服务启动文件\" class=\"headerlink\" title=\"4、复制服务启动文件\"></a>4、复制服务启动文件</h1><pre><code>$ cp /usr/share/mysql/mysql.server /etc/init.d/mysqld\n</code></pre><h1 id=\"5、启动mysql服务\"><a href=\"#5、启动mysql服务\" class=\"headerlink\" title=\"5、启动mysql服务\"></a>5、启动mysql服务</h1><pre><code>$ /etc/init.d/mysqld start\n\n检查mysql 是否已经启动:$ netstat -atln | grep 3306\n</code></pre><h1 id=\"6、把mysql加入开机自启动\"><a href=\"#6、把mysql加入开机自启动\" class=\"headerlink\" title=\"6、把mysql加入开机自启动:\"></a>6、把mysql加入开机自启动:</h1><pre><code>$ chkconfig  --add mysqld  \n</code></pre><h1 id=\"7、设置账号密码\"><a href=\"#7、设置账号密码\" class=\"headerlink\" title=\"7、设置账号密码\"></a>7、设置账号密码</h1><pre><code>关闭mysql：$ /etc/init.d/mysql stop\n\n进入mysql安全模式: $ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;\n\n设置root账号密码，允许root远程连接，开发所有权限：\n\nmysql -u root\n\nmysql&gt; use mysql;\n\nmysql&gt; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;\n\nmysql&gt; INSERT INTO mysql.user (Host,User,Password,ssl_cipher,x509_issuer,x509_subject) VALUES (&apos;%&apos;,&apos;root&apos;,PASSWORD(&apos;newpassword&apos;),&quot;&quot;,&quot;&quot;,&quot;&quot;); \n\nmysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;newpassword&apos; WITH GRANT OPTION;\n\nmysql&gt; FLUSH PRIVILEGES;\n\nmysql&gt; quit\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>软件版本：centos7，mysql5.6</p>\n<p>具体安装过程：</p>\n<h1 id=\"1、通过ssh上传rpm安装文件\"><a href=\"#1、通过ssh上传rpm安装文件\" class=\"headerlink\" title=\"1、通过ssh上传rpm安装文件\"></a>1、通过ssh上传rpm安装文件</h1><h1 id=\"2、由于centos默认安装了mariadb，需要先卸载。\"><a href=\"#2、由于centos默认安装了mariadb，需要先卸载。\" class=\"headerlink\" title=\"2、由于centos默认安装了mariadb，需要先卸载。\"></a>2、由于centos默认安装了mariadb，需要先卸载。</h1><pre><code>查询是否已安装：\n\n $ rpm -qa |grep mariadb \n\n如果已经安装，则卸载：\n\n$ rpm -e --nodeps mariadb-libs-5.5.47-1.el7_2.x86_64\n</code></pre><h1 id=\"3、分别安装mysql-server-client-devel。\"><a href=\"#3、分别安装mysql-server-client-devel。\" class=\"headerlink\" title=\"3、分别安装mysql server/client/devel。\"></a>3、分别安装mysql server/client/devel。</h1><pre><code>切换到安装包目录：    \n\n$ cd /usr/local/sw/MySql5.6\n\n 执行安装命令：\n\n$ rpm -ivh MySQL-server-5.6.13-1.el6.x86_64.rpm\n\n $ rpm -ivh MySQL-client-5.6.13-1.el6.x86_64.rpm\n\n $ rpm -ivh MySQL-devel-5.6.13-1.el6.x86_64.rpm\n</code></pre><h1 id=\"4、复制服务启动文件\"><a href=\"#4、复制服务启动文件\" class=\"headerlink\" title=\"4、复制服务启动文件\"></a>4、复制服务启动文件</h1><pre><code>$ cp /usr/share/mysql/mysql.server /etc/init.d/mysqld\n</code></pre><h1 id=\"5、启动mysql服务\"><a href=\"#5、启动mysql服务\" class=\"headerlink\" title=\"5、启动mysql服务\"></a>5、启动mysql服务</h1><pre><code>$ /etc/init.d/mysqld start\n\n检查mysql 是否已经启动:$ netstat -atln | grep 3306\n</code></pre><h1 id=\"6、把mysql加入开机自启动\"><a href=\"#6、把mysql加入开机自启动\" class=\"headerlink\" title=\"6、把mysql加入开机自启动:\"></a>6、把mysql加入开机自启动:</h1><pre><code>$ chkconfig  --add mysqld  \n</code></pre><h1 id=\"7、设置账号密码\"><a href=\"#7、设置账号密码\" class=\"headerlink\" title=\"7、设置账号密码\"></a>7、设置账号密码</h1><pre><code>关闭mysql：$ /etc/init.d/mysql stop\n\n进入mysql安全模式: $ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;\n\n设置root账号密码，允许root远程连接，开发所有权限：\n\nmysql -u root\n\nmysql&gt; use mysql;\n\nmysql&gt; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) where USER=&apos;root&apos;;\n\nmysql&gt; INSERT INTO mysql.user (Host,User,Password,ssl_cipher,x509_issuer,x509_subject) VALUES (&apos;%&apos;,&apos;root&apos;,PASSWORD(&apos;newpassword&apos;),&quot;&quot;,&quot;&quot;,&quot;&quot;); \n\nmysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;newpassword&apos; WITH GRANT OPTION;\n\nmysql&gt; FLUSH PRIVILEGES;\n\nmysql&gt; quit\n</code></pre>"},{"title":"ZUUL路由服务遇到的坑","date":"2018-02-26T06:16:22.000Z","_content":"\n项目采用Spring cloud微服务框架，使用ZUUL作为路由服务，在使用过程中遇到了如下问题，记录下来供大家借鉴。\n## 1、关于跨域\nAPI需要提供给其他项目使用，由于服务通过zuul，所以zuul需要支持跨域访问。\n解决办法：\n增加跨域过滤器即可\n```java\n@Bean\n    public CorsFilter corsFilter() {\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(\"*\");\n        config.addAllowedHeader(\"*\");\n        config.addAllowedMethod(\"*\");\n        config.setMaxAge(3600L);\n        source.registerCorsConfiguration(\"/**\", config);\n        return new CorsFilter(source);\n    }\n```\n## 2、文件上传中文名乱码\n使用form上传文件，直接post到服务，文件名中文读取正常。但是通过zuul中转后，文件名变成乱码。\n解决办法：\n1、注意编码，全站api和前端全部要使用utf-8编码。zuul中强制编码为utf-8，参数配置如下：\n```yaml\nspring:\n  http:\n    encoding:\n      charset: UTF-8\n      enabled: true\n      force: true\n```\n2、修改nginx路由设置，在原来的api地址前，统一增加zuul。因为默认上传文件是通过服务自己的controller来处理，增加zuul前缀后，通过zuul servlet来处理，避免了多次跳转，和引入编码错误。nginx配置举例：\n```\n    location /api/ {\n                proxy_pass   http://localhost:9999/zuul/api/;\n                proxy_redirect  http://localhost:9999/zuul/api/ /api/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header REMOTE-HOST $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n                client_max_body_size 500m;\n                proxy_connect_timeout 60s;\n                proxy_read_timeout 600s;\n                proxy_send_timeout 600s;\n            }\n```\n3、增加zuul前缀后会导致header中出现Access-Control-Allow-Credentials等属性重复的异常，需要在zuul中设置header忽略。参数配置如下\n```yaml\nzuul:\n  sensitiveHeaders: Authorization\n  ignored-headers: Access-Control-Allow-Credentials,Access-Control-Allow-Origin,Vary,X-Frame-Options\n```\n","source":"_posts/java/ZUUL路由服务遇到的坑.md","raw":"---\ntitle: ZUUL路由服务遇到的坑\ndate: 2018-02-26 14:16:22\ntags: [zuul,java]\n---\n\n项目采用Spring cloud微服务框架，使用ZUUL作为路由服务，在使用过程中遇到了如下问题，记录下来供大家借鉴。\n## 1、关于跨域\nAPI需要提供给其他项目使用，由于服务通过zuul，所以zuul需要支持跨域访问。\n解决办法：\n增加跨域过滤器即可\n```java\n@Bean\n    public CorsFilter corsFilter() {\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.addAllowedOrigin(\"*\");\n        config.addAllowedHeader(\"*\");\n        config.addAllowedMethod(\"*\");\n        config.setMaxAge(3600L);\n        source.registerCorsConfiguration(\"/**\", config);\n        return new CorsFilter(source);\n    }\n```\n## 2、文件上传中文名乱码\n使用form上传文件，直接post到服务，文件名中文读取正常。但是通过zuul中转后，文件名变成乱码。\n解决办法：\n1、注意编码，全站api和前端全部要使用utf-8编码。zuul中强制编码为utf-8，参数配置如下：\n```yaml\nspring:\n  http:\n    encoding:\n      charset: UTF-8\n      enabled: true\n      force: true\n```\n2、修改nginx路由设置，在原来的api地址前，统一增加zuul。因为默认上传文件是通过服务自己的controller来处理，增加zuul前缀后，通过zuul servlet来处理，避免了多次跳转，和引入编码错误。nginx配置举例：\n```\n    location /api/ {\n                proxy_pass   http://localhost:9999/zuul/api/;\n                proxy_redirect  http://localhost:9999/zuul/api/ /api/;\n                proxy_set_header Host $host;\n                proxy_set_header X-Real-IP $remote_addr;\n                proxy_set_header REMOTE-HOST $remote_addr;\n                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n                client_max_body_size 500m;\n                proxy_connect_timeout 60s;\n                proxy_read_timeout 600s;\n                proxy_send_timeout 600s;\n            }\n```\n3、增加zuul前缀后会导致header中出现Access-Control-Allow-Credentials等属性重复的异常，需要在zuul中设置header忽略。参数配置如下\n```yaml\nzuul:\n  sensitiveHeaders: Authorization\n  ignored-headers: Access-Control-Allow-Credentials,Access-Control-Allow-Origin,Vary,X-Frame-Options\n```\n","slug":"java/ZUUL路由服务遇到的坑","published":1,"updated":"2018-03-11T07:14:10.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl0006tccmhd3trs51","content":"<p>项目采用Spring cloud微服务框架，使用ZUUL作为路由服务，在使用过程中遇到了如下问题，记录下来供大家借鉴。</p>\n<h2 id=\"1、关于跨域\"><a href=\"#1、关于跨域\" class=\"headerlink\" title=\"1、关于跨域\"></a>1、关于跨域</h2><p>API需要提供给其他项目使用，由于服务通过zuul，所以zuul需要支持跨域访问。<br>解决办法：<br>增加跨域过滤器即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CorsFilter <span class=\"title\">corsFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UrlBasedCorsConfigurationSource source = <span class=\"keyword\">new</span> UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> CorsConfiguration config = <span class=\"keyword\">new</span> CorsConfiguration();</span><br><span class=\"line\">        config.setAllowCredentials(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.addAllowedOrigin(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.addAllowedHeader(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.addAllowedMethod(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.setMaxAge(<span class=\"number\">3600L</span>);</span><br><span class=\"line\">        source.registerCorsConfiguration(<span class=\"string\">\"/**\"</span>, config);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CorsFilter(source);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2、文件上传中文名乱码\"><a href=\"#2、文件上传中文名乱码\" class=\"headerlink\" title=\"2、文件上传中文名乱码\"></a>2、文件上传中文名乱码</h2><p>使用form上传文件，直接post到服务，文件名中文读取正常。但是通过zuul中转后，文件名变成乱码。<br>解决办法：<br>1、注意编码，全站api和前端全部要使用utf-8编码。zuul中强制编码为utf-8，参数配置如下：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  http:</span></span><br><span class=\"line\"><span class=\"attr\">    encoding:</span></span><br><span class=\"line\"><span class=\"attr\">      charset:</span> <span class=\"string\">UTF-8</span></span><br><span class=\"line\"><span class=\"attr\">      enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">      force:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>2、修改nginx路由设置，在原来的api地址前，统一增加zuul。因为默认上传文件是通过服务自己的controller来处理，增加zuul前缀后，通过zuul servlet来处理，避免了多次跳转，和引入编码错误。nginx配置举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /api/ &#123;</span><br><span class=\"line\">            proxy_pass   http://localhost:9999/zuul/api/;</span><br><span class=\"line\">            proxy_redirect  http://localhost:9999/zuul/api/ /api/;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; </span><br><span class=\"line\">            client_max_body_size 500m;</span><br><span class=\"line\">            proxy_connect_timeout 60s;</span><br><span class=\"line\">            proxy_read_timeout 600s;</span><br><span class=\"line\">            proxy_send_timeout 600s;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>3、增加zuul前缀后会导致header中出现Access-Control-Allow-Credentials等属性重复的异常，需要在zuul中设置header忽略。参数配置如下<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  sensitiveHeaders:</span> <span class=\"string\">Authorization</span></span><br><span class=\"line\"><span class=\"attr\">  ignored-headers:</span> <span class=\"string\">Access-Control-Allow-Credentials,Access-Control-Allow-Origin,Vary,X-Frame-Options</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目采用Spring cloud微服务框架，使用ZUUL作为路由服务，在使用过程中遇到了如下问题，记录下来供大家借鉴。</p>\n<h2 id=\"1、关于跨域\"><a href=\"#1、关于跨域\" class=\"headerlink\" title=\"1、关于跨域\"></a>1、关于跨域</h2><p>API需要提供给其他项目使用，由于服务通过zuul，所以zuul需要支持跨域访问。<br>解决办法：<br>增加跨域过滤器即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CorsFilter <span class=\"title\">corsFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UrlBasedCorsConfigurationSource source = <span class=\"keyword\">new</span> UrlBasedCorsConfigurationSource();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> CorsConfiguration config = <span class=\"keyword\">new</span> CorsConfiguration();</span><br><span class=\"line\">        config.setAllowCredentials(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        config.addAllowedOrigin(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.addAllowedHeader(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.addAllowedMethod(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">        config.setMaxAge(<span class=\"number\">3600L</span>);</span><br><span class=\"line\">        source.registerCorsConfiguration(<span class=\"string\">\"/**\"</span>, config);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CorsFilter(source);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2、文件上传中文名乱码\"><a href=\"#2、文件上传中文名乱码\" class=\"headerlink\" title=\"2、文件上传中文名乱码\"></a>2、文件上传中文名乱码</h2><p>使用form上传文件，直接post到服务，文件名中文读取正常。但是通过zuul中转后，文件名变成乱码。<br>解决办法：<br>1、注意编码，全站api和前端全部要使用utf-8编码。zuul中强制编码为utf-8，参数配置如下：<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  http:</span></span><br><span class=\"line\"><span class=\"attr\">    encoding:</span></span><br><span class=\"line\"><span class=\"attr\">      charset:</span> <span class=\"string\">UTF-8</span></span><br><span class=\"line\"><span class=\"attr\">      enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">      force:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>2、修改nginx路由设置，在原来的api地址前，统一增加zuul。因为默认上传文件是通过服务自己的controller来处理，增加zuul前缀后，通过zuul servlet来处理，避免了多次跳转，和引入编码错误。nginx配置举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /api/ &#123;</span><br><span class=\"line\">            proxy_pass   http://localhost:9999/zuul/api/;</span><br><span class=\"line\">            proxy_redirect  http://localhost:9999/zuul/api/ /api/;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; </span><br><span class=\"line\">            client_max_body_size 500m;</span><br><span class=\"line\">            proxy_connect_timeout 60s;</span><br><span class=\"line\">            proxy_read_timeout 600s;</span><br><span class=\"line\">            proxy_send_timeout 600s;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>3、增加zuul前缀后会导致header中出现Access-Control-Allow-Credentials等属性重复的异常，需要在zuul中设置header忽略。参数配置如下<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">zuul:</span></span><br><span class=\"line\"><span class=\"attr\">  sensitiveHeaders:</span> <span class=\"string\">Authorization</span></span><br><span class=\"line\"><span class=\"attr\">  ignored-headers:</span> <span class=\"string\">Access-Control-Allow-Credentials,Access-Control-Allow-Origin,Vary,X-Frame-Options</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"BeyongCompare跨操作系统比较文件","date":"2016-07-10T11:39:06.000Z","_content":"# 问题现象\n一份代码在windows上，一份在linux上。直接用BC比较，js和css文件，结果文件全部红色，被判为有差异。实际文件没有修改，必须挨个文件打开，才能知道是否有变化。其他文件无此问题。如果两份代码全部在windows上也没有此问题。\n# 问题原因\nwindows和linux上对换行符的定义是不一样的，所以导致BC因为有变化。\n# 解决办法\n在BC里面选择基于规则比较。\n![](https://static.oschina.net/uploads/img/201803/09212530_pb36.jpg)\n\n打开一个JS文件选择规则，设置“比较行结尾”\n![](https://static.oschina.net/uploads/img/201803/09212726_UN7r.jpg)","source":"_posts/tool/BeyongCompare跨操作系统比较文件.md","raw":"---\ntitle: BeyongCompare跨操作系统比较文件\ndate: 2016-07-10 19:39:06\ntags: [工具]\n---\n# 问题现象\n一份代码在windows上，一份在linux上。直接用BC比较，js和css文件，结果文件全部红色，被判为有差异。实际文件没有修改，必须挨个文件打开，才能知道是否有变化。其他文件无此问题。如果两份代码全部在windows上也没有此问题。\n# 问题原因\nwindows和linux上对换行符的定义是不一样的，所以导致BC因为有变化。\n# 解决办法\n在BC里面选择基于规则比较。\n![](https://static.oschina.net/uploads/img/201803/09212530_pb36.jpg)\n\n打开一个JS文件选择规则，设置“比较行结尾”\n![](https://static.oschina.net/uploads/img/201803/09212726_UN7r.jpg)","slug":"tool/BeyongCompare跨操作系统比较文件","published":1,"updated":"2018-03-09T13:58:54.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl0007tccmiko9u08a","content":"<h1 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h1><p>一份代码在windows上，一份在linux上。直接用BC比较，js和css文件，结果文件全部红色，被判为有差异。实际文件没有修改，必须挨个文件打开，才能知道是否有变化。其他文件无此问题。如果两份代码全部在windows上也没有此问题。</p>\n<h1 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h1><p>windows和linux上对换行符的定义是不一样的，所以导致BC因为有变化。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>在BC里面选择基于规则比较。<br><img src=\"https://static.oschina.net/uploads/img/201803/09212530_pb36.jpg\" alt=\"\"></p>\n<p>打开一个JS文件选择规则，设置“比较行结尾”<br><img src=\"https://static.oschina.net/uploads/img/201803/09212726_UN7r.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h1><p>一份代码在windows上，一份在linux上。直接用BC比较，js和css文件，结果文件全部红色，被判为有差异。实际文件没有修改，必须挨个文件打开，才能知道是否有变化。其他文件无此问题。如果两份代码全部在windows上也没有此问题。</p>\n<h1 id=\"问题原因\"><a href=\"#问题原因\" class=\"headerlink\" title=\"问题原因\"></a>问题原因</h1><p>windows和linux上对换行符的定义是不一样的，所以导致BC因为有变化。</p>\n<h1 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h1><p>在BC里面选择基于规则比较。<br><img src=\"https://static.oschina.net/uploads/img/201803/09212530_pb36.jpg\" alt=\"\"></p>\n<p>打开一个JS文件选择规则，设置“比较行结尾”<br><img src=\"https://static.oschina.net/uploads/img/201803/09212726_UN7r.jpg\" alt=\"\"></p>\n"},{"title":"Chrome无法搜索和安装插件的解决办法","date":"2016-07-10T11:39:06.000Z","_content":"由于你懂的原因，Google Chrome插件无法搜索和安装。这里提供一个临时解决方案。\n1. 打开 http://www.cnplugins.com  或者 http://www.chromeextensions.org 网站（类似网站很多，可以自己搜索）。 搜索您需要的插件，下载到本地。\n2. 在chrome地址栏输入 chrome://extensions/ 或者通过菜单打开扩展程序。\n3. 将下载的.crx文件拖放到扩展程序页面，然后确认安装即可。\n\n### web前端开发常用的插件推荐\n1. 网页调试HTTP测试工具-Postman  http://www.cnplugins.com/devtool/postman/#dlink  \n2. web性能分析工具PageSpeed Insights (by Google)  http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink \n\n备注：\npagespeed安装后执行分析会出现跑死现象，初步分析是改工具需要连接google获取资源，被墙了：（\n可以考虑使用performance-analyser代替，进行性能分析 http://www.cnplugins.com/devtool/performance-analyser/download.html\n\n### 补充postman无法安装的解决办法\n1. 使用解压缩软件将crx文件解压缩。将解压后的文件夹里的\"_metadata\"文件夹改名为\"metadata\"\n2. 打开chrome的扩展程序![图片1.png](https://upload-images.jianshu.io/upload_images/4944427-2a15fe06d12e3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 勾选开发者模式，然后点击“加载已解压的扩展程序”，选中.crx文件解压后的目录，即可安装成功![图片2.png](https://upload-images.jianshu.io/upload_images/4944427-c2d1b9399f61ce5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. 使用时在扩展程序中点击“启动”，打开postman后，无需注册也可以使用![图片3.png](https://upload-images.jianshu.io/upload_images/4944427-4482bb1ef4543f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5. 以后每次打开chrome都会出现如下提醒，一定要选择“取消”，否则插件会停用![图片4.png](https://upload-images.jianshu.io/upload_images/4944427-a058ca135e76688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","source":"_posts/tool/Chrome无法搜索和安装插件的解决办法.md","raw":"---\ntitle: Chrome无法搜索和安装插件的解决办法\ndate: 2016-07-10 19:39:06\ntags: [工具]\n---\n由于你懂的原因，Google Chrome插件无法搜索和安装。这里提供一个临时解决方案。\n1. 打开 http://www.cnplugins.com  或者 http://www.chromeextensions.org 网站（类似网站很多，可以自己搜索）。 搜索您需要的插件，下载到本地。\n2. 在chrome地址栏输入 chrome://extensions/ 或者通过菜单打开扩展程序。\n3. 将下载的.crx文件拖放到扩展程序页面，然后确认安装即可。\n\n### web前端开发常用的插件推荐\n1. 网页调试HTTP测试工具-Postman  http://www.cnplugins.com/devtool/postman/#dlink  \n2. web性能分析工具PageSpeed Insights (by Google)  http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink \n\n备注：\npagespeed安装后执行分析会出现跑死现象，初步分析是改工具需要连接google获取资源，被墙了：（\n可以考虑使用performance-analyser代替，进行性能分析 http://www.cnplugins.com/devtool/performance-analyser/download.html\n\n### 补充postman无法安装的解决办法\n1. 使用解压缩软件将crx文件解压缩。将解压后的文件夹里的\"_metadata\"文件夹改名为\"metadata\"\n2. 打开chrome的扩展程序![图片1.png](https://upload-images.jianshu.io/upload_images/4944427-2a15fe06d12e3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n3. 勾选开发者模式，然后点击“加载已解压的扩展程序”，选中.crx文件解压后的目录，即可安装成功![图片2.png](https://upload-images.jianshu.io/upload_images/4944427-c2d1b9399f61ce5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n4. 使用时在扩展程序中点击“启动”，打开postman后，无需注册也可以使用![图片3.png](https://upload-images.jianshu.io/upload_images/4944427-4482bb1ef4543f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n5. 以后每次打开chrome都会出现如下提醒，一定要选择“取消”，否则插件会停用![图片4.png](https://upload-images.jianshu.io/upload_images/4944427-a058ca135e76688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","slug":"tool/Chrome无法搜索和安装插件的解决办法","published":1,"updated":"2018-03-11T07:29:03.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl0008tccm6545ts65","content":"<p>由于你懂的原因，Google Chrome插件无法搜索和安装。这里提供一个临时解决方案。</p>\n<ol>\n<li>打开 <a href=\"http://www.cnplugins.com\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com</a>  或者 <a href=\"http://www.chromeextensions.org\" target=\"_blank\" rel=\"noopener\">http://www.chromeextensions.org</a> 网站（类似网站很多，可以自己搜索）。 搜索您需要的插件，下载到本地。</li>\n<li>在chrome地址栏输入 chrome://extensions/ 或者通过菜单打开扩展程序。</li>\n<li>将下载的.crx文件拖放到扩展程序页面，然后确认安装即可。</li>\n</ol>\n<h3 id=\"web前端开发常用的插件推荐\"><a href=\"#web前端开发常用的插件推荐\" class=\"headerlink\" title=\"web前端开发常用的插件推荐\"></a>web前端开发常用的插件推荐</h3><ol>\n<li>网页调试HTTP测试工具-Postman  <a href=\"http://www.cnplugins.com/devtool/postman/#dlink\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/postman/#dlink</a>  </li>\n<li>web性能分析工具PageSpeed Insights (by Google)  <a href=\"http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink</a> </li>\n</ol>\n<p>备注：<br>pagespeed安装后执行分析会出现跑死现象，初步分析是改工具需要连接google获取资源，被墙了：（<br>可以考虑使用performance-analyser代替，进行性能分析 <a href=\"http://www.cnplugins.com/devtool/performance-analyser/download.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/performance-analyser/download.html</a></p>\n<h3 id=\"补充postman无法安装的解决办法\"><a href=\"#补充postman无法安装的解决办法\" class=\"headerlink\" title=\"补充postman无法安装的解决办法\"></a>补充postman无法安装的解决办法</h3><ol>\n<li>使用解压缩软件将crx文件解压缩。将解压后的文件夹里的”_metadata”文件夹改名为”metadata”</li>\n<li>打开chrome的扩展程序<img src=\"https://upload-images.jianshu.io/upload_images/4944427-2a15fe06d12e3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片1.png\"></li>\n<li>勾选开发者模式，然后点击“加载已解压的扩展程序”，选中.crx文件解压后的目录，即可安装成功<img src=\"https://upload-images.jianshu.io/upload_images/4944427-c2d1b9399f61ce5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片2.png\"></li>\n<li>使用时在扩展程序中点击“启动”，打开postman后，无需注册也可以使用<img src=\"https://upload-images.jianshu.io/upload_images/4944427-4482bb1ef4543f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片3.png\"></li>\n<li>以后每次打开chrome都会出现如下提醒，一定要选择“取消”，否则插件会停用<img src=\"https://upload-images.jianshu.io/upload_images/4944427-a058ca135e76688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片4.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>由于你懂的原因，Google Chrome插件无法搜索和安装。这里提供一个临时解决方案。</p>\n<ol>\n<li>打开 <a href=\"http://www.cnplugins.com\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com</a>  或者 <a href=\"http://www.chromeextensions.org\" target=\"_blank\" rel=\"noopener\">http://www.chromeextensions.org</a> 网站（类似网站很多，可以自己搜索）。 搜索您需要的插件，下载到本地。</li>\n<li>在chrome地址栏输入 chrome://extensions/ 或者通过菜单打开扩展程序。</li>\n<li>将下载的.crx文件拖放到扩展程序页面，然后确认安装即可。</li>\n</ol>\n<h3 id=\"web前端开发常用的插件推荐\"><a href=\"#web前端开发常用的插件推荐\" class=\"headerlink\" title=\"web前端开发常用的插件推荐\"></a>web前端开发常用的插件推荐</h3><ol>\n<li>网页调试HTTP测试工具-Postman  <a href=\"http://www.cnplugins.com/devtool/postman/#dlink\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/postman/#dlink</a>  </li>\n<li>web性能分析工具PageSpeed Insights (by Google)  <a href=\"http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/pagespeed-insights-by-goo/#dlink</a> </li>\n</ol>\n<p>备注：<br>pagespeed安装后执行分析会出现跑死现象，初步分析是改工具需要连接google获取资源，被墙了：（<br>可以考虑使用performance-analyser代替，进行性能分析 <a href=\"http://www.cnplugins.com/devtool/performance-analyser/download.html\" target=\"_blank\" rel=\"noopener\">http://www.cnplugins.com/devtool/performance-analyser/download.html</a></p>\n<h3 id=\"补充postman无法安装的解决办法\"><a href=\"#补充postman无法安装的解决办法\" class=\"headerlink\" title=\"补充postman无法安装的解决办法\"></a>补充postman无法安装的解决办法</h3><ol>\n<li>使用解压缩软件将crx文件解压缩。将解压后的文件夹里的”_metadata”文件夹改名为”metadata”</li>\n<li>打开chrome的扩展程序<img src=\"https://upload-images.jianshu.io/upload_images/4944427-2a15fe06d12e3d68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片1.png\"></li>\n<li>勾选开发者模式，然后点击“加载已解压的扩展程序”，选中.crx文件解压后的目录，即可安装成功<img src=\"https://upload-images.jianshu.io/upload_images/4944427-c2d1b9399f61ce5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片2.png\"></li>\n<li>使用时在扩展程序中点击“启动”，打开postman后，无需注册也可以使用<img src=\"https://upload-images.jianshu.io/upload_images/4944427-4482bb1ef4543f90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片3.png\"></li>\n<li>以后每次打开chrome都会出现如下提醒，一定要选择“取消”，否则插件会停用<img src=\"https://upload-images.jianshu.io/upload_images/4944427-a058ca135e76688d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"图片4.png\"></li>\n</ol>\n"},{"title":"Jenkins脚本调用firefox失败的解决办法","date":"2018-01-08T08:54:08.000Z","_content":"### 问题描述\njenkins执行的shell脚本里，调用karma进行UT测试，日志显示Cannot start Firefox。karma设置的浏览器是firefox，由于firefox无法启动导致用例无法执行。\n### 定位过程\n1、开始怀疑是jenkins没有权限，无法调用firefox，给jenkins配置为root权限。可以在脚本中增加 whoami 命令来打印当前用户名称。结果错误依然存在。\n2、在在脚本里直接调用firefox，显示错误信息：Error: GDK_BACKEND does not match available displays。经查询，发现是调用firefox时没有传递display ID，导致firefox无法显示界面。\n3、原因分析：由于CI服务器上调用jenkins使用的命令是：(java -jar /home/data/jenkins/jenkins.war&) 。此种方式调用jenkins，直接后台进行运行，没有分配显示资源，而且关闭命令窗口，程序依然可以正常执行。但是由于没有display ID，导致firefox无法运行。\n### 解决办法\n直接在命令窗口中运行jenkins，保持命令窗口。命令为：java -jar /home/data/jenkins/jenkins.war\n","source":"_posts/tool/Jenkins脚本调用firefox失败的解决办法.md","raw":"---\ntitle: Jenkins脚本调用firefox失败的解决办法\ndate: 2018-01-08 16:54:08\ntags: [工具,linux]\n---\n### 问题描述\njenkins执行的shell脚本里，调用karma进行UT测试，日志显示Cannot start Firefox。karma设置的浏览器是firefox，由于firefox无法启动导致用例无法执行。\n### 定位过程\n1、开始怀疑是jenkins没有权限，无法调用firefox，给jenkins配置为root权限。可以在脚本中增加 whoami 命令来打印当前用户名称。结果错误依然存在。\n2、在在脚本里直接调用firefox，显示错误信息：Error: GDK_BACKEND does not match available displays。经查询，发现是调用firefox时没有传递display ID，导致firefox无法显示界面。\n3、原因分析：由于CI服务器上调用jenkins使用的命令是：(java -jar /home/data/jenkins/jenkins.war&) 。此种方式调用jenkins，直接后台进行运行，没有分配显示资源，而且关闭命令窗口，程序依然可以正常执行。但是由于没有display ID，导致firefox无法运行。\n### 解决办法\n直接在命令窗口中运行jenkins，保持命令窗口。命令为：java -jar /home/data/jenkins/jenkins.war\n","slug":"tool/Jenkins脚本调用firefox失败的解决办法","published":1,"updated":"2018-03-09T12:19:34.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl000btccmn0cp28o6","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>jenkins执行的shell脚本里，调用karma进行UT测试，日志显示Cannot start Firefox。karma设置的浏览器是firefox，由于firefox无法启动导致用例无法执行。</p>\n<h3 id=\"定位过程\"><a href=\"#定位过程\" class=\"headerlink\" title=\"定位过程\"></a>定位过程</h3><p>1、开始怀疑是jenkins没有权限，无法调用firefox，给jenkins配置为root权限。可以在脚本中增加 whoami 命令来打印当前用户名称。结果错误依然存在。<br>2、在在脚本里直接调用firefox，显示错误信息：Error: GDK_BACKEND does not match available displays。经查询，发现是调用firefox时没有传递display ID，导致firefox无法显示界面。<br>3、原因分析：由于CI服务器上调用jenkins使用的命令是：(java -jar /home/data/jenkins/jenkins.war&amp;) 。此种方式调用jenkins，直接后台进行运行，没有分配显示资源，而且关闭命令窗口，程序依然可以正常执行。但是由于没有display ID，导致firefox无法运行。</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>直接在命令窗口中运行jenkins，保持命令窗口。命令为：java -jar /home/data/jenkins/jenkins.war</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>jenkins执行的shell脚本里，调用karma进行UT测试，日志显示Cannot start Firefox。karma设置的浏览器是firefox，由于firefox无法启动导致用例无法执行。</p>\n<h3 id=\"定位过程\"><a href=\"#定位过程\" class=\"headerlink\" title=\"定位过程\"></a>定位过程</h3><p>1、开始怀疑是jenkins没有权限，无法调用firefox，给jenkins配置为root权限。可以在脚本中增加 whoami 命令来打印当前用户名称。结果错误依然存在。<br>2、在在脚本里直接调用firefox，显示错误信息：Error: GDK_BACKEND does not match available displays。经查询，发现是调用firefox时没有传递display ID，导致firefox无法显示界面。<br>3、原因分析：由于CI服务器上调用jenkins使用的命令是：(java -jar /home/data/jenkins/jenkins.war&amp;) 。此种方式调用jenkins，直接后台进行运行，没有分配显示资源，而且关闭命令窗口，程序依然可以正常执行。但是由于没有display ID，导致firefox无法运行。</p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>直接在命令窗口中运行jenkins，保持命令窗口。命令为：java -jar /home/data/jenkins/jenkins.war</p>\n"},{"title":"JConsole的远程连接","date":"2018-01-30T06:16:08.000Z","_content":"### JConsole介绍\nJConsole是JDK自带的Java性能分析器，用来监听Java应用程序性能和跟踪代码。默认安装在JDK的bin目录（例如：C:\\Program Files\\Java\\jdk1.8.0_144\\bin），直接双击运行即可。  \nJConsole可以监听本地的应用，也可以监听远程的应用。在新建连接界面上选择本地应用，或者输入远程连接地址，格式是ip:port，注意这个port是监听端口不是服务端口。\n![连接1.jpg](http://upload-images.jianshu.io/upload_images/4944427-73420e670c475117.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n连接完成后进入监听界面，可以查看内存、线程、类、JVM等相关信息。\n![监听1.jpg](http://upload-images.jianshu.io/upload_images/4944427-23976ac232a8d753.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 关于远程连接\n测试环境部署在RedHat6.5服务器上，一般说明增加如下参数即可允许远程连接。\n```java\n-Dcom.sun.management.jmxremote.port=8999\n-Dcom.sun.management.jmxremote.authenticate=false\n-Dcom.sun.management.jmxremote.ssl=false\n```\n但是实际测试无法连接，经过查询资料，最后配置如下，实现了远程连接。\n```java\n(java -jar -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.rmi.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false app-1.0.jar&)\n```\n同时还需要注意服务器的端口是否被屏蔽，hosts是否配置了实际IP。可以使用hostname -i命令来查询ip是否生效。例如实际ip是10.10.10.101，计算机名是mycomputer。hosts配置如下：\n```java\n10.10.10.101   mycomputer\n10.10.10.101   localhost localhost.localdomain localhost4 localhost4.localdomain4\n```\n","source":"_posts/tool/JConsole的远程连接.md","raw":"---\ntitle: JConsole的远程连接\ndate: 2018-01-30 14:16:08\ntags: [工具,linux，java]\n---\n### JConsole介绍\nJConsole是JDK自带的Java性能分析器，用来监听Java应用程序性能和跟踪代码。默认安装在JDK的bin目录（例如：C:\\Program Files\\Java\\jdk1.8.0_144\\bin），直接双击运行即可。  \nJConsole可以监听本地的应用，也可以监听远程的应用。在新建连接界面上选择本地应用，或者输入远程连接地址，格式是ip:port，注意这个port是监听端口不是服务端口。\n![连接1.jpg](http://upload-images.jianshu.io/upload_images/4944427-73420e670c475117.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n连接完成后进入监听界面，可以查看内存、线程、类、JVM等相关信息。\n![监听1.jpg](http://upload-images.jianshu.io/upload_images/4944427-23976ac232a8d753.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 关于远程连接\n测试环境部署在RedHat6.5服务器上，一般说明增加如下参数即可允许远程连接。\n```java\n-Dcom.sun.management.jmxremote.port=8999\n-Dcom.sun.management.jmxremote.authenticate=false\n-Dcom.sun.management.jmxremote.ssl=false\n```\n但是实际测试无法连接，经过查询资料，最后配置如下，实现了远程连接。\n```java\n(java -jar -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=8999 -Dcom.sun.management.jmxremote.rmi.port=9999 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false app-1.0.jar&)\n```\n同时还需要注意服务器的端口是否被屏蔽，hosts是否配置了实际IP。可以使用hostname -i命令来查询ip是否生效。例如实际ip是10.10.10.101，计算机名是mycomputer。hosts配置如下：\n```java\n10.10.10.101   mycomputer\n10.10.10.101   localhost localhost.localdomain localhost4 localhost4.localdomain4\n```\n","slug":"tool/JConsole的远程连接","published":1,"updated":"2018-03-11T14:12:55.318Z","_id":"cjemvlvyl000dtccmag4vhotg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"JConsole介绍\"><a href=\"#JConsole介绍\" class=\"headerlink\" title=\"JConsole介绍\"></a>JConsole介绍</h3><p>JConsole是JDK自带的Java性能分析器，用来监听Java应用程序性能和跟踪代码。默认安装在JDK的bin目录（例如：C:\\Program Files\\Java\\jdk1.8.0_144\\bin），直接双击运行即可。<br>JConsole可以监听本地的应用，也可以监听远程的应用。在新建连接界面上选择本地应用，或者输入远程连接地址，格式是ip:port，注意这个port是监听端口不是服务端口。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-73420e670c475117.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"连接1.jpg\"></p>\n<p>连接完成后进入监听界面，可以查看内存、线程、类、JVM等相关信息。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-23976ac232a8d753.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"监听1.jpg\"></p>\n<h3 id=\"关于远程连接\"><a href=\"#关于远程连接\" class=\"headerlink\" title=\"关于远程连接\"></a>关于远程连接</h3><p>测试环境部署在RedHat6.5服务器上，一般说明增加如下参数即可允许远程连接。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dcom.sun.management.jmxremote.port=<span class=\"number\">8999</span></span><br><span class=\"line\">-Dcom.sun.management.jmxremote.authenticate=<span class=\"keyword\">false</span></span><br><span class=\"line\">-Dcom.sun.management.jmxremote.ssl=<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>但是实际测试无法连接，经过查询资料，最后配置如下，实现了远程连接。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(java -jar -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=<span class=\"number\">8999</span> -Dcom.sun.management.jmxremote.rmi.port=<span class=\"number\">9999</span> -Dcom.sun.management.jmxremote.ssl=<span class=\"keyword\">false</span> -Dcom.sun.management.jmxremote.authenticate=<span class=\"keyword\">false</span> app-<span class=\"number\">1.0</span>.jar&amp;)</span><br></pre></td></tr></table></figure></p>\n<p>同时还需要注意服务器的端口是否被屏蔽，hosts是否配置了实际IP。可以使用hostname -i命令来查询ip是否生效。例如实际ip是10.10.10.101，计算机名是mycomputer。hosts配置如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10.10</span>.10.101   mycomputer</span><br><span class=\"line\"><span class=\"number\">10.10</span>.10.101   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JConsole介绍\"><a href=\"#JConsole介绍\" class=\"headerlink\" title=\"JConsole介绍\"></a>JConsole介绍</h3><p>JConsole是JDK自带的Java性能分析器，用来监听Java应用程序性能和跟踪代码。默认安装在JDK的bin目录（例如：C:\\Program Files\\Java\\jdk1.8.0_144\\bin），直接双击运行即可。<br>JConsole可以监听本地的应用，也可以监听远程的应用。在新建连接界面上选择本地应用，或者输入远程连接地址，格式是ip:port，注意这个port是监听端口不是服务端口。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-73420e670c475117.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"连接1.jpg\"></p>\n<p>连接完成后进入监听界面，可以查看内存、线程、类、JVM等相关信息。<br><img src=\"http://upload-images.jianshu.io/upload_images/4944427-23976ac232a8d753.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"监听1.jpg\"></p>\n<h3 id=\"关于远程连接\"><a href=\"#关于远程连接\" class=\"headerlink\" title=\"关于远程连接\"></a>关于远程连接</h3><p>测试环境部署在RedHat6.5服务器上，一般说明增加如下参数即可允许远程连接。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dcom.sun.management.jmxremote.port=<span class=\"number\">8999</span></span><br><span class=\"line\">-Dcom.sun.management.jmxremote.authenticate=<span class=\"keyword\">false</span></span><br><span class=\"line\">-Dcom.sun.management.jmxremote.ssl=<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>但是实际测试无法连接，经过查询资料，最后配置如下，实现了远程连接。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(java -jar -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=<span class=\"number\">8999</span> -Dcom.sun.management.jmxremote.rmi.port=<span class=\"number\">9999</span> -Dcom.sun.management.jmxremote.ssl=<span class=\"keyword\">false</span> -Dcom.sun.management.jmxremote.authenticate=<span class=\"keyword\">false</span> app-<span class=\"number\">1.0</span>.jar&amp;)</span><br></pre></td></tr></table></figure></p>\n<p>同时还需要注意服务器的端口是否被屏蔽，hosts是否配置了实际IP。可以使用hostname -i命令来查询ip是否生效。例如实际ip是10.10.10.101，计算机名是mycomputer。hosts配置如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10.10</span>.10.101   mycomputer</span><br><span class=\"line\"><span class=\"number\">10.10</span>.10.101   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br></pre></td></tr></table></figure></p>\n"},{"title":"代码量统计存在的问题和对策","date":"2015-05-19T11:39:06.000Z","_content":"\n本文是针对当前业界代码量统计工具现状的分析以及对策。虽然用代码量来代表工作量历来被广大程序员所诟病，但是代码量数据背后确实能够反映出部分软件开发中存在的问题，特别是增量开发，以及维护旧版本的时候，代码增量是很重要的一项参考数据。\n# 代码量统计工具现状\n目前研发代码量统计使用的工具是TextDiff和diffcount，主要用于代码量的总量统计和增量统计。但是这两个工具的功能不完善，很多情况下存在统计错误的情况，导致代码量的度量不准确，甚至偏差很大。\n# 典型场景分析\n## 文件重命名\n这种情况实际代码没有变化，只是文件名变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。\n##文件移动\n这种情况实际代码没有变化，只是文件的存放位置变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。\n## 函数移动\n这种情况实际代码没有变化，只是函数在文件内部位置变化或者从文件1移动到文件2，代码变化应该统计为0.实际上两个工具都会认为原有函数被删除，又新增一个相同的函数。比如该函数是10行，统计结果就是新增10行，删除10行。\n删注释\n## 增删空格和换行\n## 子目录遍历\n## 代码总量统计\n上述情况下，这两个工具都存在统计不准确的情况。特别是随着敏捷的推进，不断强化代码的重构，这种情况会更加突出。度量的基础是数据，只有在原始数据准确的前提下，度量才有意义。\n\n|工具|有效代码行|函数移动位置|文件重命名|文件移动位置|增删注释|空格换行|子目录遍历|代码总量|\n|---|---|---|---|---|---|---|---|---|\n|textdiff|不算{}|X|X|X|X|X|X|X|\n|diffcount|算{}|X|X|X|X|X|√|√|\n#解决方案\n目前商用和开源代码量统计工具，均没有能完全解决上述问题的。建议自己开发工具。\n\n工具方案：将源代码解析成全局变量声明或者函数（类的方法）这一粒度后，进行比较。\t虽然上述方案能最大程度接近真实情况，但是由于实际代码变化的复杂性，不可能完全解析数代码的真实变化情况，还是会存在误差。\n","source":"_posts/tool/代码量统计存在的问题和对策.md","raw":"---\ntitle: 代码量统计存在的问题和对策\ndate: 2015-05-19 19:39:06\ntags: [工具]\n---\n\n本文是针对当前业界代码量统计工具现状的分析以及对策。虽然用代码量来代表工作量历来被广大程序员所诟病，但是代码量数据背后确实能够反映出部分软件开发中存在的问题，特别是增量开发，以及维护旧版本的时候，代码增量是很重要的一项参考数据。\n# 代码量统计工具现状\n目前研发代码量统计使用的工具是TextDiff和diffcount，主要用于代码量的总量统计和增量统计。但是这两个工具的功能不完善，很多情况下存在统计错误的情况，导致代码量的度量不准确，甚至偏差很大。\n# 典型场景分析\n## 文件重命名\n这种情况实际代码没有变化，只是文件名变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。\n##文件移动\n这种情况实际代码没有变化，只是文件的存放位置变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。\n## 函数移动\n这种情况实际代码没有变化，只是函数在文件内部位置变化或者从文件1移动到文件2，代码变化应该统计为0.实际上两个工具都会认为原有函数被删除，又新增一个相同的函数。比如该函数是10行，统计结果就是新增10行，删除10行。\n删注释\n## 增删空格和换行\n## 子目录遍历\n## 代码总量统计\n上述情况下，这两个工具都存在统计不准确的情况。特别是随着敏捷的推进，不断强化代码的重构，这种情况会更加突出。度量的基础是数据，只有在原始数据准确的前提下，度量才有意义。\n\n|工具|有效代码行|函数移动位置|文件重命名|文件移动位置|增删注释|空格换行|子目录遍历|代码总量|\n|---|---|---|---|---|---|---|---|---|\n|textdiff|不算{}|X|X|X|X|X|X|X|\n|diffcount|算{}|X|X|X|X|X|√|√|\n#解决方案\n目前商用和开源代码量统计工具，均没有能完全解决上述问题的。建议自己开发工具。\n\n工具方案：将源代码解析成全局变量声明或者函数（类的方法）这一粒度后，进行比较。\t虽然上述方案能最大程度接近真实情况，但是由于实际代码变化的复杂性，不可能完全解析数代码的真实变化情况，还是会存在误差。\n","slug":"tool/代码量统计存在的问题和对策","published":1,"updated":"2018-03-09T13:55:16.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl000gtccmyrmv3vta","content":"<p>本文是针对当前业界代码量统计工具现状的分析以及对策。虽然用代码量来代表工作量历来被广大程序员所诟病，但是代码量数据背后确实能够反映出部分软件开发中存在的问题，特别是增量开发，以及维护旧版本的时候，代码增量是很重要的一项参考数据。</p>\n<h1 id=\"代码量统计工具现状\"><a href=\"#代码量统计工具现状\" class=\"headerlink\" title=\"代码量统计工具现状\"></a>代码量统计工具现状</h1><p>目前研发代码量统计使用的工具是TextDiff和diffcount，主要用于代码量的总量统计和增量统计。但是这两个工具的功能不完善，很多情况下存在统计错误的情况，导致代码量的度量不准确，甚至偏差很大。</p>\n<h1 id=\"典型场景分析\"><a href=\"#典型场景分析\" class=\"headerlink\" title=\"典型场景分析\"></a>典型场景分析</h1><h2 id=\"文件重命名\"><a href=\"#文件重命名\" class=\"headerlink\" title=\"文件重命名\"></a>文件重命名</h2><p>这种情况实际代码没有变化，只是文件名变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。</p>\n<p>##文件移动<br>这种情况实际代码没有变化，只是文件的存放位置变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。</p>\n<h2 id=\"函数移动\"><a href=\"#函数移动\" class=\"headerlink\" title=\"函数移动\"></a>函数移动</h2><p>这种情况实际代码没有变化，只是函数在文件内部位置变化或者从文件1移动到文件2，代码变化应该统计为0.实际上两个工具都会认为原有函数被删除，又新增一个相同的函数。比如该函数是10行，统计结果就是新增10行，删除10行。<br>删注释</p>\n<h2 id=\"增删空格和换行\"><a href=\"#增删空格和换行\" class=\"headerlink\" title=\"增删空格和换行\"></a>增删空格和换行</h2><h2 id=\"子目录遍历\"><a href=\"#子目录遍历\" class=\"headerlink\" title=\"子目录遍历\"></a>子目录遍历</h2><h2 id=\"代码总量统计\"><a href=\"#代码总量统计\" class=\"headerlink\" title=\"代码总量统计\"></a>代码总量统计</h2><p>上述情况下，这两个工具都存在统计不准确的情况。特别是随着敏捷的推进，不断强化代码的重构，这种情况会更加突出。度量的基础是数据，只有在原始数据准确的前提下，度量才有意义。</p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>有效代码行</th>\n<th>函数移动位置</th>\n<th>文件重命名</th>\n<th>文件移动位置</th>\n<th>增删注释</th>\n<th>空格换行</th>\n<th>子目录遍历</th>\n<th>代码总量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>textdiff</td>\n<td>不算{}</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>diffcount</td>\n<td>算{}</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<p>#解决方案<br>目前商用和开源代码量统计工具，均没有能完全解决上述问题的。建议自己开发工具。</p>\n<p>工具方案：将源代码解析成全局变量声明或者函数（类的方法）这一粒度后，进行比较。    虽然上述方案能最大程度接近真实情况，但是由于实际代码变化的复杂性，不可能完全解析数代码的真实变化情况，还是会存在误差。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是针对当前业界代码量统计工具现状的分析以及对策。虽然用代码量来代表工作量历来被广大程序员所诟病，但是代码量数据背后确实能够反映出部分软件开发中存在的问题，特别是增量开发，以及维护旧版本的时候，代码增量是很重要的一项参考数据。</p>\n<h1 id=\"代码量统计工具现状\"><a href=\"#代码量统计工具现状\" class=\"headerlink\" title=\"代码量统计工具现状\"></a>代码量统计工具现状</h1><p>目前研发代码量统计使用的工具是TextDiff和diffcount，主要用于代码量的总量统计和增量统计。但是这两个工具的功能不完善，很多情况下存在统计错误的情况，导致代码量的度量不准确，甚至偏差很大。</p>\n<h1 id=\"典型场景分析\"><a href=\"#典型场景分析\" class=\"headerlink\" title=\"典型场景分析\"></a>典型场景分析</h1><h2 id=\"文件重命名\"><a href=\"#文件重命名\" class=\"headerlink\" title=\"文件重命名\"></a>文件重命名</h2><p>这种情况实际代码没有变化，只是文件名变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。</p>\n<p>##文件移动<br>这种情况实际代码没有变化，只是文件的存放位置变化，代码变化应该统计为0.实际上两个工具都会认为原有文件被删除，又新增文件。比如原文件1K，统计结果就是新增1K，删除1K。</p>\n<h2 id=\"函数移动\"><a href=\"#函数移动\" class=\"headerlink\" title=\"函数移动\"></a>函数移动</h2><p>这种情况实际代码没有变化，只是函数在文件内部位置变化或者从文件1移动到文件2，代码变化应该统计为0.实际上两个工具都会认为原有函数被删除，又新增一个相同的函数。比如该函数是10行，统计结果就是新增10行，删除10行。<br>删注释</p>\n<h2 id=\"增删空格和换行\"><a href=\"#增删空格和换行\" class=\"headerlink\" title=\"增删空格和换行\"></a>增删空格和换行</h2><h2 id=\"子目录遍历\"><a href=\"#子目录遍历\" class=\"headerlink\" title=\"子目录遍历\"></a>子目录遍历</h2><h2 id=\"代码总量统计\"><a href=\"#代码总量统计\" class=\"headerlink\" title=\"代码总量统计\"></a>代码总量统计</h2><p>上述情况下，这两个工具都存在统计不准确的情况。特别是随着敏捷的推进，不断强化代码的重构，这种情况会更加突出。度量的基础是数据，只有在原始数据准确的前提下，度量才有意义。</p>\n<table>\n<thead>\n<tr>\n<th>工具</th>\n<th>有效代码行</th>\n<th>函数移动位置</th>\n<th>文件重命名</th>\n<th>文件移动位置</th>\n<th>增删注释</th>\n<th>空格换行</th>\n<th>子目录遍历</th>\n<th>代码总量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>textdiff</td>\n<td>不算{}</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>diffcount</td>\n<td>算{}</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>X</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<p>#解决方案<br>目前商用和开源代码量统计工具，均没有能完全解决上述问题的。建议自己开发工具。</p>\n<p>工具方案：将源代码解析成全局变量声明或者函数（类的方法）这一粒度后，进行比较。    虽然上述方案能最大程度接近真实情况，但是由于实际代码变化的复杂性，不可能完全解析数代码的真实变化情况，还是会存在误差。</p>\n"},{"title":"linux上使用publickey访问gerrit异常","date":"2018-01-17T02:54:08.000Z","_content":"\n### 现象\nredhat上，先使用A账号，能正常执行相关操作。切换成B账号，上传public key后，执行异常：\n```\nAgent admitted failure to sign using the key.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n````\n### 解决办法\n执行完ssh-keygen再执行一下ssh-add\n```\nssh-keygen -t rsa -C \"mymail@my.com\"\nssh-add ~/.ssh/id_rsa\n```\n","source":"_posts/tool/linux上使用publickey访问gerrit异常.md","raw":"---\ntitle: linux上使用publickey访问gerrit异常\ndate: 2018-01-17 10:54:08\ntags: [工具,gerrit]\n---\n\n### 现象\nredhat上，先使用A账号，能正常执行相关操作。切换成B账号，上传public key后，执行异常：\n```\nAgent admitted failure to sign using the key.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\n````\n### 解决办法\n执行完ssh-keygen再执行一下ssh-add\n```\nssh-keygen -t rsa -C \"mymail@my.com\"\nssh-add ~/.ssh/id_rsa\n```\n","slug":"tool/linux上使用publickey访问gerrit异常","published":1,"updated":"2018-03-09T12:19:34.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvyl000itccmj24dldld","content":"<h3 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h3><p>redhat上，先使用A账号，能正常执行相关操作。切换成B账号，上传public key后，执行异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Agent admitted failure to sign using the key.</span><br><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>执行完ssh-keygen再执行一下ssh-add<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;mymail@my.com&quot;</span><br><span class=\"line\">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h3><p>redhat上，先使用A账号，能正常执行相关操作。切换成B账号，上传public key后，执行异常：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Agent admitted failure to sign using the key.</span><br><span class=\"line\">Permission denied (publickey).</span><br><span class=\"line\">fatal: Could not read from remote repository.</span><br><span class=\"line\"></span><br><span class=\"line\">Please make sure you have the correct access rights</span><br><span class=\"line\">and the repository exists.</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h3><p>执行完ssh-keygen再执行一下ssh-add<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;mymail@my.com&quot;</span><br><span class=\"line\">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p>\n"},{"title":"sublime如何设置不同语言的缩进","date":"2015-12-09T11:39:06.000Z","_content":"首先用sublime打开一个文件，比如要设置java语言的缩进，就打开一个java文件。\n\n菜单栏: Preferences -> Settings - More -> Syntax Specific - User，打开属性编辑页面，录入如下内容。保存即可\n```\n{\n    'tab_size': 2,\n    'translate_tabs_to_spaces': true \n}\n```\n\n注意：tab_size表示tab键转成几个空格，请根据自己团队的变成规范来设置。\n\n该设置文件会保存在如下路径\\Sublime Text 2.0.2\\Data\\Packages\\User。文件名为语言名+“.sublime-settings”后缀。比如java语言的配置文件就是Java.sublime-settings。","source":"_posts/tool/sublime如何设置不同语言的缩进.md","raw":"---\ntitle: sublime如何设置不同语言的缩进\ndate: 2015-12-09 19:39:06\ntags: [工具]\n---\n首先用sublime打开一个文件，比如要设置java语言的缩进，就打开一个java文件。\n\n菜单栏: Preferences -> Settings - More -> Syntax Specific - User，打开属性编辑页面，录入如下内容。保存即可\n```\n{\n    'tab_size': 2,\n    'translate_tabs_to_spaces': true \n}\n```\n\n注意：tab_size表示tab键转成几个空格，请根据自己团队的变成规范来设置。\n\n该设置文件会保存在如下路径\\Sublime Text 2.0.2\\Data\\Packages\\User。文件名为语言名+“.sublime-settings”后缀。比如java语言的配置文件就是Java.sublime-settings。","slug":"tool/sublime如何设置不同语言的缩进","published":1,"updated":"2018-03-11T14:14:46.625Z","_id":"cjemvlvz0000ltccmplzxmhit","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先用sublime打开一个文件，比如要设置java语言的缩进，就打开一个java文件。</p>\n<p>菜单栏: Preferences -&gt; Settings - More -&gt; Syntax Specific - User，打开属性编辑页面，录入如下内容。保存即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &apos;tab_size&apos;: 2,</span><br><span class=\"line\">    &apos;translate_tabs_to_spaces&apos;: true </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：tab_size表示tab键转成几个空格，请根据自己团队的变成规范来设置。</p>\n<p>该设置文件会保存在如下路径\\Sublime Text 2.0.2\\Data\\Packages\\User。文件名为语言名+“.sublime-settings”后缀。比如java语言的配置文件就是Java.sublime-settings。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先用sublime打开一个文件，比如要设置java语言的缩进，就打开一个java文件。</p>\n<p>菜单栏: Preferences -&gt; Settings - More -&gt; Syntax Specific - User，打开属性编辑页面，录入如下内容。保存即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &apos;tab_size&apos;: 2,</span><br><span class=\"line\">    &apos;translate_tabs_to_spaces&apos;: true </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：tab_size表示tab键转成几个空格，请根据自己团队的变成规范来设置。</p>\n<p>该设置文件会保存在如下路径\\Sublime Text 2.0.2\\Data\\Packages\\User。文件名为语言名+“.sublime-settings”后缀。比如java语言的配置文件就是Java.sublime-settings。</p>\n"},{"title":"企业知识管理","date":"2015-05-10T11:39:06.000Z","_content":"本文是三年前写的汇报材料上截取出来的干货，希望对您理解企业实施知识管理有所帮助。\n# 知识管理介绍\n## 什么是知识管理\n知识管理（KM）包括一系列企业内部定义、创建、传播、采用新的*知识*和*经验*的*战略*和*实践*。这些知识和经验包括认识，可以是**个人知识**，以及组织中**商业流程**或**实践**。知识管理的目的是把个人及组织得到的知识进行有效管理，提高企业效益、增强竞争优势、创新、分享教训、持续发展。\n## 为什么要实施知识管理\n1. **竞争**\n\t- 市场竞争越来越激烈，创新的速度加快，企业必须不断获得新知识，并利用新知识为企业和社会创造价值\n2. **顾客导向**\n\t- 企业要为客户创造价值\n3. **工作流动性**\n\t- 雇员的流动性加快如果企业不能很好地保存这些雇员所获得的知识，企业有失去其知识基础的风险\n4. **环境不确定性**\n\t- 在动态的不确定环境下，技术更新速度加快，学习已成为企业得以生存的根本保证\n5. **全球化的影响**\n\t- 全球化经营要求企业需具有较好的沟通能力以及知识获取、知识创造与知识转换的能力 \n\t\n## 知识管理的作用\n1. 提高组织智慧\n2. 提升组织记忆\n3. 减少重复劳动\n一个组织的学习能力，和将学习转化成行动的速度，将是他战胜竞争对手最终的关节优势。——杰克·韦尔奇\n![](https://upload-images.jianshu.io/upload_images/4944427-ce213fc446651d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 如何实施知识管理\n1. 把知识积累起来\n2. 把知识管理起来\n3. 把知识应用起来\n知识管理通过**积累**->**共享**->**学习**->**再利用**->**创新**->**积累**->……  ，不断的重复来实现的。\n![](https://upload-images.jianshu.io/upload_images/4944427-9f5e40e9217d8c22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 实施知识管理的步骤\n1. 认知——统一企业对知识管理的认知，梳理知识管理对企业管理的意义，评估企业的知识管理现状\n2. 规划——通过对知识管理现状、知识类型的详细分析，并结合业务流程等多角度，进行知识管理规划\n3. 试点——选取适当的部门和流程依照规划基础进行知识管理实践\n4. 推广和支持——知识管理将大规模在企业推广，以全面实现其价值\n5. 制度化——重新定义战略，并进行组织构架及业务流程的重组，准确评估知识管理在企业中实现的价值。\n\n## 知识管理在业界\n1. 联想在2003年就开始启动知识管理项目。\n2. 华为08年开始研发社区建设，10年成立公司层面的知识管理项目群，推进公司的全面知识管理。\n3. 西门子在上世纪90年代就开始组织和实施知识管理。\n4. GE在1989年发起了“群策群力”（Work-Out）活动，意在集中公司内外、上下各方面的智慧，培植、收集和实施好点子，集思广益，使员工们共享自己的知识，为公司带来效益。\n5. IBM 在1995年收购lotus后，将其打造成企业级通讯、协同工作及Internet/Intranet平台。\nIBM从自己的知识管理工作中受益匪浅：IBM自己统计的数据表明，截至2001年底，4年累积共节约资金57亿美元。\n\n# 现状分析\n## 无知和无序\n1. 员工头脑中的知识，*没有有效输出*形成显性知识，存在巨大的*浪费和丢失*的风险\n2. 埋头工作，无法及时获取到内外部知识，*能力提升慢，效率提升难*\n3 .各个部门各自为战，形成了一个个*信息孤岛*，不利于组织级的知识共享和改进\n![](https://upload-images.jianshu.io/upload_images/4944427-52adb140b28c6c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 实施方案\n## 提高认知\n1. 引起高层的关注\n2. 组建知识管理团队（有专职人员投入，吸引内部人员共建）\n3. 系统学习知识管理知识\n4. 引入外部咨询顾问\n5. 向业界学习优秀经验\n\n![](https://upload-images.jianshu.io/upload_images/4944427-33ef69d7d446fc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 开展规划\n1. 深入调研我司现状\n2. 挖掘出存在的问题和痛点\n3. 识别和梳理知识库、知识地图\n4. 组建知识管理系统开发团队\n5. 确定知识管理系统方案\n6. 开展迭代开发\n\n![](https://upload-images.jianshu.io/upload_images/4944427-ef93450e44abf802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 试点合作\n1. 招募天使用户\n2. 与用户合作，不断完善知识管理系统\n3. 评估实施效果\n\n![](https://upload-images.jianshu.io/upload_images/4944427-cf28a97314c27d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 推广和支持\n1. 面向更高一级层面全面推广\n2. 对各团队进行有效的支持\n3. 营造文化氛围\n\n![](https://upload-images.jianshu.io/upload_images/4944427-75601445f667d7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 制度化\n1. 总结和回顾\n2. 开展新的规划\n3. 面向公司层面推广\n4. 端到端的知识管理打通（销售-研发-生产-用服）\n\n![](https://upload-images.jianshu.io/upload_images/4944427-46d2aa6aa36de2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 知识管理系统方案\n## 知识管理系统总体框图\n支持个人、团队和组织三个维度的知识管理\n![](https://upload-images.jianshu.io/upload_images/4944427-c6edba9a02071197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 知识管理系统功能清单\n![](https://upload-images.jianshu.io/upload_images/4944427-73550188c87f4f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 知识管理系统使用场景描述\n我是爱岗敬业的员工，我在知识管理系统上能得到什么？\n\n![](https://upload-images.jianshu.io/upload_images/4944427-d63ca4ffbc504797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n听起来还不错，那对于部门来说，这个系统有什么作用。\n\n![](https://upload-images.jianshu.io/upload_images/4944427-2d4be00926d79bb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","source":"_posts/other/企业知识管理.md","raw":"---\ntitle: 企业知识管理\ndate: 2015-05-10 19:39:06\ntags: \n---\n本文是三年前写的汇报材料上截取出来的干货，希望对您理解企业实施知识管理有所帮助。\n# 知识管理介绍\n## 什么是知识管理\n知识管理（KM）包括一系列企业内部定义、创建、传播、采用新的*知识*和*经验*的*战略*和*实践*。这些知识和经验包括认识，可以是**个人知识**，以及组织中**商业流程**或**实践**。知识管理的目的是把个人及组织得到的知识进行有效管理，提高企业效益、增强竞争优势、创新、分享教训、持续发展。\n## 为什么要实施知识管理\n1. **竞争**\n\t- 市场竞争越来越激烈，创新的速度加快，企业必须不断获得新知识，并利用新知识为企业和社会创造价值\n2. **顾客导向**\n\t- 企业要为客户创造价值\n3. **工作流动性**\n\t- 雇员的流动性加快如果企业不能很好地保存这些雇员所获得的知识，企业有失去其知识基础的风险\n4. **环境不确定性**\n\t- 在动态的不确定环境下，技术更新速度加快，学习已成为企业得以生存的根本保证\n5. **全球化的影响**\n\t- 全球化经营要求企业需具有较好的沟通能力以及知识获取、知识创造与知识转换的能力 \n\t\n## 知识管理的作用\n1. 提高组织智慧\n2. 提升组织记忆\n3. 减少重复劳动\n一个组织的学习能力，和将学习转化成行动的速度，将是他战胜竞争对手最终的关节优势。——杰克·韦尔奇\n![](https://upload-images.jianshu.io/upload_images/4944427-ce213fc446651d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 如何实施知识管理\n1. 把知识积累起来\n2. 把知识管理起来\n3. 把知识应用起来\n知识管理通过**积累**->**共享**->**学习**->**再利用**->**创新**->**积累**->……  ，不断的重复来实现的。\n![](https://upload-images.jianshu.io/upload_images/4944427-9f5e40e9217d8c22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 实施知识管理的步骤\n1. 认知——统一企业对知识管理的认知，梳理知识管理对企业管理的意义，评估企业的知识管理现状\n2. 规划——通过对知识管理现状、知识类型的详细分析，并结合业务流程等多角度，进行知识管理规划\n3. 试点——选取适当的部门和流程依照规划基础进行知识管理实践\n4. 推广和支持——知识管理将大规模在企业推广，以全面实现其价值\n5. 制度化——重新定义战略，并进行组织构架及业务流程的重组，准确评估知识管理在企业中实现的价值。\n\n## 知识管理在业界\n1. 联想在2003年就开始启动知识管理项目。\n2. 华为08年开始研发社区建设，10年成立公司层面的知识管理项目群，推进公司的全面知识管理。\n3. 西门子在上世纪90年代就开始组织和实施知识管理。\n4. GE在1989年发起了“群策群力”（Work-Out）活动，意在集中公司内外、上下各方面的智慧，培植、收集和实施好点子，集思广益，使员工们共享自己的知识，为公司带来效益。\n5. IBM 在1995年收购lotus后，将其打造成企业级通讯、协同工作及Internet/Intranet平台。\nIBM从自己的知识管理工作中受益匪浅：IBM自己统计的数据表明，截至2001年底，4年累积共节约资金57亿美元。\n\n# 现状分析\n## 无知和无序\n1. 员工头脑中的知识，*没有有效输出*形成显性知识，存在巨大的*浪费和丢失*的风险\n2. 埋头工作，无法及时获取到内外部知识，*能力提升慢，效率提升难*\n3 .各个部门各自为战，形成了一个个*信息孤岛*，不利于组织级的知识共享和改进\n![](https://upload-images.jianshu.io/upload_images/4944427-52adb140b28c6c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 实施方案\n## 提高认知\n1. 引起高层的关注\n2. 组建知识管理团队（有专职人员投入，吸引内部人员共建）\n3. 系统学习知识管理知识\n4. 引入外部咨询顾问\n5. 向业界学习优秀经验\n\n![](https://upload-images.jianshu.io/upload_images/4944427-33ef69d7d446fc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 开展规划\n1. 深入调研我司现状\n2. 挖掘出存在的问题和痛点\n3. 识别和梳理知识库、知识地图\n4. 组建知识管理系统开发团队\n5. 确定知识管理系统方案\n6. 开展迭代开发\n\n![](https://upload-images.jianshu.io/upload_images/4944427-ef93450e44abf802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 试点合作\n1. 招募天使用户\n2. 与用户合作，不断完善知识管理系统\n3. 评估实施效果\n\n![](https://upload-images.jianshu.io/upload_images/4944427-cf28a97314c27d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 推广和支持\n1. 面向更高一级层面全面推广\n2. 对各团队进行有效的支持\n3. 营造文化氛围\n\n![](https://upload-images.jianshu.io/upload_images/4944427-75601445f667d7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 制度化\n1. 总结和回顾\n2. 开展新的规划\n3. 面向公司层面推广\n4. 端到端的知识管理打通（销售-研发-生产-用服）\n\n![](https://upload-images.jianshu.io/upload_images/4944427-46d2aa6aa36de2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n# 知识管理系统方案\n## 知识管理系统总体框图\n支持个人、团队和组织三个维度的知识管理\n![](https://upload-images.jianshu.io/upload_images/4944427-c6edba9a02071197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 知识管理系统功能清单\n![](https://upload-images.jianshu.io/upload_images/4944427-73550188c87f4f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 知识管理系统使用场景描述\n我是爱岗敬业的员工，我在知识管理系统上能得到什么？\n\n![](https://upload-images.jianshu.io/upload_images/4944427-d63ca4ffbc504797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n听起来还不错，那对于部门来说，这个系统有什么作用。\n\n![](https://upload-images.jianshu.io/upload_images/4944427-2d4be00926d79bb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n","slug":"other/企业知识管理","published":1,"updated":"2018-03-09T13:57:01.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvz0000ntccmpdfqrqiq","content":"<p>本文是三年前写的汇报材料上截取出来的干货，希望对您理解企业实施知识管理有所帮助。</p>\n<h1 id=\"知识管理介绍\"><a href=\"#知识管理介绍\" class=\"headerlink\" title=\"知识管理介绍\"></a>知识管理介绍</h1><h2 id=\"什么是知识管理\"><a href=\"#什么是知识管理\" class=\"headerlink\" title=\"什么是知识管理\"></a>什么是知识管理</h2><p>知识管理（KM）包括一系列企业内部定义、创建、传播、采用新的<em>知识</em>和<em>经验</em>的<em>战略</em>和<em>实践</em>。这些知识和经验包括认识，可以是<strong>个人知识</strong>，以及组织中<strong>商业流程</strong>或<strong>实践</strong>。知识管理的目的是把个人及组织得到的知识进行有效管理，提高企业效益、增强竞争优势、创新、分享教训、持续发展。</p>\n<h2 id=\"为什么要实施知识管理\"><a href=\"#为什么要实施知识管理\" class=\"headerlink\" title=\"为什么要实施知识管理\"></a>为什么要实施知识管理</h2><ol>\n<li><strong>竞争</strong><ul>\n<li>市场竞争越来越激烈，创新的速度加快，企业必须不断获得新知识，并利用新知识为企业和社会创造价值</li>\n</ul>\n</li>\n<li><strong>顾客导向</strong><ul>\n<li>企业要为客户创造价值</li>\n</ul>\n</li>\n<li><strong>工作流动性</strong><ul>\n<li>雇员的流动性加快如果企业不能很好地保存这些雇员所获得的知识，企业有失去其知识基础的风险</li>\n</ul>\n</li>\n<li><strong>环境不确定性</strong><ul>\n<li>在动态的不确定环境下，技术更新速度加快，学习已成为企业得以生存的根本保证</li>\n</ul>\n</li>\n<li><strong>全球化的影响</strong><ul>\n<li>全球化经营要求企业需具有较好的沟通能力以及知识获取、知识创造与知识转换的能力 </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"知识管理的作用\"><a href=\"#知识管理的作用\" class=\"headerlink\" title=\"知识管理的作用\"></a>知识管理的作用</h2><ol>\n<li>提高组织智慧</li>\n<li>提升组织记忆</li>\n<li>减少重复劳动<br>一个组织的学习能力，和将学习转化成行动的速度，将是他战胜竞争对手最终的关节优势。——杰克·韦尔奇<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-ce213fc446651d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h2 id=\"如何实施知识管理\"><a href=\"#如何实施知识管理\" class=\"headerlink\" title=\"如何实施知识管理\"></a>如何实施知识管理</h2><ol>\n<li>把知识积累起来</li>\n<li>把知识管理起来</li>\n<li>把知识应用起来<br>知识管理通过<strong>积累</strong>-&gt;<strong>共享</strong>-&gt;<strong>学习</strong>-&gt;<strong>再利用</strong>-&gt;<strong>创新</strong>-&gt;<strong>积累</strong>-&gt;……  ，不断的重复来实现的。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-9f5e40e9217d8c22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h2 id=\"实施知识管理的步骤\"><a href=\"#实施知识管理的步骤\" class=\"headerlink\" title=\"实施知识管理的步骤\"></a>实施知识管理的步骤</h2><ol>\n<li>认知——统一企业对知识管理的认知，梳理知识管理对企业管理的意义，评估企业的知识管理现状</li>\n<li>规划——通过对知识管理现状、知识类型的详细分析，并结合业务流程等多角度，进行知识管理规划</li>\n<li>试点——选取适当的部门和流程依照规划基础进行知识管理实践</li>\n<li>推广和支持——知识管理将大规模在企业推广，以全面实现其价值</li>\n<li>制度化——重新定义战略，并进行组织构架及业务流程的重组，准确评估知识管理在企业中实现的价值。</li>\n</ol>\n<h2 id=\"知识管理在业界\"><a href=\"#知识管理在业界\" class=\"headerlink\" title=\"知识管理在业界\"></a>知识管理在业界</h2><ol>\n<li>联想在2003年就开始启动知识管理项目。</li>\n<li>华为08年开始研发社区建设，10年成立公司层面的知识管理项目群，推进公司的全面知识管理。</li>\n<li>西门子在上世纪90年代就开始组织和实施知识管理。</li>\n<li>GE在1989年发起了“群策群力”（Work-Out）活动，意在集中公司内外、上下各方面的智慧，培植、收集和实施好点子，集思广益，使员工们共享自己的知识，为公司带来效益。</li>\n<li>IBM 在1995年收购lotus后，将其打造成企业级通讯、协同工作及Internet/Intranet平台。<br>IBM从自己的知识管理工作中受益匪浅：IBM自己统计的数据表明，截至2001年底，4年累积共节约资金57亿美元。</li>\n</ol>\n<h1 id=\"现状分析\"><a href=\"#现状分析\" class=\"headerlink\" title=\"现状分析\"></a>现状分析</h1><h2 id=\"无知和无序\"><a href=\"#无知和无序\" class=\"headerlink\" title=\"无知和无序\"></a>无知和无序</h2><ol>\n<li>员工头脑中的知识，<em>没有有效输出</em>形成显性知识，存在巨大的<em>浪费和丢失</em>的风险</li>\n<li>埋头工作，无法及时获取到内外部知识，<em>能力提升慢，效率提升难</em><br>3 .各个部门各自为战，形成了一个个<em>信息孤岛</em>，不利于组织级的知识共享和改进<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-52adb140b28c6c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h1 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h1><h2 id=\"提高认知\"><a href=\"#提高认知\" class=\"headerlink\" title=\"提高认知\"></a>提高认知</h2><ol>\n<li>引起高层的关注</li>\n<li>组建知识管理团队（有专职人员投入，吸引内部人员共建）</li>\n<li>系统学习知识管理知识</li>\n<li>引入外部咨询顾问</li>\n<li>向业界学习优秀经验</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-33ef69d7d446fc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"开展规划\"><a href=\"#开展规划\" class=\"headerlink\" title=\"开展规划\"></a>开展规划</h2><ol>\n<li>深入调研我司现状</li>\n<li>挖掘出存在的问题和痛点</li>\n<li>识别和梳理知识库、知识地图</li>\n<li>组建知识管理系统开发团队</li>\n<li>确定知识管理系统方案</li>\n<li>开展迭代开发</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-ef93450e44abf802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"试点合作\"><a href=\"#试点合作\" class=\"headerlink\" title=\"试点合作\"></a>试点合作</h2><ol>\n<li>招募天使用户</li>\n<li>与用户合作，不断完善知识管理系统</li>\n<li>评估实施效果</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-cf28a97314c27d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"推广和支持\"><a href=\"#推广和支持\" class=\"headerlink\" title=\"推广和支持\"></a>推广和支持</h2><ol>\n<li>面向更高一级层面全面推广</li>\n<li>对各团队进行有效的支持</li>\n<li>营造文化氛围</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-75601445f667d7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"制度化\"><a href=\"#制度化\" class=\"headerlink\" title=\"制度化\"></a>制度化</h2><ol>\n<li>总结和回顾</li>\n<li>开展新的规划</li>\n<li>面向公司层面推广</li>\n<li>端到端的知识管理打通（销售-研发-生产-用服）</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-46d2aa6aa36de2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"知识管理系统方案\"><a href=\"#知识管理系统方案\" class=\"headerlink\" title=\"知识管理系统方案\"></a>知识管理系统方案</h1><h2 id=\"知识管理系统总体框图\"><a href=\"#知识管理系统总体框图\" class=\"headerlink\" title=\"知识管理系统总体框图\"></a>知识管理系统总体框图</h2><p>支持个人、团队和组织三个维度的知识管理<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-c6edba9a02071197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"知识管理系统功能清单\"><a href=\"#知识管理系统功能清单\" class=\"headerlink\" title=\"知识管理系统功能清单\"></a>知识管理系统功能清单</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-73550188c87f4f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"知识管理系统使用场景描述\"><a href=\"#知识管理系统使用场景描述\" class=\"headerlink\" title=\"知识管理系统使用场景描述\"></a>知识管理系统使用场景描述</h2><p>我是爱岗敬业的员工，我在知识管理系统上能得到什么？</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-d63ca4ffbc504797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>听起来还不错，那对于部门来说，这个系统有什么作用。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-2d4be00926d79bb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是三年前写的汇报材料上截取出来的干货，希望对您理解企业实施知识管理有所帮助。</p>\n<h1 id=\"知识管理介绍\"><a href=\"#知识管理介绍\" class=\"headerlink\" title=\"知识管理介绍\"></a>知识管理介绍</h1><h2 id=\"什么是知识管理\"><a href=\"#什么是知识管理\" class=\"headerlink\" title=\"什么是知识管理\"></a>什么是知识管理</h2><p>知识管理（KM）包括一系列企业内部定义、创建、传播、采用新的<em>知识</em>和<em>经验</em>的<em>战略</em>和<em>实践</em>。这些知识和经验包括认识，可以是<strong>个人知识</strong>，以及组织中<strong>商业流程</strong>或<strong>实践</strong>。知识管理的目的是把个人及组织得到的知识进行有效管理，提高企业效益、增强竞争优势、创新、分享教训、持续发展。</p>\n<h2 id=\"为什么要实施知识管理\"><a href=\"#为什么要实施知识管理\" class=\"headerlink\" title=\"为什么要实施知识管理\"></a>为什么要实施知识管理</h2><ol>\n<li><strong>竞争</strong><ul>\n<li>市场竞争越来越激烈，创新的速度加快，企业必须不断获得新知识，并利用新知识为企业和社会创造价值</li>\n</ul>\n</li>\n<li><strong>顾客导向</strong><ul>\n<li>企业要为客户创造价值</li>\n</ul>\n</li>\n<li><strong>工作流动性</strong><ul>\n<li>雇员的流动性加快如果企业不能很好地保存这些雇员所获得的知识，企业有失去其知识基础的风险</li>\n</ul>\n</li>\n<li><strong>环境不确定性</strong><ul>\n<li>在动态的不确定环境下，技术更新速度加快，学习已成为企业得以生存的根本保证</li>\n</ul>\n</li>\n<li><strong>全球化的影响</strong><ul>\n<li>全球化经营要求企业需具有较好的沟通能力以及知识获取、知识创造与知识转换的能力 </li>\n</ul>\n</li>\n</ol>\n<h2 id=\"知识管理的作用\"><a href=\"#知识管理的作用\" class=\"headerlink\" title=\"知识管理的作用\"></a>知识管理的作用</h2><ol>\n<li>提高组织智慧</li>\n<li>提升组织记忆</li>\n<li>减少重复劳动<br>一个组织的学习能力，和将学习转化成行动的速度，将是他战胜竞争对手最终的关节优势。——杰克·韦尔奇<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-ce213fc446651d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h2 id=\"如何实施知识管理\"><a href=\"#如何实施知识管理\" class=\"headerlink\" title=\"如何实施知识管理\"></a>如何实施知识管理</h2><ol>\n<li>把知识积累起来</li>\n<li>把知识管理起来</li>\n<li>把知识应用起来<br>知识管理通过<strong>积累</strong>-&gt;<strong>共享</strong>-&gt;<strong>学习</strong>-&gt;<strong>再利用</strong>-&gt;<strong>创新</strong>-&gt;<strong>积累</strong>-&gt;……  ，不断的重复来实现的。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-9f5e40e9217d8c22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h2 id=\"实施知识管理的步骤\"><a href=\"#实施知识管理的步骤\" class=\"headerlink\" title=\"实施知识管理的步骤\"></a>实施知识管理的步骤</h2><ol>\n<li>认知——统一企业对知识管理的认知，梳理知识管理对企业管理的意义，评估企业的知识管理现状</li>\n<li>规划——通过对知识管理现状、知识类型的详细分析，并结合业务流程等多角度，进行知识管理规划</li>\n<li>试点——选取适当的部门和流程依照规划基础进行知识管理实践</li>\n<li>推广和支持——知识管理将大规模在企业推广，以全面实现其价值</li>\n<li>制度化——重新定义战略，并进行组织构架及业务流程的重组，准确评估知识管理在企业中实现的价值。</li>\n</ol>\n<h2 id=\"知识管理在业界\"><a href=\"#知识管理在业界\" class=\"headerlink\" title=\"知识管理在业界\"></a>知识管理在业界</h2><ol>\n<li>联想在2003年就开始启动知识管理项目。</li>\n<li>华为08年开始研发社区建设，10年成立公司层面的知识管理项目群，推进公司的全面知识管理。</li>\n<li>西门子在上世纪90年代就开始组织和实施知识管理。</li>\n<li>GE在1989年发起了“群策群力”（Work-Out）活动，意在集中公司内外、上下各方面的智慧，培植、收集和实施好点子，集思广益，使员工们共享自己的知识，为公司带来效益。</li>\n<li>IBM 在1995年收购lotus后，将其打造成企业级通讯、协同工作及Internet/Intranet平台。<br>IBM从自己的知识管理工作中受益匪浅：IBM自己统计的数据表明，截至2001年底，4年累积共节约资金57亿美元。</li>\n</ol>\n<h1 id=\"现状分析\"><a href=\"#现状分析\" class=\"headerlink\" title=\"现状分析\"></a>现状分析</h1><h2 id=\"无知和无序\"><a href=\"#无知和无序\" class=\"headerlink\" title=\"无知和无序\"></a>无知和无序</h2><ol>\n<li>员工头脑中的知识，<em>没有有效输出</em>形成显性知识，存在巨大的<em>浪费和丢失</em>的风险</li>\n<li>埋头工作，无法及时获取到内外部知识，<em>能力提升慢，效率提升难</em><br>3 .各个部门各自为战，形成了一个个<em>信息孤岛</em>，不利于组织级的知识共享和改进<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-52adb140b28c6c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ol>\n<h1 id=\"实施方案\"><a href=\"#实施方案\" class=\"headerlink\" title=\"实施方案\"></a>实施方案</h1><h2 id=\"提高认知\"><a href=\"#提高认知\" class=\"headerlink\" title=\"提高认知\"></a>提高认知</h2><ol>\n<li>引起高层的关注</li>\n<li>组建知识管理团队（有专职人员投入，吸引内部人员共建）</li>\n<li>系统学习知识管理知识</li>\n<li>引入外部咨询顾问</li>\n<li>向业界学习优秀经验</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-33ef69d7d446fc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"开展规划\"><a href=\"#开展规划\" class=\"headerlink\" title=\"开展规划\"></a>开展规划</h2><ol>\n<li>深入调研我司现状</li>\n<li>挖掘出存在的问题和痛点</li>\n<li>识别和梳理知识库、知识地图</li>\n<li>组建知识管理系统开发团队</li>\n<li>确定知识管理系统方案</li>\n<li>开展迭代开发</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-ef93450e44abf802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"试点合作\"><a href=\"#试点合作\" class=\"headerlink\" title=\"试点合作\"></a>试点合作</h2><ol>\n<li>招募天使用户</li>\n<li>与用户合作，不断完善知识管理系统</li>\n<li>评估实施效果</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-cf28a97314c27d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"推广和支持\"><a href=\"#推广和支持\" class=\"headerlink\" title=\"推广和支持\"></a>推广和支持</h2><ol>\n<li>面向更高一级层面全面推广</li>\n<li>对各团队进行有效的支持</li>\n<li>营造文化氛围</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-75601445f667d7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"制度化\"><a href=\"#制度化\" class=\"headerlink\" title=\"制度化\"></a>制度化</h2><ol>\n<li>总结和回顾</li>\n<li>开展新的规划</li>\n<li>面向公司层面推广</li>\n<li>端到端的知识管理打通（销售-研发-生产-用服）</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-46d2aa6aa36de2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"知识管理系统方案\"><a href=\"#知识管理系统方案\" class=\"headerlink\" title=\"知识管理系统方案\"></a>知识管理系统方案</h1><h2 id=\"知识管理系统总体框图\"><a href=\"#知识管理系统总体框图\" class=\"headerlink\" title=\"知识管理系统总体框图\"></a>知识管理系统总体框图</h2><p>支持个人、团队和组织三个维度的知识管理<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-c6edba9a02071197.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"知识管理系统功能清单\"><a href=\"#知识管理系统功能清单\" class=\"headerlink\" title=\"知识管理系统功能清单\"></a>知识管理系统功能清单</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-73550188c87f4f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"知识管理系统使用场景描述\"><a href=\"#知识管理系统使用场景描述\" class=\"headerlink\" title=\"知识管理系统使用场景描述\"></a>知识管理系统使用场景描述</h2><p>我是爱岗敬业的员工，我在知识管理系统上能得到什么？</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-d63ca4ffbc504797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>听起来还不错，那对于部门来说，这个系统有什么作用。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/4944427-2d4be00926d79bb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n"},{"title":"微信公众号开发","date":"2016-10-10T11:39:06.000Z","_content":"近日摸索了公众号的开发流程特记录下来，以供大家参考。\n首先最重要的是你的有一个公众号，具体怎么申请这里就不赘述了。嘿嘿，其实开发调试的时候可以使用临时的调试公众号，这样即使没有公众号也可以进行开发调试了。具体方法如下：打开http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。 然后用自己的微信扫一下，确认即可。系统会自动给你生成一个测试公众号，有简单的管理功能。\n![](https://upload-images.jianshu.io/upload_images/4944427-677420acba8c71f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n当然你也可以直接在公众号上进行开发调试。登陆公众号平台后，在左侧菜单底部，选择开发者中心，配置服务器信息（同测试账号）。如需加密可以设置秘钥，需注意，公众账号主动调用API的情况将不受影响。只有被动回复用户的消息时，才需要进行消息加解密。参考：http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\n![](https://upload-images.jianshu.io/upload_images/4944427-46a4784287b9f390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 服务端认证\n\n添加服务器URL后，微信服务器会向你的公众号服务器发送一个认证请求。比如你的微信服务URL是：http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&echostr=3942832202382810879&timestamp=1441531611&nonce=1839804127。公众号服务器校验流程入。\n\n1. 将token、timestamp、nonce三个参数进行字典序排序\n2. 将三个参数字符串拼接成一个字符串进行sha1加密\n3. 开发者获得加密后的字符串可与signature对比，如果相同则校验通过\n校验通过后，返回echostr参数的内容给微信服务器，完成认证。\n\n服务端PHP代码参考：http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。\n\nnodeJS代码参考：http://my.oschina.net/fengcunhan/blog/97367\n\n通过认证后，才能完成服务器的配置。\n\n\n\n# 消息接收和自动回复\n\n当用户向公众号发送消息时，微信服务器会自动讲消息转发到公众号服务器，发起一个post请求到http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html\n\nPHP使用$GLOBALS[\"HTTP_RAW_POST_DATA\"]获取消息内容。\n\nnodejs无法自己获取，需要执行读取操作：\n```\n var formData=\"\";\n     req.on(\"data\",function(data){\n     formData+=data;\n     });\n     req.on(\"end\",function(){\n     processMessage(formData,res);\n     });\n```\n\n# 通过API创建菜单\n\n首先向微信服务器发起一个get请求：\n\nhttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\n获取到access_token，然后发起创建菜单请求。POST（请使用https协议） https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN\n\n菜单信息以json格式封装。参考：http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html","source":"_posts/other/微信公众号开发.md","raw":"---\ntitle: 微信公众号开发\ndate: 2016-10-10 19:39:06\ntags: \n---\n近日摸索了公众号的开发流程特记录下来，以供大家参考。\n首先最重要的是你的有一个公众号，具体怎么申请这里就不赘述了。嘿嘿，其实开发调试的时候可以使用临时的调试公众号，这样即使没有公众号也可以进行开发调试了。具体方法如下：打开http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。 然后用自己的微信扫一下，确认即可。系统会自动给你生成一个测试公众号，有简单的管理功能。\n![](https://upload-images.jianshu.io/upload_images/4944427-677420acba8c71f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n当然你也可以直接在公众号上进行开发调试。登陆公众号平台后，在左侧菜单底部，选择开发者中心，配置服务器信息（同测试账号）。如需加密可以设置秘钥，需注意，公众账号主动调用API的情况将不受影响。只有被动回复用户的消息时，才需要进行消息加解密。参考：http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\n![](https://upload-images.jianshu.io/upload_images/4944427-46a4784287b9f390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n# 服务端认证\n\n添加服务器URL后，微信服务器会向你的公众号服务器发送一个认证请求。比如你的微信服务URL是：http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&echostr=3942832202382810879&timestamp=1441531611&nonce=1839804127。公众号服务器校验流程入。\n\n1. 将token、timestamp、nonce三个参数进行字典序排序\n2. 将三个参数字符串拼接成一个字符串进行sha1加密\n3. 开发者获得加密后的字符串可与signature对比，如果相同则校验通过\n校验通过后，返回echostr参数的内容给微信服务器，完成认证。\n\n服务端PHP代码参考：http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。\n\nnodeJS代码参考：http://my.oschina.net/fengcunhan/blog/97367\n\n通过认证后，才能完成服务器的配置。\n\n\n\n# 消息接收和自动回复\n\n当用户向公众号发送消息时，微信服务器会自动讲消息转发到公众号服务器，发起一个post请求到http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html\n\nPHP使用$GLOBALS[\"HTTP_RAW_POST_DATA\"]获取消息内容。\n\nnodejs无法自己获取，需要执行读取操作：\n```\n var formData=\"\";\n     req.on(\"data\",function(data){\n     formData+=data;\n     });\n     req.on(\"end\",function(){\n     processMessage(formData,res);\n     });\n```\n\n# 通过API创建菜单\n\n首先向微信服务器发起一个get请求：\n\nhttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\n获取到access_token，然后发起创建菜单请求。POST（请使用https协议） https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN\n\n菜单信息以json格式封装。参考：http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html","slug":"other/微信公众号开发","published":1,"updated":"2018-03-09T13:57:09.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvz0000qtccmxc9qn5qu","content":"<p>近日摸索了公众号的开发流程特记录下来，以供大家参考。<br>首先最重要的是你的有一个公众号，具体怎么申请这里就不赘述了。嘿嘿，其实开发调试的时候可以使用临时的调试公众号，这样即使没有公众号也可以进行开发调试了。具体方法如下：打开<a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。</a> 然后用自己的微信扫一下，确认即可。系统会自动给你生成一个测试公众号，有简单的管理功能。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-677420acba8c71f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当然你也可以直接在公众号上进行开发调试。登陆公众号平台后，在左侧菜单底部，选择开发者中心，配置服务器信息（同测试账号）。如需加密可以设置秘钥，需注意，公众账号主动调用API的情况将不受影响。只有被动回复用户的消息时，才需要进行消息加解密。参考：<a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html</a><br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-46a4784287b9f390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"服务端认证\"><a href=\"#服务端认证\" class=\"headerlink\" title=\"服务端认证\"></a>服务端认证</h1><p>添加服务器URL后，微信服务器会向你的公众号服务器发送一个认证请求。比如你的微信服务URL是：<a href=\"http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&amp;echostr=3942832202382810879&amp;timestamp=1441531611&amp;nonce=1839804127。公众号服务器校验流程入。\" target=\"_blank\" rel=\"noopener\">http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&amp;echostr=3942832202382810879&amp;timestamp=1441531611&amp;nonce=1839804127。公众号服务器校验流程入。</a></p>\n<ol>\n<li>将token、timestamp、nonce三个参数进行字典序排序</li>\n<li>将三个参数字符串拼接成一个字符串进行sha1加密</li>\n<li>开发者获得加密后的字符串可与signature对比，如果相同则校验通过<br>校验通过后，返回echostr参数的内容给微信服务器，完成认证。</li>\n</ol>\n<p>服务端PHP代码参考：<a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。</a></p>\n<p>nodeJS代码参考：<a href=\"http://my.oschina.net/fengcunhan/blog/97367\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/fengcunhan/blog/97367</a></p>\n<p>通过认证后，才能完成服务器的配置。</p>\n<h1 id=\"消息接收和自动回复\"><a href=\"#消息接收和自动回复\" class=\"headerlink\" title=\"消息接收和自动回复\"></a>消息接收和自动回复</h1><p>当用户向公众号发送消息时，微信服务器会自动讲消息转发到公众号服务器，发起一个post请求到<a href=\"http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html\" target=\"_blank\" rel=\"noopener\">http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html</a></p>\n<p>PHP使用$GLOBALS[“HTTP_RAW_POST_DATA”]获取消息内容。</p>\n<p>nodejs无法自己获取，需要执行读取操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var formData=&quot;&quot;;</span><br><span class=\"line\">    req.on(&quot;data&quot;,function(data)&#123;</span><br><span class=\"line\">    formData+=data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    req.on(&quot;end&quot;,function()&#123;</span><br><span class=\"line\">    processMessage(formData,res);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过API创建菜单\"><a href=\"#通过API创建菜单\" class=\"headerlink\" title=\"通过API创建菜单\"></a>通过API创建菜单</h1><p>首先向微信服务器发起一个get请求：</p>\n<p><a href=\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\" target=\"_blank\" rel=\"noopener\">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a><br>获取到access_token，然后发起创建菜单请求。POST（请使用https协议） <a href=\"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN\" target=\"_blank\" rel=\"noopener\">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN</a></p>\n<p>菜单信息以json格式封装。参考：<a href=\"http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>近日摸索了公众号的开发流程特记录下来，以供大家参考。<br>首先最重要的是你的有一个公众号，具体怎么申请这里就不赘述了。嘿嘿，其实开发调试的时候可以使用临时的调试公众号，这样即使没有公众号也可以进行开发调试了。具体方法如下：打开<a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login。</a> 然后用自己的微信扫一下，确认即可。系统会自动给你生成一个测试公众号，有简单的管理功能。<br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-677420acba8c71f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当然你也可以直接在公众号上进行开发调试。登陆公众号平台后，在左侧菜单底部，选择开发者中心，配置服务器信息（同测试账号）。如需加密可以设置秘钥，需注意，公众账号主动调用API的情况将不受影响。只有被动回复用户的消息时，才需要进行消息加解密。参考：<a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html</a><br><img src=\"https://upload-images.jianshu.io/upload_images/4944427-46a4784287b9f390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h1 id=\"服务端认证\"><a href=\"#服务端认证\" class=\"headerlink\" title=\"服务端认证\"></a>服务端认证</h1><p>添加服务器URL后，微信服务器会向你的公众号服务器发送一个认证请求。比如你的微信服务URL是：<a href=\"http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&amp;echostr=3942832202382810879&amp;timestamp=1441531611&amp;nonce=1839804127。公众号服务器校验流程入。\" target=\"_blank\" rel=\"noopener\">http://10.10.10.10/wx。微信服务器会发起一个get请求，http://10.10.10.10/wx/?signature=c4b6bed68f55e7bd09e2771674a1989619716054&amp;echostr=3942832202382810879&amp;timestamp=1441531611&amp;nonce=1839804127。公众号服务器校验流程入。</a></p>\n<ol>\n<li>将token、timestamp、nonce三个参数进行字典序排序</li>\n<li>将三个参数字符串拼接成一个字符串进行sha1加密</li>\n<li>开发者获得加密后的字符串可与signature对比，如果相同则校验通过<br>校验通过后，返回echostr参数的内容给微信服务器，完成认证。</li>\n</ol>\n<p>服务端PHP代码参考：<a href=\"http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/17/2d4265491f12608cd170a95559800f2d.html。</a></p>\n<p>nodeJS代码参考：<a href=\"http://my.oschina.net/fengcunhan/blog/97367\" target=\"_blank\" rel=\"noopener\">http://my.oschina.net/fengcunhan/blog/97367</a></p>\n<p>通过认证后，才能完成服务器的配置。</p>\n<h1 id=\"消息接收和自动回复\"><a href=\"#消息接收和自动回复\" class=\"headerlink\" title=\"消息接收和自动回复\"></a>消息接收和自动回复</h1><p>当用户向公众号发送消息时，微信服务器会自动讲消息转发到公众号服务器，发起一个post请求到<a href=\"http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html\" target=\"_blank\" rel=\"noopener\">http://10.10.10.10/wx。消息为xml字符串形式上传到服务器。公众号服务器解析出xml字符串中的消息类型，发送用户，以及发送的消息等信息。然后返回一个xml形式的字符串。API参考：http://mp.weixin.qq.com/wiki/10/79502792eef98d6e0c6e1739da387346.html</a></p>\n<p>PHP使用$GLOBALS[“HTTP_RAW_POST_DATA”]获取消息内容。</p>\n<p>nodejs无法自己获取，需要执行读取操作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var formData=&quot;&quot;;</span><br><span class=\"line\">    req.on(&quot;data&quot;,function(data)&#123;</span><br><span class=\"line\">    formData+=data;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    req.on(&quot;end&quot;,function()&#123;</span><br><span class=\"line\">    processMessage(formData,res);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"通过API创建菜单\"><a href=\"#通过API创建菜单\" class=\"headerlink\" title=\"通过API创建菜单\"></a>通过API创建菜单</h1><p>首先向微信服务器发起一个get请求：</p>\n<p><a href=\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET\" target=\"_blank\" rel=\"noopener\">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a><br>获取到access_token，然后发起创建菜单请求。POST（请使用https协议） <a href=\"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN\" target=\"_blank\" rel=\"noopener\">https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN</a></p>\n<p>菜单信息以json格式封装。参考：<a href=\"http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html\" target=\"_blank\" rel=\"noopener\">http://mp.weixin.qq.com/wiki/13/43de8269be54a0a6f64413e4dfa94f39.html</a></p>\n"},{"title":"重复代码检测工具","date":"2015-05-10T11:39:06.000Z","_content":"# 何谓重复代码\n简单说，就是指重复或近似的代码。程序猿在码代码时，往往使用CP（copy and paste）大法，飞快的完成开发任务。不经意间代码中充斥着大量的重复、相似的代码。重复代码不仅让代码量大增，造成编译速度慢，而且占用大量存储空间，更严重的后果是造成了代码可维护性差，代码质量下降。\n重复可能是软件中一切邪恶的根源，许多原则与实践规则都是为了控制与消除重复而创建。……软件开发领域的所有创新都是不断在尝试从源代码中消除重复。——《代码整洁之道》 马丁\n\n# 重复代码都有哪些类型？\n最简单明了的是完全一样的代码片段。此外，还有如下类型的重复代码:\n1. 类型Ⅰ，代码片段中除了空格、注释以及换行以外的内容完全一致\n2. 类型Ⅱ，代码片段中除了空格、注释、换行以及变量名以外的内容完全一致\n3. 类型Ⅲ，代码片段中除了空格、注释、换行以及变量名以外的语句可能有增删改，功能不变\n4. 类型Ⅳ，两个或更多个代码段执行相同的运算，但通过不同的语法和变量来实现。\n\n不同的重复代码检测工具，由于在实现算法上有所不同，其所能检测的重复代码类型也不尽相同，如下表所示。\n\n|名称|Simian|PMD-CPD|CloneDR|CCCD|CCFinder|Bauhaus|CodePro|\n| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |\n|检测类型|Ⅰ|Ⅰ，Ⅱ|Ⅰ，Ⅱ|Ⅰ，Ⅱ|Ⅰ|Ⅰ，Ⅱ，Ⅲ|Ⅰ，Ⅱ，Ⅲ|\n|支持语言|C/C++，Java|C/C++，Java|C/C++，Java|C，Java|C/C++，Java|C/C++，Java|Java|\n|授权类型|商用，可免费|开源|商用，可免费|开源|开源|商用，可免费|开源|\n|推荐星级|**|***|**|*|*|**|***|\n\n# 怎么消除重复代码?\n《代码大全》在第七章“高质量的子程序”中指出，创建子程序是消除重复代码的有效方法。\n在《重构——改善既有代码的设计》一书中，建议如下方法消除重复代码：\n1. 提取类，如果多个类中含有相同或相似的成员变量，方法，可以定义一个新的类来实现这些功能。原有的类可以作为子类继承。\n2. 提取函数，如果多个类中含有相同或相似的方法，可以把这些方法集中到新的类，供其他类调用。\n3. 替换函数，相同或相似的代码可以通过调用实现该功能的函数来实现。","source":"_posts/tool/重复代码检测工具.md","raw":"---\ntitle: 重复代码检测工具\ndate: 2015-05-10 19:39:06\ntags: [工具]\n---\n# 何谓重复代码\n简单说，就是指重复或近似的代码。程序猿在码代码时，往往使用CP（copy and paste）大法，飞快的完成开发任务。不经意间代码中充斥着大量的重复、相似的代码。重复代码不仅让代码量大增，造成编译速度慢，而且占用大量存储空间，更严重的后果是造成了代码可维护性差，代码质量下降。\n重复可能是软件中一切邪恶的根源，许多原则与实践规则都是为了控制与消除重复而创建。……软件开发领域的所有创新都是不断在尝试从源代码中消除重复。——《代码整洁之道》 马丁\n\n# 重复代码都有哪些类型？\n最简单明了的是完全一样的代码片段。此外，还有如下类型的重复代码:\n1. 类型Ⅰ，代码片段中除了空格、注释以及换行以外的内容完全一致\n2. 类型Ⅱ，代码片段中除了空格、注释、换行以及变量名以外的内容完全一致\n3. 类型Ⅲ，代码片段中除了空格、注释、换行以及变量名以外的语句可能有增删改，功能不变\n4. 类型Ⅳ，两个或更多个代码段执行相同的运算，但通过不同的语法和变量来实现。\n\n不同的重复代码检测工具，由于在实现算法上有所不同，其所能检测的重复代码类型也不尽相同，如下表所示。\n\n|名称|Simian|PMD-CPD|CloneDR|CCCD|CCFinder|Bauhaus|CodePro|\n| -------- | -------- | -------- | -------- | -------- | -------- | -------- | -------- |\n|检测类型|Ⅰ|Ⅰ，Ⅱ|Ⅰ，Ⅱ|Ⅰ，Ⅱ|Ⅰ|Ⅰ，Ⅱ，Ⅲ|Ⅰ，Ⅱ，Ⅲ|\n|支持语言|C/C++，Java|C/C++，Java|C/C++，Java|C，Java|C/C++，Java|C/C++，Java|Java|\n|授权类型|商用，可免费|开源|商用，可免费|开源|开源|商用，可免费|开源|\n|推荐星级|**|***|**|*|*|**|***|\n\n# 怎么消除重复代码?\n《代码大全》在第七章“高质量的子程序”中指出，创建子程序是消除重复代码的有效方法。\n在《重构——改善既有代码的设计》一书中，建议如下方法消除重复代码：\n1. 提取类，如果多个类中含有相同或相似的成员变量，方法，可以定义一个新的类来实现这些功能。原有的类可以作为子类继承。\n2. 提取函数，如果多个类中含有相同或相似的方法，可以把这些方法集中到新的类，供其他类调用。\n3. 替换函数，相同或相似的代码可以通过调用实现该功能的函数来实现。","slug":"tool/重复代码检测工具","published":1,"updated":"2018-03-09T13:41:18.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlvz0000stccmn1m7qtxt","content":"<h1 id=\"何谓重复代码\"><a href=\"#何谓重复代码\" class=\"headerlink\" title=\"何谓重复代码\"></a>何谓重复代码</h1><p>简单说，就是指重复或近似的代码。程序猿在码代码时，往往使用CP（copy and paste）大法，飞快的完成开发任务。不经意间代码中充斥着大量的重复、相似的代码。重复代码不仅让代码量大增，造成编译速度慢，而且占用大量存储空间，更严重的后果是造成了代码可维护性差，代码质量下降。<br>重复可能是软件中一切邪恶的根源，许多原则与实践规则都是为了控制与消除重复而创建。……软件开发领域的所有创新都是不断在尝试从源代码中消除重复。——《代码整洁之道》 马丁</p>\n<h1 id=\"重复代码都有哪些类型？\"><a href=\"#重复代码都有哪些类型？\" class=\"headerlink\" title=\"重复代码都有哪些类型？\"></a>重复代码都有哪些类型？</h1><p>最简单明了的是完全一样的代码片段。此外，还有如下类型的重复代码:</p>\n<ol>\n<li>类型Ⅰ，代码片段中除了空格、注释以及换行以外的内容完全一致</li>\n<li>类型Ⅱ，代码片段中除了空格、注释、换行以及变量名以外的内容完全一致</li>\n<li>类型Ⅲ，代码片段中除了空格、注释、换行以及变量名以外的语句可能有增删改，功能不变</li>\n<li>类型Ⅳ，两个或更多个代码段执行相同的运算，但通过不同的语法和变量来实现。</li>\n</ol>\n<p>不同的重复代码检测工具，由于在实现算法上有所不同，其所能检测的重复代码类型也不尽相同，如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>Simian</th>\n<th>PMD-CPD</th>\n<th>CloneDR</th>\n<th>CCCD</th>\n<th>CCFinder</th>\n<th>Bauhaus</th>\n<th>CodePro</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>检测类型</td>\n<td>Ⅰ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ</td>\n<td>Ⅰ，Ⅱ，Ⅲ</td>\n<td>Ⅰ，Ⅱ，Ⅲ</td>\n</tr>\n<tr>\n<td>支持语言</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>C，Java</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>Java</td>\n</tr>\n<tr>\n<td>授权类型</td>\n<td>商用，可免费</td>\n<td>开源</td>\n<td>商用，可免费</td>\n<td>开源</td>\n<td>开源</td>\n<td>商用，可免费</td>\n<td>开源</td>\n</tr>\n<tr>\n<td>推荐星级</td>\n<td>**</td>\n<td><em>*</em></td>\n<td>**</td>\n<td>*</td>\n<td>*</td>\n<td>**</td>\n<td><em>*</em></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"怎么消除重复代码\"><a href=\"#怎么消除重复代码\" class=\"headerlink\" title=\"怎么消除重复代码?\"></a>怎么消除重复代码?</h1><p>《代码大全》在第七章“高质量的子程序”中指出，创建子程序是消除重复代码的有效方法。<br>在《重构——改善既有代码的设计》一书中，建议如下方法消除重复代码：</p>\n<ol>\n<li>提取类，如果多个类中含有相同或相似的成员变量，方法，可以定义一个新的类来实现这些功能。原有的类可以作为子类继承。</li>\n<li>提取函数，如果多个类中含有相同或相似的方法，可以把这些方法集中到新的类，供其他类调用。</li>\n<li>替换函数，相同或相似的代码可以通过调用实现该功能的函数来实现。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"何谓重复代码\"><a href=\"#何谓重复代码\" class=\"headerlink\" title=\"何谓重复代码\"></a>何谓重复代码</h1><p>简单说，就是指重复或近似的代码。程序猿在码代码时，往往使用CP（copy and paste）大法，飞快的完成开发任务。不经意间代码中充斥着大量的重复、相似的代码。重复代码不仅让代码量大增，造成编译速度慢，而且占用大量存储空间，更严重的后果是造成了代码可维护性差，代码质量下降。<br>重复可能是软件中一切邪恶的根源，许多原则与实践规则都是为了控制与消除重复而创建。……软件开发领域的所有创新都是不断在尝试从源代码中消除重复。——《代码整洁之道》 马丁</p>\n<h1 id=\"重复代码都有哪些类型？\"><a href=\"#重复代码都有哪些类型？\" class=\"headerlink\" title=\"重复代码都有哪些类型？\"></a>重复代码都有哪些类型？</h1><p>最简单明了的是完全一样的代码片段。此外，还有如下类型的重复代码:</p>\n<ol>\n<li>类型Ⅰ，代码片段中除了空格、注释以及换行以外的内容完全一致</li>\n<li>类型Ⅱ，代码片段中除了空格、注释、换行以及变量名以外的内容完全一致</li>\n<li>类型Ⅲ，代码片段中除了空格、注释、换行以及变量名以外的语句可能有增删改，功能不变</li>\n<li>类型Ⅳ，两个或更多个代码段执行相同的运算，但通过不同的语法和变量来实现。</li>\n</ol>\n<p>不同的重复代码检测工具，由于在实现算法上有所不同，其所能检测的重复代码类型也不尽相同，如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>Simian</th>\n<th>PMD-CPD</th>\n<th>CloneDR</th>\n<th>CCCD</th>\n<th>CCFinder</th>\n<th>Bauhaus</th>\n<th>CodePro</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>检测类型</td>\n<td>Ⅰ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ，Ⅱ</td>\n<td>Ⅰ</td>\n<td>Ⅰ，Ⅱ，Ⅲ</td>\n<td>Ⅰ，Ⅱ，Ⅲ</td>\n</tr>\n<tr>\n<td>支持语言</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>C，Java</td>\n<td>C/C++，Java</td>\n<td>C/C++，Java</td>\n<td>Java</td>\n</tr>\n<tr>\n<td>授权类型</td>\n<td>商用，可免费</td>\n<td>开源</td>\n<td>商用，可免费</td>\n<td>开源</td>\n<td>开源</td>\n<td>商用，可免费</td>\n<td>开源</td>\n</tr>\n<tr>\n<td>推荐星级</td>\n<td>**</td>\n<td><em>*</em></td>\n<td>**</td>\n<td>*</td>\n<td>*</td>\n<td>**</td>\n<td><em>*</em></td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"怎么消除重复代码\"><a href=\"#怎么消除重复代码\" class=\"headerlink\" title=\"怎么消除重复代码?\"></a>怎么消除重复代码?</h1><p>《代码大全》在第七章“高质量的子程序”中指出，创建子程序是消除重复代码的有效方法。<br>在《重构——改善既有代码的设计》一书中，建议如下方法消除重复代码：</p>\n<ol>\n<li>提取类，如果多个类中含有相同或相似的成员变量，方法，可以定义一个新的类来实现这些功能。原有的类可以作为子类继承。</li>\n<li>提取函数，如果多个类中含有相同或相似的方法，可以把这些方法集中到新的类，供其他类调用。</li>\n<li>替换函数，相同或相似的代码可以通过调用实现该功能的函数来实现。</li>\n</ol>\n"},{"title":"Grunt--web前端构建工具","date":"2016-09-10T11:39:06.000Z","_content":"#简介\nGrunt是一款使用javascript开发的开源的web前端构建工具，有着丰富的给类工具插件。Grunt及其插件运行在node.js环境上。可以完成诸如：html/css/js/image文件的压缩和合并，html/css/js文件的静态检查，js的自动化测试，引入css/js文件的版本号自动更新，文件的删除和复制等等，web前端开发所需要的各类工作。\n\nGrunt官网：[http://gruntjs.com/](http://gruntjs.com/ \"http://gruntjs.com/\")\n\n非官方中文网站：[http://www.gruntjs.net/](http://www.gruntjs.net/ \"http://www.gruntjs.net/\")\n#Grunt的安装\nGrunt在node.js环境上执行，使用前必须先安装node.js和npm。\n##node.js的安装\n直接到官网下载安装包，执行安装即可。下载地址：[https://nodejs.org/en/](https://nodejs.org/en/)\n\n安装了node.js之后，打开命令行控制台，输入“node -v”来查看node。js的版本，已验证node.js是否安装成功。npm集成在node.js的安装包，安装完node.js即可。输入“npm -v”，查看npm版本。\n\n##Grunt的安装\n由于npm经常被墙，导致无法安装成功。幸好我们有了中兴自己的镜像。\n执行“npm set registry http://mirrors.zte.com.cn/npm” 配置好镜像后，就能顺利完成安装了。执行“npm install -g grunt-cli” 安装Grunt，注意安装的是grunt-cli，-g表示全局安装，所有目录均可使用\n\n安装完成后，执行“grunt -v”。验证安装是否成功。\n\n#Grunt插件的安装\n安装Grunt插件的时候可以采用两种方式，一种是单个插件安装（常用于新搭建项目的场景）；一种是插件批量安装（常用于下载项目文件后搭建开发环境）。具体安装方法如下：\n1. 安装单个插件\n\t首先在命令行控制台里，切换到项目根目录。例如安装jshint插件，执行“npm install grunt-contrib-jshint --save-dev”命令即可。\n\n2. 批量安装\n\t首先新建package.json文件。将需要安装的插件名称和版本填写好（如果是配置库上下载，已有配置文件，此步骤跳过）。详细内容参考下一小节。\n\t命令行控制台切换到项目根目录。执行“npm install --save-dev”命令即可。执行成功后，根目录下会出现node_modules目录，下面会出现已安装的所有插件。\n##package.json配置文件\n配置具体示例如下：\n```javascript\n{\n  \"name\": \"wxcop\",\n  \"version\": \"0.1.0\",\n  \"devDependencies\": {\n    \"grunt\": \"^0.4.5\",\n    \"grunt-contrib-clean\": \"^0.6.0\",\n    \"grunt-contrib-copy\": \"^0.8.2\",\n    \"grunt-contrib-cssmin\": \"^0.14.0\",\n    \"grunt-contrib-jshint\": \"^0.11.3\",\n    \"grunt-contrib-uglify\": \"^0.9.2\"\n  }\n}\n```\n示例中name为当前工程名称，version工程版本信息，devDependencies为依赖项（即Grunt和相关插件）。注意，这里的版本号前面有一个^符号，表示该插件可以被Grunt自动更新到最新的子版本。\n关于配置文件的说明，详见：[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)\n#配置构建任务\n在项目根目录下新建构建任务描述文件Gruntfile.js。具体示例如下：\n```javascript\nmodule.exports = function(grunt) {  \n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),   //加载配置文件 \n    uglify: {\n      options: { },\n      buildall: {//按原文件结构压缩js文件夹内所有js文件\n          options: {\n            preserveComments:false,\n            report: \"min\"//输出压缩率，可选的值有 false(不输出信息)，gzip\n          },\n          files: [{\n              compress:false,\n              expand:true,\n              cwd:'js',//js目录下\n              src:'**/*.js',//所有js文件\n              dest: 'dist/js'//输出到此目录下\n          }]\n      },\n      ueditor: {//单独压缩ueditor.all.js文件\n          options: {\n            preserveComments:false,\n            report: \"min\"\n          },\n          files: [{\n              compress:false,\n              src:'vender/ueditor/ueditor.all.js',\n              dest: 'vender/ueditor/ueditor.all.min.js'\n          }]\n      }\n    },\n    cssmin: {\n      compress: {//按原文件结构压缩css文件夹内所有css文件\n        files: [{\n               expand: true,\n               cwd: 'css/',\n               src: '**/*.css',\n               dest: 'dist/css'\n         }]\n      },\n      adminlte: {//单独压缩AdminLTE.css文件\n          files: [{\n              src:'vender/AdminLTE/AdminLTE.css',\n              dest: 'vender/AdminLTE/AdminLTE.min.css'\n          }]\n      }\n    }  \n  });\n  // 加载包含 \"uglify\" 任务的插件。\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-cssmin');\n  // 默认被执行的任务列表。\n  grunt.registerTask('default', ['uglify','cssmin:compress','cssmin:adminlte']);\n};\n```\n上述代码实现了js目录下所有js文件的压缩，css目录下的所有css文件的压缩。文件主题是module.exports = function(grunt) { };函数内部主要有三部分：初始化参数，加载插件，注册构建任务。\n1. 初始化参数\n\tpkg属性，指定具体加载的配置文件，默认的必选项。uglify和cssmin是自己定义的任务，名称也是自定义的。\n2. 加载插件\n\t加载指定的插件。\n3. 注册构建任务\n\tdefault是任务名称，[]中是具体构建项，按照先后顺序执行。可以是一个任务集合'uglify',也可以是一个具体的任务'cssmin:compress'。\n#执行构建\n在命令行控制台里，切换到项目根目录。执行grunt，即可执行default任务。执行“grunt cssmin:adminlte”，即可执行具体的一个任务。执行“grunt uglify”即可执行一个任务集合。\n\n这里只是对grunt的一个概括介绍，配置的详细参数，具体插件的配置，后续在其他帖子里描述。","source":"_posts/FE/engineering/Grunt--web前端构建工具.md","raw":"---\ntitle: Grunt--web前端构建工具\ndate: 2016-09-10 19:39:06\ntags: [工具]\n---\n#简介\nGrunt是一款使用javascript开发的开源的web前端构建工具，有着丰富的给类工具插件。Grunt及其插件运行在node.js环境上。可以完成诸如：html/css/js/image文件的压缩和合并，html/css/js文件的静态检查，js的自动化测试，引入css/js文件的版本号自动更新，文件的删除和复制等等，web前端开发所需要的各类工作。\n\nGrunt官网：[http://gruntjs.com/](http://gruntjs.com/ \"http://gruntjs.com/\")\n\n非官方中文网站：[http://www.gruntjs.net/](http://www.gruntjs.net/ \"http://www.gruntjs.net/\")\n#Grunt的安装\nGrunt在node.js环境上执行，使用前必须先安装node.js和npm。\n##node.js的安装\n直接到官网下载安装包，执行安装即可。下载地址：[https://nodejs.org/en/](https://nodejs.org/en/)\n\n安装了node.js之后，打开命令行控制台，输入“node -v”来查看node。js的版本，已验证node.js是否安装成功。npm集成在node.js的安装包，安装完node.js即可。输入“npm -v”，查看npm版本。\n\n##Grunt的安装\n由于npm经常被墙，导致无法安装成功。幸好我们有了中兴自己的镜像。\n执行“npm set registry http://mirrors.zte.com.cn/npm” 配置好镜像后，就能顺利完成安装了。执行“npm install -g grunt-cli” 安装Grunt，注意安装的是grunt-cli，-g表示全局安装，所有目录均可使用\n\n安装完成后，执行“grunt -v”。验证安装是否成功。\n\n#Grunt插件的安装\n安装Grunt插件的时候可以采用两种方式，一种是单个插件安装（常用于新搭建项目的场景）；一种是插件批量安装（常用于下载项目文件后搭建开发环境）。具体安装方法如下：\n1. 安装单个插件\n\t首先在命令行控制台里，切换到项目根目录。例如安装jshint插件，执行“npm install grunt-contrib-jshint --save-dev”命令即可。\n\n2. 批量安装\n\t首先新建package.json文件。将需要安装的插件名称和版本填写好（如果是配置库上下载，已有配置文件，此步骤跳过）。详细内容参考下一小节。\n\t命令行控制台切换到项目根目录。执行“npm install --save-dev”命令即可。执行成功后，根目录下会出现node_modules目录，下面会出现已安装的所有插件。\n##package.json配置文件\n配置具体示例如下：\n```javascript\n{\n  \"name\": \"wxcop\",\n  \"version\": \"0.1.0\",\n  \"devDependencies\": {\n    \"grunt\": \"^0.4.5\",\n    \"grunt-contrib-clean\": \"^0.6.0\",\n    \"grunt-contrib-copy\": \"^0.8.2\",\n    \"grunt-contrib-cssmin\": \"^0.14.0\",\n    \"grunt-contrib-jshint\": \"^0.11.3\",\n    \"grunt-contrib-uglify\": \"^0.9.2\"\n  }\n}\n```\n示例中name为当前工程名称，version工程版本信息，devDependencies为依赖项（即Grunt和相关插件）。注意，这里的版本号前面有一个^符号，表示该插件可以被Grunt自动更新到最新的子版本。\n关于配置文件的说明，详见：[https://docs.npmjs.com/files/package.json](https://docs.npmjs.com/files/package.json)\n#配置构建任务\n在项目根目录下新建构建任务描述文件Gruntfile.js。具体示例如下：\n```javascript\nmodule.exports = function(grunt) {  \n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),   //加载配置文件 \n    uglify: {\n      options: { },\n      buildall: {//按原文件结构压缩js文件夹内所有js文件\n          options: {\n            preserveComments:false,\n            report: \"min\"//输出压缩率，可选的值有 false(不输出信息)，gzip\n          },\n          files: [{\n              compress:false,\n              expand:true,\n              cwd:'js',//js目录下\n              src:'**/*.js',//所有js文件\n              dest: 'dist/js'//输出到此目录下\n          }]\n      },\n      ueditor: {//单独压缩ueditor.all.js文件\n          options: {\n            preserveComments:false,\n            report: \"min\"\n          },\n          files: [{\n              compress:false,\n              src:'vender/ueditor/ueditor.all.js',\n              dest: 'vender/ueditor/ueditor.all.min.js'\n          }]\n      }\n    },\n    cssmin: {\n      compress: {//按原文件结构压缩css文件夹内所有css文件\n        files: [{\n               expand: true,\n               cwd: 'css/',\n               src: '**/*.css',\n               dest: 'dist/css'\n         }]\n      },\n      adminlte: {//单独压缩AdminLTE.css文件\n          files: [{\n              src:'vender/AdminLTE/AdminLTE.css',\n              dest: 'vender/AdminLTE/AdminLTE.min.css'\n          }]\n      }\n    }  \n  });\n  // 加载包含 \"uglify\" 任务的插件。\n  grunt.loadNpmTasks('grunt-contrib-uglify');\n  grunt.loadNpmTasks('grunt-contrib-cssmin');\n  // 默认被执行的任务列表。\n  grunt.registerTask('default', ['uglify','cssmin:compress','cssmin:adminlte']);\n};\n```\n上述代码实现了js目录下所有js文件的压缩，css目录下的所有css文件的压缩。文件主题是module.exports = function(grunt) { };函数内部主要有三部分：初始化参数，加载插件，注册构建任务。\n1. 初始化参数\n\tpkg属性，指定具体加载的配置文件，默认的必选项。uglify和cssmin是自己定义的任务，名称也是自定义的。\n2. 加载插件\n\t加载指定的插件。\n3. 注册构建任务\n\tdefault是任务名称，[]中是具体构建项，按照先后顺序执行。可以是一个任务集合'uglify',也可以是一个具体的任务'cssmin:compress'。\n#执行构建\n在命令行控制台里，切换到项目根目录。执行grunt，即可执行default任务。执行“grunt cssmin:adminlte”，即可执行具体的一个任务。执行“grunt uglify”即可执行一个任务集合。\n\n这里只是对grunt的一个概括介绍，配置的详细参数，具体插件的配置，后续在其他帖子里描述。","slug":"FE/engineering/Grunt--web前端构建工具","published":1,"updated":"2018-03-11T07:17:45.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b0012tccm75m9ugn4","content":"<p>#简介<br>Grunt是一款使用javascript开发的开源的web前端构建工具，有着丰富的给类工具插件。Grunt及其插件运行在node.js环境上。可以完成诸如：html/css/js/image文件的压缩和合并，html/css/js文件的静态检查，js的自动化测试，引入css/js文件的版本号自动更新，文件的删除和复制等等，web前端开发所需要的各类工作。</p>\n<p>Grunt官网：<a href=\"http://gruntjs.com/\" title=\"http://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">http://gruntjs.com/</a></p>\n<p>非官方中文网站：<a href=\"http://www.gruntjs.net/\" title=\"http://www.gruntjs.net/\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/</a></p>\n<p>#Grunt的安装<br>Grunt在node.js环境上执行，使用前必须先安装node.js和npm。</p>\n<p>##node.js的安装<br>直接到官网下载安装包，执行安装即可。下载地址：<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a></p>\n<p>安装了node.js之后，打开命令行控制台，输入“node -v”来查看node。js的版本，已验证node.js是否安装成功。npm集成在node.js的安装包，安装完node.js即可。输入“npm -v”，查看npm版本。</p>\n<p>##Grunt的安装<br>由于npm经常被墙，导致无法安装成功。幸好我们有了中兴自己的镜像。<br>执行“npm set registry <a href=\"http://mirrors.zte.com.cn/npm”\" target=\"_blank\" rel=\"noopener\">http://mirrors.zte.com.cn/npm”</a> 配置好镜像后，就能顺利完成安装了。执行“npm install -g grunt-cli” 安装Grunt，注意安装的是grunt-cli，-g表示全局安装，所有目录均可使用</p>\n<p>安装完成后，执行“grunt -v”。验证安装是否成功。</p>\n<p>#Grunt插件的安装<br>安装Grunt插件的时候可以采用两种方式，一种是单个插件安装（常用于新搭建项目的场景）；一种是插件批量安装（常用于下载项目文件后搭建开发环境）。具体安装方法如下：</p>\n<ol>\n<li><p>安装单个插件<br> 首先在命令行控制台里，切换到项目根目录。例如安装jshint插件，执行“npm install grunt-contrib-jshint –save-dev”命令即可。</p>\n</li>\n<li><p>批量安装<br> 首先新建package.json文件。将需要安装的插件名称和版本填写好（如果是配置库上下载，已有配置文件，此步骤跳过）。详细内容参考下一小节。<br> 命令行控制台切换到项目根目录。执行“npm install –save-dev”命令即可。执行成功后，根目录下会出现node_modules目录，下面会出现已安装的所有插件。<br>##package.json配置文件<br>配置具体示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"wxcop\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"^0.4.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-clean\"</span>: <span class=\"string\">\"^0.6.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-copy\"</span>: <span class=\"string\">\"^0.8.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-cssmin\"</span>: <span class=\"string\">\"^0.14.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-jshint\"</span>: <span class=\"string\">\"^0.11.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-uglify\"</span>: <span class=\"string\">\"^0.9.2\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>示例中name为当前工程名称，version工程版本信息，devDependencies为依赖项（即Grunt和相关插件）。注意，这里的版本号前面有一个^符号，表示该插件可以被Grunt自动更新到最新的子版本。<br>关于配置文件的说明，详见：<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/files/package.json</a></p>\n<p>#配置构建任务<br>在项目根目录下新建构建任务描述文件Gruntfile.js。具体示例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">grunt</span>) </span>&#123;  </span><br><span class=\"line\">  grunt.initConfig(&#123;</span><br><span class=\"line\">    pkg: grunt.file.readJSON(<span class=\"string\">'package.json'</span>),   <span class=\"comment\">//加载配置文件 </span></span><br><span class=\"line\">    uglify: &#123;</span><br><span class=\"line\">      options: &#123; &#125;,</span><br><span class=\"line\">      buildall: &#123;<span class=\"comment\">//按原文件结构压缩js文件夹内所有js文件</span></span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            preserveComments:<span class=\"literal\">false</span>,</span><br><span class=\"line\">            report: <span class=\"string\">\"min\"</span><span class=\"comment\">//输出压缩率，可选的值有 false(不输出信息)，gzip</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              compress:<span class=\"literal\">false</span>,</span><br><span class=\"line\">              expand:<span class=\"literal\">true</span>,</span><br><span class=\"line\">              cwd:<span class=\"string\">'js'</span>,<span class=\"comment\">//js目录下</span></span><br><span class=\"line\">              src:<span class=\"string\">'**/*.js'</span>,<span class=\"comment\">//所有js文件</span></span><br><span class=\"line\">              dest: <span class=\"string\">'dist/js'</span><span class=\"comment\">//输出到此目录下</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ueditor: &#123;<span class=\"comment\">//单独压缩ueditor.all.js文件</span></span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            preserveComments:<span class=\"literal\">false</span>,</span><br><span class=\"line\">            report: <span class=\"string\">\"min\"</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              compress:<span class=\"literal\">false</span>,</span><br><span class=\"line\">              src:<span class=\"string\">'vender/ueditor/ueditor.all.js'</span>,</span><br><span class=\"line\">              dest: <span class=\"string\">'vender/ueditor/ueditor.all.min.js'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cssmin: &#123;</span><br><span class=\"line\">      compress: &#123;<span class=\"comment\">//按原文件结构压缩css文件夹内所有css文件</span></span><br><span class=\"line\">        files: [&#123;</span><br><span class=\"line\">               expand: <span class=\"literal\">true</span>,</span><br><span class=\"line\">               cwd: <span class=\"string\">'css/'</span>,</span><br><span class=\"line\">               src: <span class=\"string\">'**/*.css'</span>,</span><br><span class=\"line\">               dest: <span class=\"string\">'dist/css'</span></span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      adminlte: &#123;<span class=\"comment\">//单独压缩AdminLTE.css文件</span></span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              src:<span class=\"string\">'vender/AdminLTE/AdminLTE.css'</span>,</span><br><span class=\"line\">              dest: <span class=\"string\">'vender/AdminLTE/AdminLTE.min.css'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 加载包含 \"uglify\" 任务的插件。</span></span><br><span class=\"line\">  grunt.loadNpmTasks(<span class=\"string\">'grunt-contrib-uglify'</span>);</span><br><span class=\"line\">  grunt.loadNpmTasks(<span class=\"string\">'grunt-contrib-cssmin'</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 默认被执行的任务列表。</span></span><br><span class=\"line\">  grunt.registerTask(<span class=\"string\">'default'</span>, [<span class=\"string\">'uglify'</span>,<span class=\"string\">'cssmin:compress'</span>,<span class=\"string\">'cssmin:adminlte'</span>]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码实现了js目录下所有js文件的压缩，css目录下的所有css文件的压缩。文件主题是module.exports = function(grunt) { };函数内部主要有三部分：初始化参数，加载插件，注册构建任务。</p>\n<ol>\n<li>初始化参数<br> pkg属性，指定具体加载的配置文件，默认的必选项。uglify和cssmin是自己定义的任务，名称也是自定义的。</li>\n<li>加载插件<br> 加载指定的插件。</li>\n<li>注册构建任务<br> default是任务名称，[]中是具体构建项，按照先后顺序执行。可以是一个任务集合’uglify’,也可以是一个具体的任务’cssmin:compress’。<br>#执行构建<br>在命令行控制台里，切换到项目根目录。执行grunt，即可执行default任务。执行“grunt cssmin:adminlte”，即可执行具体的一个任务。执行“grunt uglify”即可执行一个任务集合。</li>\n</ol>\n<p>这里只是对grunt的一个概括介绍，配置的详细参数，具体插件的配置，后续在其他帖子里描述。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#简介<br>Grunt是一款使用javascript开发的开源的web前端构建工具，有着丰富的给类工具插件。Grunt及其插件运行在node.js环境上。可以完成诸如：html/css/js/image文件的压缩和合并，html/css/js文件的静态检查，js的自动化测试，引入css/js文件的版本号自动更新，文件的删除和复制等等，web前端开发所需要的各类工作。</p>\n<p>Grunt官网：<a href=\"http://gruntjs.com/\" title=\"http://gruntjs.com/\" target=\"_blank\" rel=\"noopener\">http://gruntjs.com/</a></p>\n<p>非官方中文网站：<a href=\"http://www.gruntjs.net/\" title=\"http://www.gruntjs.net/\" target=\"_blank\" rel=\"noopener\">http://www.gruntjs.net/</a></p>\n<p>#Grunt的安装<br>Grunt在node.js环境上执行，使用前必须先安装node.js和npm。</p>\n<p>##node.js的安装<br>直接到官网下载安装包，执行安装即可。下载地址：<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/</a></p>\n<p>安装了node.js之后，打开命令行控制台，输入“node -v”来查看node。js的版本，已验证node.js是否安装成功。npm集成在node.js的安装包，安装完node.js即可。输入“npm -v”，查看npm版本。</p>\n<p>##Grunt的安装<br>由于npm经常被墙，导致无法安装成功。幸好我们有了中兴自己的镜像。<br>执行“npm set registry <a href=\"http://mirrors.zte.com.cn/npm”\" target=\"_blank\" rel=\"noopener\">http://mirrors.zte.com.cn/npm”</a> 配置好镜像后，就能顺利完成安装了。执行“npm install -g grunt-cli” 安装Grunt，注意安装的是grunt-cli，-g表示全局安装，所有目录均可使用</p>\n<p>安装完成后，执行“grunt -v”。验证安装是否成功。</p>\n<p>#Grunt插件的安装<br>安装Grunt插件的时候可以采用两种方式，一种是单个插件安装（常用于新搭建项目的场景）；一种是插件批量安装（常用于下载项目文件后搭建开发环境）。具体安装方法如下：</p>\n<ol>\n<li><p>安装单个插件<br> 首先在命令行控制台里，切换到项目根目录。例如安装jshint插件，执行“npm install grunt-contrib-jshint –save-dev”命令即可。</p>\n</li>\n<li><p>批量安装<br> 首先新建package.json文件。将需要安装的插件名称和版本填写好（如果是配置库上下载，已有配置文件，此步骤跳过）。详细内容参考下一小节。<br> 命令行控制台切换到项目根目录。执行“npm install –save-dev”命令即可。执行成功后，根目录下会出现node_modules目录，下面会出现已安装的所有插件。<br>##package.json配置文件<br>配置具体示例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"wxcop\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"devDependencies\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"grunt\"</span>: <span class=\"string\">\"^0.4.5\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-clean\"</span>: <span class=\"string\">\"^0.6.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-copy\"</span>: <span class=\"string\">\"^0.8.2\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-cssmin\"</span>: <span class=\"string\">\"^0.14.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-jshint\"</span>: <span class=\"string\">\"^0.11.3\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"grunt-contrib-uglify\"</span>: <span class=\"string\">\"^0.9.2\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>示例中name为当前工程名称，version工程版本信息，devDependencies为依赖项（即Grunt和相关插件）。注意，这里的版本号前面有一个^符号，表示该插件可以被Grunt自动更新到最新的子版本。<br>关于配置文件的说明，详见：<a href=\"https://docs.npmjs.com/files/package.json\" target=\"_blank\" rel=\"noopener\">https://docs.npmjs.com/files/package.json</a></p>\n<p>#配置构建任务<br>在项目根目录下新建构建任务描述文件Gruntfile.js。具体示例如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">grunt</span>) </span>&#123;  </span><br><span class=\"line\">  grunt.initConfig(&#123;</span><br><span class=\"line\">    pkg: grunt.file.readJSON(<span class=\"string\">'package.json'</span>),   <span class=\"comment\">//加载配置文件 </span></span><br><span class=\"line\">    uglify: &#123;</span><br><span class=\"line\">      options: &#123; &#125;,</span><br><span class=\"line\">      buildall: &#123;<span class=\"comment\">//按原文件结构压缩js文件夹内所有js文件</span></span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            preserveComments:<span class=\"literal\">false</span>,</span><br><span class=\"line\">            report: <span class=\"string\">\"min\"</span><span class=\"comment\">//输出压缩率，可选的值有 false(不输出信息)，gzip</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              compress:<span class=\"literal\">false</span>,</span><br><span class=\"line\">              expand:<span class=\"literal\">true</span>,</span><br><span class=\"line\">              cwd:<span class=\"string\">'js'</span>,<span class=\"comment\">//js目录下</span></span><br><span class=\"line\">              src:<span class=\"string\">'**/*.js'</span>,<span class=\"comment\">//所有js文件</span></span><br><span class=\"line\">              dest: <span class=\"string\">'dist/js'</span><span class=\"comment\">//输出到此目录下</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      ueditor: &#123;<span class=\"comment\">//单独压缩ueditor.all.js文件</span></span><br><span class=\"line\">          options: &#123;</span><br><span class=\"line\">            preserveComments:<span class=\"literal\">false</span>,</span><br><span class=\"line\">            report: <span class=\"string\">\"min\"</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              compress:<span class=\"literal\">false</span>,</span><br><span class=\"line\">              src:<span class=\"string\">'vender/ueditor/ueditor.all.js'</span>,</span><br><span class=\"line\">              dest: <span class=\"string\">'vender/ueditor/ueditor.all.min.js'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cssmin: &#123;</span><br><span class=\"line\">      compress: &#123;<span class=\"comment\">//按原文件结构压缩css文件夹内所有css文件</span></span><br><span class=\"line\">        files: [&#123;</span><br><span class=\"line\">               expand: <span class=\"literal\">true</span>,</span><br><span class=\"line\">               cwd: <span class=\"string\">'css/'</span>,</span><br><span class=\"line\">               src: <span class=\"string\">'**/*.css'</span>,</span><br><span class=\"line\">               dest: <span class=\"string\">'dist/css'</span></span><br><span class=\"line\">         &#125;]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      adminlte: &#123;<span class=\"comment\">//单独压缩AdminLTE.css文件</span></span><br><span class=\"line\">          files: [&#123;</span><br><span class=\"line\">              src:<span class=\"string\">'vender/AdminLTE/AdminLTE.css'</span>,</span><br><span class=\"line\">              dest: <span class=\"string\">'vender/AdminLTE/AdminLTE.min.css'</span></span><br><span class=\"line\">          &#125;]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 加载包含 \"uglify\" 任务的插件。</span></span><br><span class=\"line\">  grunt.loadNpmTasks(<span class=\"string\">'grunt-contrib-uglify'</span>);</span><br><span class=\"line\">  grunt.loadNpmTasks(<span class=\"string\">'grunt-contrib-cssmin'</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 默认被执行的任务列表。</span></span><br><span class=\"line\">  grunt.registerTask(<span class=\"string\">'default'</span>, [<span class=\"string\">'uglify'</span>,<span class=\"string\">'cssmin:compress'</span>,<span class=\"string\">'cssmin:adminlte'</span>]);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上述代码实现了js目录下所有js文件的压缩，css目录下的所有css文件的压缩。文件主题是module.exports = function(grunt) { };函数内部主要有三部分：初始化参数，加载插件，注册构建任务。</p>\n<ol>\n<li>初始化参数<br> pkg属性，指定具体加载的配置文件，默认的必选项。uglify和cssmin是自己定义的任务，名称也是自定义的。</li>\n<li>加载插件<br> 加载指定的插件。</li>\n<li>注册构建任务<br> default是任务名称，[]中是具体构建项，按照先后顺序执行。可以是一个任务集合’uglify’,也可以是一个具体的任务’cssmin:compress’。<br>#执行构建<br>在命令行控制台里，切换到项目根目录。执行grunt，即可执行default任务。执行“grunt cssmin:adminlte”，即可执行具体的一个任务。执行“grunt uglify”即可执行一个任务集合。</li>\n</ol>\n<p>这里只是对grunt的一个概括介绍，配置的详细参数，具体插件的配置，后续在其他帖子里描述。</p>\n"},{"title":"高性能JavaScript--DOM操作","date":"2017-12-12T04:24:08.000Z","_content":"\n用JS进行DOM操作的代价是昂贵的，它是富web应用中最常见的性能瓶颈。\n### DOM\n文档对象模型（DOM）是一个独立于语言的，用于操作XML和HTML文档的程序接口（API）。通常在浏览器中DOM和JS都是独立的，因为彼此独立，所以JS操作DOM，性能开销就很大。\n### 提升性能最佳实践\n* 减少操作\n典型场景，循环操作DOM，改成循环拼接，最后操作DOM。\n```\n//循环操作DOM15000次\nfunction innerHTMLLoop(){\n\tfor(var count = 0; count < 15000; count++){\n\t\tdocument.getElementById('here').innerHTML += 'a';\n\t}\n}\n//只操作1次DOM，在IE8中性能提升273倍\nfunction innerHTMLLoop(){\n\tvar content = '';\n\tfor(var count = 0; count < 15000; count++){\n\t\tcontent += 'a';\n\t}\n\tdocument.getElementById('here').innerHTML = content;\n}\n```\n* 增加新元素时innerHTML性能高于DOM方法\n```\nvar newDiv = \"<div></div>\";\ndocument.getElementById('here').innerHTML = newDiv;\n//\nvar newElement = document.createElement('div');\ndocument.getElementById('here').appendChild(newElement);\n```\n* 使用节点clone\n```\nvar newElement1 = document.createElement('div');\nvar newElementN = newElement1.cloneNode(true);\n```\n\n* HTML集合使用array代替\nDOM查询方法（getElementByName，getElementByClassName，getElementByTagName），以及部分属性（images,links,forms,elements）返回值是HTML集合（类似数组，有length和下标访问，无push，slice）。这些集合要避免重复访问，因为每次访问都会重新执行查询。\n```\n//由于每次添加div后，长度增加，此循环是死循环\nvar divList= document.getElementByName('div')；\nfor(var count = 0; count < divList.length; count++){\n\tdocument.body.appendChild(document.createElement('div'));\n}\n//集合保存到变量，避免重复查询\nfor(var count = 0; count < document.getElementByName('div').length; count++){\n\t//do something\n}\nvar divList= document.getElementByName('div')；\nvar len = divList.length\nvar arr = toArray(divList); //toArray是自定义的函数，将集合转成array\nfor(var count = 0; count < len; count++){\n\t//do something\n}\n```\n注意：此方法会额外增加一次遍历操作，长度小的集合可能不会提升反而下降\n\n* 局部变量替代\n```\nfor(var i = 0; i < document.getElementsByTagName(\"a\").length; i++){\n\t\tdocument.getElementsByTagName(\"a\")[i].class = 'active'\n}\n//改进后\nvar list = document.getElementsByTagName(\"a\");\nvar len = list.length;\nfor(var i = 0; i < len; i++){\n\t\tlist[i].class = 'active'\n}\n```\n* IE6、7中遍历DOM，nextSibling性能高于childNode\n* 遍历元素节点优选元素节点属性\nchildNodes,firstChild和nextSibling这些属性并不区分元素节点和其他类型节点（比如注释和文本节点）。如果只需要查询元素节点，优先使用如下方法代替。（注意：IE6-8只支持children属性）\n\n|元素节点属性名|被替代的属性名|\n| - | :-: | -: | \n|children|childNodes|\n|childElementCount|childNodes.length|\n|firstElementChild|firstChild|\n|lastElementChild|lastChild|\n|nextElementSibling|nextSibling|\n|previousElementSibling|previousSibling|\n*  利用CSS选择器提高查找效率\nquerySelectorAll()方法使用CSS选择器作为参数，并且返回匹配节点的类数组对象。不会返回HTML集合，不会对应实时的文档结构，避免了之前讨论的HTML集合引起的性能和逻辑问题。代码示例如下：\n```\n//改进前\nvar els = document.getElementsById(\"menu\").getElementsByTagName(\"a\");\n//改进后\nvar els = document.querySelectorAll(\"#menu a\");\n```\n如果是组合查询，querySelectorAll()方法更具优势。对比一下：\n```\n//改进前\nvar els = [];\nvar divs = document.getElementsByTagName(\"div\");\nvar className = \"\";\nfor(var i = 0,len = divs.length; i<len;i++){\n\tclassName = divs[i].className;\n\tif(className === 'warning' || className === 'notice'){\n\t\tels.push(divs[i]);\n\t}\n}\n//改进后\nvar els = document.querySelectorAll(\"div.warning, div.notice\");\n```\n推荐使用querySelector()方法，查询第一个匹配的节点。\n\n## 重绘与重排\n浏览器下载完所有的组件文件（html、js、css、图片）之后，会解析这些组件，并生成两个数据结构：\n1. DOM树：表示页面结构\n2. 渲染树：表示DOM节点如何显示\nDOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的DOM元素在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或者“盒”，具有内边距padding，外边距margin，边框border和位置position（IE盒模型的高度和宽度包括边框和内边距，W3C只是内容部分。W3C盒模型可使用box-sizing:border-box改成IE盒模型）。一旦DOM树和渲染树构建完成，浏览器就开始显示（绘制）页面元素。\n当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的集合属性，同事其他元素的集合属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程被称为“重排reflow”。完成重排后，浏览器会重新绘制受影响的部分到平路中，该过程被称为“重绘repaint”。\n并不是所有的DOM变化都会影响几何属性，比如改变背景色，此时只会执行重绘而不会触发重排。重绘和重排都是代价昂贵的操作，需要尽量避免。  \n\n### 触发重排的操作\n1. 添加和删除可见的DOM元素\n2. 元素位置改变\n3. 元素尺寸变化\n4. 内容改变\n5. 页面渲染器初始化\n6. 浏览器窗口尺寸改变\n7. 滚动条的出现和消失会触发整个页面的重排\n\n### 渲染树变化的排队与刷新\n由于重排消耗大，大多数浏览器都会通过队列化修改并批量执行来优化重排过程。获取布局的如下操作会导致队列刷新：\n*  offsetTop，offsetLeft，offsetWidth，offsetHeight\n* scrollTop，scrollLeft，scrollWidth，scrollHeight\n* clientTop，clientLeft，clientWidth，clientHeight\n* getCumputedStyle()(currentStyle in IE)\n执行这些属性和方法需要返回最新的布局信息，因此浏览器会执行渲染队列中的操作，已获得最新的布局信息。因此不需要避免频繁执行这些属性和方法。\n### 最小化重排和重绘\n为减少重排或者重绘，应该合并多次对DOM和样式的修改，然后一次性处理。\n#### 修改样式\n```\n//优化前,执行了三次重排。大部分现代浏览器进行了优化，可能只执行一次\nvar el = document.getElementById('mydiv');\nel.style.borderLeft='1px';\nel.style.borderRight='2px';\nel.style.padding='5px';\n//优化后，只执行一次\nvar el = document.getElementById('mydiv');\nel.style.ccsText='border-left:1px;border-right:2px;padding:5px;';\n//第二种优化方法\nvar el = document.getElementById('mydiv');\nel.className='active';\n```\n#### 批量修改DOM\n可以通过如下步骤减少重绘和重排次数：\n1. 使元素脱离文档流\n2. 对其应用多重改变\n3. 把元素待会文档中\n这样操作后只会在1和3补执行两次重排，忽略了步骤2中可能的N次重排。\n使元素脱离文档流的方法有如下三种：\n1. 隐藏元素，应用修改，重新显示\n2. 使用文档片段在当前DOM之外构建一个子树，执行完修改后再把它拷贝回文档\n3. 讲原始元素拷贝到一个脱离文档的节点中，修改这个副本，完成后再替换原始元素。\n```\nfunction appendDataToElement(appendToElement, data) {\n\tvar a, li;\n\tfor (var i = 0, max = data.length; i < max; i++) {\n\t\ta = document.createElement('a');\n\t\ta.href = data[i].url;\n\t\ta.appendChild(document.createTextNode(data[i].name));\n\t\tli = document.createElement('li');\n\t\tli.appendChild(a);\n\t\tappendToElement.appendChild(li);\n\t}\n};\n//优化前,循环内N次重排\nvar ul = document.getElementById('mylist');\nappendDataToElement(ul, data);\n//第一种，异常和显示\nvar ul = document.getElementById('mylist');\nul.style.display = 'none';\nappendDataToElement(ul, data);\nul.style.display = 'block';\n//第二种，文档片段\nvar fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\ndocument.getElementById('mylist').appendChild(fragment);\n//第三种，元素替换\nvar old = document.getElementById('mylist');\nvar clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old);\n```\n推荐第二种方案，其产生的DOM遍历和重排次数最少。\n### 缓存布局信息\n当查询布局信息（例如offsets,scroll,client等），浏览器为返回最新值，会刷新队列并应用所有变更。所哟尽量减少布局信息的获取次数，获取后赋值给局部变量，然后再操作局部变量。\n例如移动元素的例子，timeout循环部分\n```\n//改进前\nmyElement.style.left = 1 + myElement.offsetLeft + 'px';\nmyElement.style.top = 1 + myElement.offsetTop + 'px';\nif (myElement.offsetLeft >= 500) {\n\tstopAnimation();\n}\n//改进后，先一次性获取初始位置\nvar current = myElement.offsetLeft;\n//然后循环执行操作\ncurrent++\nmyElement.style.left = current + 'px';\nmyElement.style.top = current + 'px';\nif (current >= 500) {\n\tstopAnimation();\n}\n```\n### 让元素脱离动画流\n采用绝对位置定位，可以减少元素尺寸变化时，对其他元素造成的重排影响。\n例如折叠/展开这种交互方式，每次变化都会导致下方所有元素的移动。如果把这部分元素使用绝对位置定位，覆盖其他部分。这样就能避免下方元素的重排和重绘，减少开销。\n### IE和:hover\n从IE7开始，IE允许任何元素上使用:hover这个CSS伪选择器。如果大量使用:hover，响应速度下降明显。特别是IE8。\n### 事件委托\n如果进行大量的DOM元素事件绑定，会引入性能问题。一个简单的解决方案是事件委托。只需给最外层的元素绑定事件，利用事件逐层冒泡并能被父级元素捕获，就可以处理所有子元素上触发的事件。\n","source":"_posts/FE/js/高性能JavaScript--DOM操作.md","raw":"---\ntitle: 高性能JavaScript--DOM操作\ndate: 2017-12-12 12:24:08\ntags: [JS,性能]\n---\n\n用JS进行DOM操作的代价是昂贵的，它是富web应用中最常见的性能瓶颈。\n### DOM\n文档对象模型（DOM）是一个独立于语言的，用于操作XML和HTML文档的程序接口（API）。通常在浏览器中DOM和JS都是独立的，因为彼此独立，所以JS操作DOM，性能开销就很大。\n### 提升性能最佳实践\n* 减少操作\n典型场景，循环操作DOM，改成循环拼接，最后操作DOM。\n```\n//循环操作DOM15000次\nfunction innerHTMLLoop(){\n\tfor(var count = 0; count < 15000; count++){\n\t\tdocument.getElementById('here').innerHTML += 'a';\n\t}\n}\n//只操作1次DOM，在IE8中性能提升273倍\nfunction innerHTMLLoop(){\n\tvar content = '';\n\tfor(var count = 0; count < 15000; count++){\n\t\tcontent += 'a';\n\t}\n\tdocument.getElementById('here').innerHTML = content;\n}\n```\n* 增加新元素时innerHTML性能高于DOM方法\n```\nvar newDiv = \"<div></div>\";\ndocument.getElementById('here').innerHTML = newDiv;\n//\nvar newElement = document.createElement('div');\ndocument.getElementById('here').appendChild(newElement);\n```\n* 使用节点clone\n```\nvar newElement1 = document.createElement('div');\nvar newElementN = newElement1.cloneNode(true);\n```\n\n* HTML集合使用array代替\nDOM查询方法（getElementByName，getElementByClassName，getElementByTagName），以及部分属性（images,links,forms,elements）返回值是HTML集合（类似数组，有length和下标访问，无push，slice）。这些集合要避免重复访问，因为每次访问都会重新执行查询。\n```\n//由于每次添加div后，长度增加，此循环是死循环\nvar divList= document.getElementByName('div')；\nfor(var count = 0; count < divList.length; count++){\n\tdocument.body.appendChild(document.createElement('div'));\n}\n//集合保存到变量，避免重复查询\nfor(var count = 0; count < document.getElementByName('div').length; count++){\n\t//do something\n}\nvar divList= document.getElementByName('div')；\nvar len = divList.length\nvar arr = toArray(divList); //toArray是自定义的函数，将集合转成array\nfor(var count = 0; count < len; count++){\n\t//do something\n}\n```\n注意：此方法会额外增加一次遍历操作，长度小的集合可能不会提升反而下降\n\n* 局部变量替代\n```\nfor(var i = 0; i < document.getElementsByTagName(\"a\").length; i++){\n\t\tdocument.getElementsByTagName(\"a\")[i].class = 'active'\n}\n//改进后\nvar list = document.getElementsByTagName(\"a\");\nvar len = list.length;\nfor(var i = 0; i < len; i++){\n\t\tlist[i].class = 'active'\n}\n```\n* IE6、7中遍历DOM，nextSibling性能高于childNode\n* 遍历元素节点优选元素节点属性\nchildNodes,firstChild和nextSibling这些属性并不区分元素节点和其他类型节点（比如注释和文本节点）。如果只需要查询元素节点，优先使用如下方法代替。（注意：IE6-8只支持children属性）\n\n|元素节点属性名|被替代的属性名|\n| - | :-: | -: | \n|children|childNodes|\n|childElementCount|childNodes.length|\n|firstElementChild|firstChild|\n|lastElementChild|lastChild|\n|nextElementSibling|nextSibling|\n|previousElementSibling|previousSibling|\n*  利用CSS选择器提高查找效率\nquerySelectorAll()方法使用CSS选择器作为参数，并且返回匹配节点的类数组对象。不会返回HTML集合，不会对应实时的文档结构，避免了之前讨论的HTML集合引起的性能和逻辑问题。代码示例如下：\n```\n//改进前\nvar els = document.getElementsById(\"menu\").getElementsByTagName(\"a\");\n//改进后\nvar els = document.querySelectorAll(\"#menu a\");\n```\n如果是组合查询，querySelectorAll()方法更具优势。对比一下：\n```\n//改进前\nvar els = [];\nvar divs = document.getElementsByTagName(\"div\");\nvar className = \"\";\nfor(var i = 0,len = divs.length; i<len;i++){\n\tclassName = divs[i].className;\n\tif(className === 'warning' || className === 'notice'){\n\t\tels.push(divs[i]);\n\t}\n}\n//改进后\nvar els = document.querySelectorAll(\"div.warning, div.notice\");\n```\n推荐使用querySelector()方法，查询第一个匹配的节点。\n\n## 重绘与重排\n浏览器下载完所有的组件文件（html、js、css、图片）之后，会解析这些组件，并生成两个数据结构：\n1. DOM树：表示页面结构\n2. 渲染树：表示DOM节点如何显示\nDOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的DOM元素在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或者“盒”，具有内边距padding，外边距margin，边框border和位置position（IE盒模型的高度和宽度包括边框和内边距，W3C只是内容部分。W3C盒模型可使用box-sizing:border-box改成IE盒模型）。一旦DOM树和渲染树构建完成，浏览器就开始显示（绘制）页面元素。\n当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的集合属性，同事其他元素的集合属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程被称为“重排reflow”。完成重排后，浏览器会重新绘制受影响的部分到平路中，该过程被称为“重绘repaint”。\n并不是所有的DOM变化都会影响几何属性，比如改变背景色，此时只会执行重绘而不会触发重排。重绘和重排都是代价昂贵的操作，需要尽量避免。  \n\n### 触发重排的操作\n1. 添加和删除可见的DOM元素\n2. 元素位置改变\n3. 元素尺寸变化\n4. 内容改变\n5. 页面渲染器初始化\n6. 浏览器窗口尺寸改变\n7. 滚动条的出现和消失会触发整个页面的重排\n\n### 渲染树变化的排队与刷新\n由于重排消耗大，大多数浏览器都会通过队列化修改并批量执行来优化重排过程。获取布局的如下操作会导致队列刷新：\n*  offsetTop，offsetLeft，offsetWidth，offsetHeight\n* scrollTop，scrollLeft，scrollWidth，scrollHeight\n* clientTop，clientLeft，clientWidth，clientHeight\n* getCumputedStyle()(currentStyle in IE)\n执行这些属性和方法需要返回最新的布局信息，因此浏览器会执行渲染队列中的操作，已获得最新的布局信息。因此不需要避免频繁执行这些属性和方法。\n### 最小化重排和重绘\n为减少重排或者重绘，应该合并多次对DOM和样式的修改，然后一次性处理。\n#### 修改样式\n```\n//优化前,执行了三次重排。大部分现代浏览器进行了优化，可能只执行一次\nvar el = document.getElementById('mydiv');\nel.style.borderLeft='1px';\nel.style.borderRight='2px';\nel.style.padding='5px';\n//优化后，只执行一次\nvar el = document.getElementById('mydiv');\nel.style.ccsText='border-left:1px;border-right:2px;padding:5px;';\n//第二种优化方法\nvar el = document.getElementById('mydiv');\nel.className='active';\n```\n#### 批量修改DOM\n可以通过如下步骤减少重绘和重排次数：\n1. 使元素脱离文档流\n2. 对其应用多重改变\n3. 把元素待会文档中\n这样操作后只会在1和3补执行两次重排，忽略了步骤2中可能的N次重排。\n使元素脱离文档流的方法有如下三种：\n1. 隐藏元素，应用修改，重新显示\n2. 使用文档片段在当前DOM之外构建一个子树，执行完修改后再把它拷贝回文档\n3. 讲原始元素拷贝到一个脱离文档的节点中，修改这个副本，完成后再替换原始元素。\n```\nfunction appendDataToElement(appendToElement, data) {\n\tvar a, li;\n\tfor (var i = 0, max = data.length; i < max; i++) {\n\t\ta = document.createElement('a');\n\t\ta.href = data[i].url;\n\t\ta.appendChild(document.createTextNode(data[i].name));\n\t\tli = document.createElement('li');\n\t\tli.appendChild(a);\n\t\tappendToElement.appendChild(li);\n\t}\n};\n//优化前,循环内N次重排\nvar ul = document.getElementById('mylist');\nappendDataToElement(ul, data);\n//第一种，异常和显示\nvar ul = document.getElementById('mylist');\nul.style.display = 'none';\nappendDataToElement(ul, data);\nul.style.display = 'block';\n//第二种，文档片段\nvar fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\ndocument.getElementById('mylist').appendChild(fragment);\n//第三种，元素替换\nvar old = document.getElementById('mylist');\nvar clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old);\n```\n推荐第二种方案，其产生的DOM遍历和重排次数最少。\n### 缓存布局信息\n当查询布局信息（例如offsets,scroll,client等），浏览器为返回最新值，会刷新队列并应用所有变更。所哟尽量减少布局信息的获取次数，获取后赋值给局部变量，然后再操作局部变量。\n例如移动元素的例子，timeout循环部分\n```\n//改进前\nmyElement.style.left = 1 + myElement.offsetLeft + 'px';\nmyElement.style.top = 1 + myElement.offsetTop + 'px';\nif (myElement.offsetLeft >= 500) {\n\tstopAnimation();\n}\n//改进后，先一次性获取初始位置\nvar current = myElement.offsetLeft;\n//然后循环执行操作\ncurrent++\nmyElement.style.left = current + 'px';\nmyElement.style.top = current + 'px';\nif (current >= 500) {\n\tstopAnimation();\n}\n```\n### 让元素脱离动画流\n采用绝对位置定位，可以减少元素尺寸变化时，对其他元素造成的重排影响。\n例如折叠/展开这种交互方式，每次变化都会导致下方所有元素的移动。如果把这部分元素使用绝对位置定位，覆盖其他部分。这样就能避免下方元素的重排和重绘，减少开销。\n### IE和:hover\n从IE7开始，IE允许任何元素上使用:hover这个CSS伪选择器。如果大量使用:hover，响应速度下降明显。特别是IE8。\n### 事件委托\n如果进行大量的DOM元素事件绑定，会引入性能问题。一个简单的解决方案是事件委托。只需给最外层的元素绑定事件，利用事件逐层冒泡并能被父级元素捕获，就可以处理所有子元素上触发的事件。\n","slug":"FE/js/高性能JavaScript--DOM操作","published":1,"updated":"2018-03-09T12:19:34.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b0013tccmoqompymz","content":"<p>用JS进行DOM操作的代价是昂贵的，它是富web应用中最常见的性能瓶颈。</p>\n<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><p>文档对象模型（DOM）是一个独立于语言的，用于操作XML和HTML文档的程序接口（API）。通常在浏览器中DOM和JS都是独立的，因为彼此独立，所以JS操作DOM，性能开销就很大。</p>\n<h3 id=\"提升性能最佳实践\"><a href=\"#提升性能最佳实践\" class=\"headerlink\" title=\"提升性能最佳实践\"></a>提升性能最佳实践</h3><ul>\n<li><p>减少操作<br>典型场景，循环操作DOM，改成循环拼接，最后操作DOM。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//循环操作DOM15000次</span><br><span class=\"line\">function innerHTMLLoop()&#123;</span><br><span class=\"line\">\tfor(var count = 0; count &lt; 15000; count++)&#123;</span><br><span class=\"line\">\t\tdocument.getElementById(&apos;here&apos;).innerHTML += &apos;a&apos;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//只操作1次DOM，在IE8中性能提升273倍</span><br><span class=\"line\">function innerHTMLLoop()&#123;</span><br><span class=\"line\">\tvar content = &apos;&apos;;</span><br><span class=\"line\">\tfor(var count = 0; count &lt; 15000; count++)&#123;</span><br><span class=\"line\">\t\tcontent += &apos;a&apos;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdocument.getElementById(&apos;here&apos;).innerHTML = content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加新元素时innerHTML性能高于DOM方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newDiv = &quot;&lt;div&gt;&lt;/div&gt;&quot;;</span><br><span class=\"line\">document.getElementById(&apos;here&apos;).innerHTML = newDiv;</span><br><span class=\"line\">//</span><br><span class=\"line\">var newElement = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">document.getElementById(&apos;here&apos;).appendChild(newElement);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用节点clone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newElement1 = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">var newElementN = newElement1.cloneNode(true);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML集合使用array代替<br>DOM查询方法（getElementByName，getElementByClassName，getElementByTagName），以及部分属性（images,links,forms,elements）返回值是HTML集合（类似数组，有length和下标访问，无push，slice）。这些集合要避免重复访问，因为每次访问都会重新执行查询。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//由于每次添加div后，长度增加，此循环是死循环</span><br><span class=\"line\">var divList= document.getElementByName(&apos;div&apos;)；</span><br><span class=\"line\">for(var count = 0; count &lt; divList.length; count++)&#123;</span><br><span class=\"line\">\tdocument.body.appendChild(document.createElement(&apos;div&apos;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//集合保存到变量，避免重复查询</span><br><span class=\"line\">for(var count = 0; count &lt; document.getElementByName(&apos;div&apos;).length; count++)&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var divList= document.getElementByName(&apos;div&apos;)；</span><br><span class=\"line\">var len = divList.length</span><br><span class=\"line\">var arr = toArray(divList); //toArray是自定义的函数，将集合转成array</span><br><span class=\"line\">for(var count = 0; count &lt; len; count++)&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：此方法会额外增加一次遍历操作，长度小的集合可能不会提升反而下降</p>\n<ul>\n<li><p>局部变量替代</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; document.getElementsByTagName(&quot;a&quot;).length; i++)&#123;</span><br><span class=\"line\">\t\tdocument.getElementsByTagName(&quot;a&quot;)[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var list = document.getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">var len = list.length;</span><br><span class=\"line\">for(var i = 0; i &lt; len; i++)&#123;</span><br><span class=\"line\">\t\tlist[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IE6、7中遍历DOM，nextSibling性能高于childNode</p>\n</li>\n<li>遍历元素节点优选元素节点属性<br>childNodes,firstChild和nextSibling这些属性并不区分元素节点和其他类型节点（比如注释和文本节点）。如果只需要查询元素节点，优先使用如下方法代替。（注意：IE6-8只支持children属性）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>元素节点属性名</th>\n<th style=\"text-align:center\">被替代的属性名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td style=\"text-align:center\">childNodes</td>\n</tr>\n<tr>\n<td>childElementCount</td>\n<td style=\"text-align:center\">childNodes.length</td>\n</tr>\n<tr>\n<td>firstElementChild</td>\n<td style=\"text-align:center\">firstChild</td>\n</tr>\n<tr>\n<td>lastElementChild</td>\n<td style=\"text-align:center\">lastChild</td>\n</tr>\n<tr>\n<td>nextElementSibling</td>\n<td style=\"text-align:center\">nextSibling</td>\n</tr>\n<tr>\n<td>previousElementSibling</td>\n<td style=\"text-align:center\">previousSibling</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>利用CSS选择器提高查找效率<br>querySelectorAll()方法使用CSS选择器作为参数，并且返回匹配节点的类数组对象。不会返回HTML集合，不会对应实时的文档结构，避免了之前讨论的HTML集合引起的性能和逻辑问题。代码示例如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">var els = document.getElementsById(&quot;menu&quot;).getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var els = document.querySelectorAll(&quot;#menu a&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果是组合查询，querySelectorAll()方法更具优势。对比一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">var els = [];</span><br><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\">var className = &quot;&quot;;</span><br><span class=\"line\">for(var i = 0,len = divs.length; i&lt;len;i++)&#123;</span><br><span class=\"line\">\tclassName = divs[i].className;</span><br><span class=\"line\">\tif(className === &apos;warning&apos; || className === &apos;notice&apos;)&#123;</span><br><span class=\"line\">\t\tels.push(divs[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var els = document.querySelectorAll(&quot;div.warning, div.notice&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>推荐使用querySelector()方法，查询第一个匹配的节点。</p>\n<h2 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h2><p>浏览器下载完所有的组件文件（html、js、css、图片）之后，会解析这些组件，并生成两个数据结构：</p>\n<ol>\n<li>DOM树：表示页面结构</li>\n<li>渲染树：表示DOM节点如何显示<br>DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的DOM元素在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或者“盒”，具有内边距padding，外边距margin，边框border和位置position（IE盒模型的高度和宽度包括边框和内边距，W3C只是内容部分。W3C盒模型可使用box-sizing:border-box改成IE盒模型）。一旦DOM树和渲染树构建完成，浏览器就开始显示（绘制）页面元素。<br>当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的集合属性，同事其他元素的集合属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程被称为“重排reflow”。完成重排后，浏览器会重新绘制受影响的部分到平路中，该过程被称为“重绘repaint”。<br>并不是所有的DOM变化都会影响几何属性，比如改变背景色，此时只会执行重绘而不会触发重排。重绘和重排都是代价昂贵的操作，需要尽量避免。  </li>\n</ol>\n<h3 id=\"触发重排的操作\"><a href=\"#触发重排的操作\" class=\"headerlink\" title=\"触发重排的操作\"></a>触发重排的操作</h3><ol>\n<li>添加和删除可见的DOM元素</li>\n<li>元素位置改变</li>\n<li>元素尺寸变化</li>\n<li>内容改变</li>\n<li>页面渲染器初始化</li>\n<li>浏览器窗口尺寸改变</li>\n<li>滚动条的出现和消失会触发整个页面的重排</li>\n</ol>\n<h3 id=\"渲染树变化的排队与刷新\"><a href=\"#渲染树变化的排队与刷新\" class=\"headerlink\" title=\"渲染树变化的排队与刷新\"></a>渲染树变化的排队与刷新</h3><p>由于重排消耗大，大多数浏览器都会通过队列化修改并批量执行来优化重排过程。获取布局的如下操作会导致队列刷新：</p>\n<ul>\n<li>offsetTop，offsetLeft，offsetWidth，offsetHeight</li>\n<li>scrollTop，scrollLeft，scrollWidth，scrollHeight</li>\n<li>clientTop，clientLeft，clientWidth，clientHeight</li>\n<li>getCumputedStyle()(currentStyle in IE)<br>执行这些属性和方法需要返回最新的布局信息，因此浏览器会执行渲染队列中的操作，已获得最新的布局信息。因此不需要避免频繁执行这些属性和方法。<h3 id=\"最小化重排和重绘\"><a href=\"#最小化重排和重绘\" class=\"headerlink\" title=\"最小化重排和重绘\"></a>最小化重排和重绘</h3>为减少重排或者重绘，应该合并多次对DOM和样式的修改，然后一次性处理。<h4 id=\"修改样式\"><a href=\"#修改样式\" class=\"headerlink\" title=\"修改样式\"></a>修改样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//优化前,执行了三次重排。大部分现代浏览器进行了优化，可能只执行一次</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.style.borderLeft=&apos;1px&apos;;</span><br><span class=\"line\">el.style.borderRight=&apos;2px&apos;;</span><br><span class=\"line\">el.style.padding=&apos;5px&apos;;</span><br><span class=\"line\">//优化后，只执行一次</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.style.ccsText=&apos;border-left:1px;border-right:2px;padding:5px;&apos;;</span><br><span class=\"line\">//第二种优化方法</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.className=&apos;active&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h4><p>可以通过如下步骤减少重绘和重排次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其应用多重改变</li>\n<li>把元素待会文档中<br>这样操作后只会在1和3补执行两次重排，忽略了步骤2中可能的N次重排。<br>使元素脱离文档流的方法有如下三种：</li>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段在当前DOM之外构建一个子树，执行完修改后再把它拷贝回文档</li>\n<li>讲原始元素拷贝到一个脱离文档的节点中，修改这个副本，完成后再替换原始元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">\tvar a, li;</span><br><span class=\"line\">\tfor (var i = 0, max = data.length; i &lt; max; i++) &#123;</span><br><span class=\"line\">\t\ta = document.createElement(&apos;a&apos;);</span><br><span class=\"line\">\t\ta.href = data[i].url;</span><br><span class=\"line\">\t\ta.appendChild(document.createTextNode(data[i].name));</span><br><span class=\"line\">\t\tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">\t\tli.appendChild(a);</span><br><span class=\"line\">\t\tappendToElement.appendChild(li);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//优化前,循环内N次重排</span><br><span class=\"line\">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">//第一种，异常和显示</span><br><span class=\"line\">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">ul.style.display = &apos;none&apos;;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = &apos;block&apos;;</span><br><span class=\"line\">//第二种，文档片段</span><br><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br><span class=\"line\">//第三种，元素替换</span><br><span class=\"line\">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">var clone = old.cloneNode(true);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>推荐第二种方案，其产生的DOM遍历和重排次数最少。</p>\n<h3 id=\"缓存布局信息\"><a href=\"#缓存布局信息\" class=\"headerlink\" title=\"缓存布局信息\"></a>缓存布局信息</h3><p>当查询布局信息（例如offsets,scroll,client等），浏览器为返回最新值，会刷新队列并应用所有变更。所哟尽量减少布局信息的获取次数，获取后赋值给局部变量，然后再操作局部变量。<br>例如移动元素的例子，timeout循环部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">myElement.style.left = 1 + myElement.offsetLeft + &apos;px&apos;;</span><br><span class=\"line\">myElement.style.top = 1 + myElement.offsetTop + &apos;px&apos;;</span><br><span class=\"line\">if (myElement.offsetLeft &gt;= 500) &#123;</span><br><span class=\"line\">\tstopAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后，先一次性获取初始位置</span><br><span class=\"line\">var current = myElement.offsetLeft;</span><br><span class=\"line\">//然后循环执行操作</span><br><span class=\"line\">current++</span><br><span class=\"line\">myElement.style.left = current + &apos;px&apos;;</span><br><span class=\"line\">myElement.style.top = current + &apos;px&apos;;</span><br><span class=\"line\">if (current &gt;= 500) &#123;</span><br><span class=\"line\">\tstopAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"让元素脱离动画流\"><a href=\"#让元素脱离动画流\" class=\"headerlink\" title=\"让元素脱离动画流\"></a>让元素脱离动画流</h3><p>采用绝对位置定位，可以减少元素尺寸变化时，对其他元素造成的重排影响。<br>例如折叠/展开这种交互方式，每次变化都会导致下方所有元素的移动。如果把这部分元素使用绝对位置定位，覆盖其他部分。这样就能避免下方元素的重排和重绘，减少开销。</p>\n<h3 id=\"IE和-hover\"><a href=\"#IE和-hover\" class=\"headerlink\" title=\"IE和:hover\"></a>IE和:hover</h3><p>从IE7开始，IE允许任何元素上使用:hover这个CSS伪选择器。如果大量使用:hover，响应速度下降明显。特别是IE8。</p>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><p>如果进行大量的DOM元素事件绑定，会引入性能问题。一个简单的解决方案是事件委托。只需给最外层的元素绑定事件，利用事件逐层冒泡并能被父级元素捕获，就可以处理所有子元素上触发的事件。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用JS进行DOM操作的代价是昂贵的，它是富web应用中最常见的性能瓶颈。</p>\n<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3><p>文档对象模型（DOM）是一个独立于语言的，用于操作XML和HTML文档的程序接口（API）。通常在浏览器中DOM和JS都是独立的，因为彼此独立，所以JS操作DOM，性能开销就很大。</p>\n<h3 id=\"提升性能最佳实践\"><a href=\"#提升性能最佳实践\" class=\"headerlink\" title=\"提升性能最佳实践\"></a>提升性能最佳实践</h3><ul>\n<li><p>减少操作<br>典型场景，循环操作DOM，改成循环拼接，最后操作DOM。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//循环操作DOM15000次</span><br><span class=\"line\">function innerHTMLLoop()&#123;</span><br><span class=\"line\">\tfor(var count = 0; count &lt; 15000; count++)&#123;</span><br><span class=\"line\">\t\tdocument.getElementById(&apos;here&apos;).innerHTML += &apos;a&apos;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//只操作1次DOM，在IE8中性能提升273倍</span><br><span class=\"line\">function innerHTMLLoop()&#123;</span><br><span class=\"line\">\tvar content = &apos;&apos;;</span><br><span class=\"line\">\tfor(var count = 0; count &lt; 15000; count++)&#123;</span><br><span class=\"line\">\t\tcontent += &apos;a&apos;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdocument.getElementById(&apos;here&apos;).innerHTML = content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>增加新元素时innerHTML性能高于DOM方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newDiv = &quot;&lt;div&gt;&lt;/div&gt;&quot;;</span><br><span class=\"line\">document.getElementById(&apos;here&apos;).innerHTML = newDiv;</span><br><span class=\"line\">//</span><br><span class=\"line\">var newElement = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">document.getElementById(&apos;here&apos;).appendChild(newElement);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用节点clone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var newElement1 = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">var newElementN = newElement1.cloneNode(true);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTML集合使用array代替<br>DOM查询方法（getElementByName，getElementByClassName，getElementByTagName），以及部分属性（images,links,forms,elements）返回值是HTML集合（类似数组，有length和下标访问，无push，slice）。这些集合要避免重复访问，因为每次访问都会重新执行查询。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//由于每次添加div后，长度增加，此循环是死循环</span><br><span class=\"line\">var divList= document.getElementByName(&apos;div&apos;)；</span><br><span class=\"line\">for(var count = 0; count &lt; divList.length; count++)&#123;</span><br><span class=\"line\">\tdocument.body.appendChild(document.createElement(&apos;div&apos;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//集合保存到变量，避免重复查询</span><br><span class=\"line\">for(var count = 0; count &lt; document.getElementByName(&apos;div&apos;).length; count++)&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var divList= document.getElementByName(&apos;div&apos;)；</span><br><span class=\"line\">var len = divList.length</span><br><span class=\"line\">var arr = toArray(divList); //toArray是自定义的函数，将集合转成array</span><br><span class=\"line\">for(var count = 0; count &lt; len; count++)&#123;</span><br><span class=\"line\">\t//do something</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：此方法会额外增加一次遍历操作，长度小的集合可能不会提升反而下降</p>\n<ul>\n<li><p>局部变量替代</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(var i = 0; i &lt; document.getElementsByTagName(&quot;a&quot;).length; i++)&#123;</span><br><span class=\"line\">\t\tdocument.getElementsByTagName(&quot;a&quot;)[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var list = document.getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">var len = list.length;</span><br><span class=\"line\">for(var i = 0; i &lt; len; i++)&#123;</span><br><span class=\"line\">\t\tlist[i].class = &apos;active&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IE6、7中遍历DOM，nextSibling性能高于childNode</p>\n</li>\n<li>遍历元素节点优选元素节点属性<br>childNodes,firstChild和nextSibling这些属性并不区分元素节点和其他类型节点（比如注释和文本节点）。如果只需要查询元素节点，优先使用如下方法代替。（注意：IE6-8只支持children属性）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>元素节点属性名</th>\n<th style=\"text-align:center\">被替代的属性名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td style=\"text-align:center\">childNodes</td>\n</tr>\n<tr>\n<td>childElementCount</td>\n<td style=\"text-align:center\">childNodes.length</td>\n</tr>\n<tr>\n<td>firstElementChild</td>\n<td style=\"text-align:center\">firstChild</td>\n</tr>\n<tr>\n<td>lastElementChild</td>\n<td style=\"text-align:center\">lastChild</td>\n</tr>\n<tr>\n<td>nextElementSibling</td>\n<td style=\"text-align:center\">nextSibling</td>\n</tr>\n<tr>\n<td>previousElementSibling</td>\n<td style=\"text-align:center\">previousSibling</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>利用CSS选择器提高查找效率<br>querySelectorAll()方法使用CSS选择器作为参数，并且返回匹配节点的类数组对象。不会返回HTML集合，不会对应实时的文档结构，避免了之前讨论的HTML集合引起的性能和逻辑问题。代码示例如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">var els = document.getElementsById(&quot;menu&quot;).getElementsByTagName(&quot;a&quot;);</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var els = document.querySelectorAll(&quot;#menu a&quot;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果是组合查询，querySelectorAll()方法更具优势。对比一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">var els = [];</span><br><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\">var className = &quot;&quot;;</span><br><span class=\"line\">for(var i = 0,len = divs.length; i&lt;len;i++)&#123;</span><br><span class=\"line\">\tclassName = divs[i].className;</span><br><span class=\"line\">\tif(className === &apos;warning&apos; || className === &apos;notice&apos;)&#123;</span><br><span class=\"line\">\t\tels.push(divs[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后</span><br><span class=\"line\">var els = document.querySelectorAll(&quot;div.warning, div.notice&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>推荐使用querySelector()方法，查询第一个匹配的节点。</p>\n<h2 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h2><p>浏览器下载完所有的组件文件（html、js、css、图片）之后，会解析这些组件，并生成两个数据结构：</p>\n<ol>\n<li>DOM树：表示页面结构</li>\n<li>渲染树：表示DOM节点如何显示<br>DOM树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的DOM元素在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或者“盒”，具有内边距padding，外边距margin，边框border和位置position（IE盒模型的高度和宽度包括边框和内边距，W3C只是内容部分。W3C盒模型可使用box-sizing:border-box改成IE盒模型）。一旦DOM树和渲染树构建完成，浏览器就开始显示（绘制）页面元素。<br>当DOM的变化影响了元素的几何属性（宽和高），浏览器需要重新计算元素的集合属性，同事其他元素的集合属性和位置也会受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程被称为“重排reflow”。完成重排后，浏览器会重新绘制受影响的部分到平路中，该过程被称为“重绘repaint”。<br>并不是所有的DOM变化都会影响几何属性，比如改变背景色，此时只会执行重绘而不会触发重排。重绘和重排都是代价昂贵的操作，需要尽量避免。  </li>\n</ol>\n<h3 id=\"触发重排的操作\"><a href=\"#触发重排的操作\" class=\"headerlink\" title=\"触发重排的操作\"></a>触发重排的操作</h3><ol>\n<li>添加和删除可见的DOM元素</li>\n<li>元素位置改变</li>\n<li>元素尺寸变化</li>\n<li>内容改变</li>\n<li>页面渲染器初始化</li>\n<li>浏览器窗口尺寸改变</li>\n<li>滚动条的出现和消失会触发整个页面的重排</li>\n</ol>\n<h3 id=\"渲染树变化的排队与刷新\"><a href=\"#渲染树变化的排队与刷新\" class=\"headerlink\" title=\"渲染树变化的排队与刷新\"></a>渲染树变化的排队与刷新</h3><p>由于重排消耗大，大多数浏览器都会通过队列化修改并批量执行来优化重排过程。获取布局的如下操作会导致队列刷新：</p>\n<ul>\n<li>offsetTop，offsetLeft，offsetWidth，offsetHeight</li>\n<li>scrollTop，scrollLeft，scrollWidth，scrollHeight</li>\n<li>clientTop，clientLeft，clientWidth，clientHeight</li>\n<li>getCumputedStyle()(currentStyle in IE)<br>执行这些属性和方法需要返回最新的布局信息，因此浏览器会执行渲染队列中的操作，已获得最新的布局信息。因此不需要避免频繁执行这些属性和方法。<h3 id=\"最小化重排和重绘\"><a href=\"#最小化重排和重绘\" class=\"headerlink\" title=\"最小化重排和重绘\"></a>最小化重排和重绘</h3>为减少重排或者重绘，应该合并多次对DOM和样式的修改，然后一次性处理。<h4 id=\"修改样式\"><a href=\"#修改样式\" class=\"headerlink\" title=\"修改样式\"></a>修改样式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//优化前,执行了三次重排。大部分现代浏览器进行了优化，可能只执行一次</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.style.borderLeft=&apos;1px&apos;;</span><br><span class=\"line\">el.style.borderRight=&apos;2px&apos;;</span><br><span class=\"line\">el.style.padding=&apos;5px&apos;;</span><br><span class=\"line\">//优化后，只执行一次</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.style.ccsText=&apos;border-left:1px;border-right:2px;padding:5px;&apos;;</span><br><span class=\"line\">//第二种优化方法</span><br><span class=\"line\">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class=\"line\">el.className=&apos;active&apos;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h4><p>可以通过如下步骤减少重绘和重排次数：</p>\n<ol>\n<li>使元素脱离文档流</li>\n<li>对其应用多重改变</li>\n<li>把元素待会文档中<br>这样操作后只会在1和3补执行两次重排，忽略了步骤2中可能的N次重排。<br>使元素脱离文档流的方法有如下三种：</li>\n<li>隐藏元素，应用修改，重新显示</li>\n<li>使用文档片段在当前DOM之外构建一个子树，执行完修改后再把它拷贝回文档</li>\n<li>讲原始元素拷贝到一个脱离文档的节点中，修改这个副本，完成后再替换原始元素。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function appendDataToElement(appendToElement, data) &#123;</span><br><span class=\"line\">\tvar a, li;</span><br><span class=\"line\">\tfor (var i = 0, max = data.length; i &lt; max; i++) &#123;</span><br><span class=\"line\">\t\ta = document.createElement(&apos;a&apos;);</span><br><span class=\"line\">\t\ta.href = data[i].url;</span><br><span class=\"line\">\t\ta.appendChild(document.createTextNode(data[i].name));</span><br><span class=\"line\">\t\tli = document.createElement(&apos;li&apos;);</span><br><span class=\"line\">\t\tli.appendChild(a);</span><br><span class=\"line\">\t\tappendToElement.appendChild(li);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//优化前,循环内N次重排</span><br><span class=\"line\">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">//第一种，异常和显示</span><br><span class=\"line\">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">ul.style.display = &apos;none&apos;;</span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = &apos;block&apos;;</span><br><span class=\"line\">//第二种，文档片段</span><br><span class=\"line\">var fragment = document.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br><span class=\"line\">//第三种，元素替换</span><br><span class=\"line\">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class=\"line\">var clone = old.cloneNode(true);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>推荐第二种方案，其产生的DOM遍历和重排次数最少。</p>\n<h3 id=\"缓存布局信息\"><a href=\"#缓存布局信息\" class=\"headerlink\" title=\"缓存布局信息\"></a>缓存布局信息</h3><p>当查询布局信息（例如offsets,scroll,client等），浏览器为返回最新值，会刷新队列并应用所有变更。所哟尽量减少布局信息的获取次数，获取后赋值给局部变量，然后再操作局部变量。<br>例如移动元素的例子，timeout循环部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//改进前</span><br><span class=\"line\">myElement.style.left = 1 + myElement.offsetLeft + &apos;px&apos;;</span><br><span class=\"line\">myElement.style.top = 1 + myElement.offsetTop + &apos;px&apos;;</span><br><span class=\"line\">if (myElement.offsetLeft &gt;= 500) &#123;</span><br><span class=\"line\">\tstopAnimation();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//改进后，先一次性获取初始位置</span><br><span class=\"line\">var current = myElement.offsetLeft;</span><br><span class=\"line\">//然后循环执行操作</span><br><span class=\"line\">current++</span><br><span class=\"line\">myElement.style.left = current + &apos;px&apos;;</span><br><span class=\"line\">myElement.style.top = current + &apos;px&apos;;</span><br><span class=\"line\">if (current &gt;= 500) &#123;</span><br><span class=\"line\">\tstopAnimation();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"让元素脱离动画流\"><a href=\"#让元素脱离动画流\" class=\"headerlink\" title=\"让元素脱离动画流\"></a>让元素脱离动画流</h3><p>采用绝对位置定位，可以减少元素尺寸变化时，对其他元素造成的重排影响。<br>例如折叠/展开这种交互方式，每次变化都会导致下方所有元素的移动。如果把这部分元素使用绝对位置定位，覆盖其他部分。这样就能避免下方元素的重排和重绘，减少开销。</p>\n<h3 id=\"IE和-hover\"><a href=\"#IE和-hover\" class=\"headerlink\" title=\"IE和:hover\"></a>IE和:hover</h3><p>从IE7开始，IE允许任何元素上使用:hover这个CSS伪选择器。如果大量使用:hover，响应速度下降明显。特别是IE8。</p>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><p>如果进行大量的DOM元素事件绑定，会引入性能问题。一个简单的解决方案是事件委托。只需给最外层的元素绑定事件，利用事件逐层冒泡并能被父级元素捕获，就可以处理所有子元素上触发的事件。</p>\n"},{"title":"AngularJS学习--Directives","date":"2016-04-02T04:24:08.000Z","_content":"# Directives是什么？\nAngularJS Directives是DOM元素(例如属性，元素名，注释或CSS类)上的标记，它告诉AngularJS的 html 编译器($compile) 把特定的操作连接到DOM元素或转化为DOM元素及其子元素，使元素拥有某些特定的行为。指令是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。\n\n## 什么时候需要用Directives？\n不要滥用Directives，如下一些场合需要考虑使用：\n1. 当某些元素或者元素组合以及其行为，需要在多个页面或者位置重复使用时；\n2. 引用其他jQuery组件，并且在加载数据后需要进行初始化时；\n\n##使用Directives的好处\n1. 去除重复代码\n2. 使得HTML更具可读性 例如：\n```\n//未使用指令时，无法知道该文本框的作用，需要查看JS代码。\n<input type=\"text\" />\n//使用指令后，根据指令可得知是时间输入框。显然后者更清晰明了。\n<input type=\"text\" data-date-picker />\n```\n注意：如果不涉及DOM定义，也可以考虑使用serivces\n# Directives有哪些形式？\nAngularJS中有四种类型的自定义指令：\n1. 元素指令  E \n```\n<data-my-directive></ data-my-directive>\n```\n2. 属性指令   A \n```\n<div data-my-attr></div>\n```\n3. CSS class 指令 C\n```\n<div class=\"my-class\"></div>\n```\n4. 注释指令 M \n```\n <!– directive:my-comment -- >\n```\n# Directives的命名\n如果要符合HTML5的规范，可以在元素前面添加 x- 或者 data-的前缀。在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)现形式，然后再与注册过的指令进行匹配。例如：\n```\n//指令定义\napp.directive('helloWorld', function() {})\n\n//指令应用\n<div data-hello-world></div>\n```\n当然，如果不需要符合HTML5规范，不可以加x- 或者 data- 前缀，一样可以正常使用。\n\n# Directives初体验\n指令示例如下，\n```\n//指令定义\nangular.module(‘app‘,[])\n.directive('helloWorld', function() {\n  return {\n      restrict: 'AE',\n      replace: 'true',\n      template: '<h3>Hello World!!</h3>'\n  };\n});\n\n//指令应用\n<div hello-world></div>\n```\n## Directive的基本属性说明：\n- restrict – 这个属性用来指定指令的类型，可用类型：A E C M。\n- template – 这个属性规定了指令被Angular编译和链接后生成的HTML字符串。可以包含其他的指令，以及表达式({ { } })等。\n- templateUrl—模板文件（template属性的HTML字符串保存成HTML文件）的URL地址，元素内容复杂的情况下推荐使用。\n- replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。默认是false，templat内容直接插入到该元素里。\n- transclude –说明指令是否复制原始标记中的内容。默认为false。注意：当前指令元素无子元素只有文本内容时，会自动添加span元素。\n## Directive的属性——link：\n如果我们要为DOM元素添加事件监听、监听模型属性变化、以及更新DOM等等行为时，就需要使用link属性。\n```\nlink: function(scope, element , attrs)  {\n        //dosomething\n    }\n```\n参数说明：\n- scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。\n- element – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行封装，可直接调用。 element .css('cursor', 'pointer');\n- attrs  一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性，那么可以在 link 函数中通过 attrs.attributename 来使用它。\n\n## Directive的属性——compile：\n```\n    compile: function(element, attrs) {\n        //dosomething\n    }\n```\ncompile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：\n- element – 指令所在的元素\n- attrs– 元素上赋予的参数的标准化列表\n\n要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。\n\n大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的。\n### 指令是如何被编译的？\n当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。\n\n## Directive的属性——scope：\n创建指令的作用范围，scope在指令中作为属性标签传递。scope 是创建可以复用指令的必要条件，每个指令（不论是处于嵌套指令的哪一级）都有其唯一的作用域，它不依赖于父scope。\nscope与父scope的关系可以分为隔离和继承两种。\n- 继承（默认就是继承）： scope: true,\n- 完全隔离：scope :  {},\n- 部分隔离： scope :  {name=‘@userName’}\n\n非完全隔离场景下又存在如下3种继承关系：\n```\nscope: {\n    name : '@',\n    age : '=',\n    doUpdate : '&'\n}\n```\n- “@” 单向绑定，数值可以从父scope传递到子scope，反之则不行。\n- “=” 双向绑定，数值可以在父scope，子scope之间互相传递\n- “&“  引用，类似函数指针，使得子scope可以直接调用父scope函数，从而修改父scope的变量。\n上述举例中，是属性和scope成员变量名称一致的情况。如果不一致，需要在符号后添加原始属性名称。例如：name:'@enName'\n\n注意：指令应用时，继承的属性名称必须使用-连接单词，不能用驼峰命名。\n```\n<div my-directive do-update=\"doUpdate\"><div>\n```","source":"_posts/FE/ng/AngularJS学习--Directives.md","raw":"---\ntitle: AngularJS学习--Directives\ndate: 2016-04-02 12:24:08\ntags: [JS,AngularJS]\n---\n# Directives是什么？\nAngularJS Directives是DOM元素(例如属性，元素名，注释或CSS类)上的标记，它告诉AngularJS的 html 编译器($compile) 把特定的操作连接到DOM元素或转化为DOM元素及其子元素，使元素拥有某些特定的行为。指令是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。\n\n## 什么时候需要用Directives？\n不要滥用Directives，如下一些场合需要考虑使用：\n1. 当某些元素或者元素组合以及其行为，需要在多个页面或者位置重复使用时；\n2. 引用其他jQuery组件，并且在加载数据后需要进行初始化时；\n\n##使用Directives的好处\n1. 去除重复代码\n2. 使得HTML更具可读性 例如：\n```\n//未使用指令时，无法知道该文本框的作用，需要查看JS代码。\n<input type=\"text\" />\n//使用指令后，根据指令可得知是时间输入框。显然后者更清晰明了。\n<input type=\"text\" data-date-picker />\n```\n注意：如果不涉及DOM定义，也可以考虑使用serivces\n# Directives有哪些形式？\nAngularJS中有四种类型的自定义指令：\n1. 元素指令  E \n```\n<data-my-directive></ data-my-directive>\n```\n2. 属性指令   A \n```\n<div data-my-attr></div>\n```\n3. CSS class 指令 C\n```\n<div class=\"my-class\"></div>\n```\n4. 注释指令 M \n```\n <!– directive:my-comment -- >\n```\n# Directives的命名\n如果要符合HTML5的规范，可以在元素前面添加 x- 或者 data-的前缀。在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)现形式，然后再与注册过的指令进行匹配。例如：\n```\n//指令定义\napp.directive('helloWorld', function() {})\n\n//指令应用\n<div data-hello-world></div>\n```\n当然，如果不需要符合HTML5规范，不可以加x- 或者 data- 前缀，一样可以正常使用。\n\n# Directives初体验\n指令示例如下，\n```\n//指令定义\nangular.module(‘app‘,[])\n.directive('helloWorld', function() {\n  return {\n      restrict: 'AE',\n      replace: 'true',\n      template: '<h3>Hello World!!</h3>'\n  };\n});\n\n//指令应用\n<div hello-world></div>\n```\n## Directive的基本属性说明：\n- restrict – 这个属性用来指定指令的类型，可用类型：A E C M。\n- template – 这个属性规定了指令被Angular编译和链接后生成的HTML字符串。可以包含其他的指令，以及表达式({ { } })等。\n- templateUrl—模板文件（template属性的HTML字符串保存成HTML文件）的URL地址，元素内容复杂的情况下推荐使用。\n- replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。默认是false，templat内容直接插入到该元素里。\n- transclude –说明指令是否复制原始标记中的内容。默认为false。注意：当前指令元素无子元素只有文本内容时，会自动添加span元素。\n## Directive的属性——link：\n如果我们要为DOM元素添加事件监听、监听模型属性变化、以及更新DOM等等行为时，就需要使用link属性。\n```\nlink: function(scope, element , attrs)  {\n        //dosomething\n    }\n```\n参数说明：\n- scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。\n- element – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行封装，可直接调用。 element .css('cursor', 'pointer');\n- attrs  一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性，那么可以在 link 函数中通过 attrs.attributename 来使用它。\n\n## Directive的属性——compile：\n```\n    compile: function(element, attrs) {\n        //dosomething\n    }\n```\ncompile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：\n- element – 指令所在的元素\n- attrs– 元素上赋予的参数的标准化列表\n\n要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。\n\n大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的。\n### 指令是如何被编译的？\n当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。\n\n## Directive的属性——scope：\n创建指令的作用范围，scope在指令中作为属性标签传递。scope 是创建可以复用指令的必要条件，每个指令（不论是处于嵌套指令的哪一级）都有其唯一的作用域，它不依赖于父scope。\nscope与父scope的关系可以分为隔离和继承两种。\n- 继承（默认就是继承）： scope: true,\n- 完全隔离：scope :  {},\n- 部分隔离： scope :  {name=‘@userName’}\n\n非完全隔离场景下又存在如下3种继承关系：\n```\nscope: {\n    name : '@',\n    age : '=',\n    doUpdate : '&'\n}\n```\n- “@” 单向绑定，数值可以从父scope传递到子scope，反之则不行。\n- “=” 双向绑定，数值可以在父scope，子scope之间互相传递\n- “&“  引用，类似函数指针，使得子scope可以直接调用父scope函数，从而修改父scope的变量。\n上述举例中，是属性和scope成员变量名称一致的情况。如果不一致，需要在符号后添加原始属性名称。例如：name:'@enName'\n\n注意：指令应用时，继承的属性名称必须使用-连接单词，不能用驼峰命名。\n```\n<div my-directive do-update=\"doUpdate\"><div>\n```","slug":"FE/ng/AngularJS学习--Directives","published":1,"updated":"2018-03-10T07:10:39.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b0015tccm92waqadi","content":"<h1 id=\"Directives是什么？\"><a href=\"#Directives是什么？\" class=\"headerlink\" title=\"Directives是什么？\"></a>Directives是什么？</h1><p>AngularJS Directives是DOM元素(例如属性，元素名，注释或CSS类)上的标记，它告诉AngularJS的 html 编译器($compile) 把特定的操作连接到DOM元素或转化为DOM元素及其子元素，使元素拥有某些特定的行为。指令是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。</p>\n<h2 id=\"什么时候需要用Directives？\"><a href=\"#什么时候需要用Directives？\" class=\"headerlink\" title=\"什么时候需要用Directives？\"></a>什么时候需要用Directives？</h2><p>不要滥用Directives，如下一些场合需要考虑使用：</p>\n<ol>\n<li>当某些元素或者元素组合以及其行为，需要在多个页面或者位置重复使用时；</li>\n<li>引用其他jQuery组件，并且在加载数据后需要进行初始化时；</li>\n</ol>\n<p>##使用Directives的好处</p>\n<ol>\n<li>去除重复代码</li>\n<li>使得HTML更具可读性 例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//未使用指令时，无法知道该文本框的作用，需要查看JS代码。</span><br><span class=\"line\">&lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">//使用指令后，根据指令可得知是时间输入框。显然后者更清晰明了。</span><br><span class=\"line\">&lt;input type=&quot;text&quot; data-date-picker /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意：如果不涉及DOM定义，也可以考虑使用serivces</p>\n<h1 id=\"Directives有哪些形式？\"><a href=\"#Directives有哪些形式？\" class=\"headerlink\" title=\"Directives有哪些形式？\"></a>Directives有哪些形式？</h1><p>AngularJS中有四种类型的自定义指令：</p>\n<ol>\n<li><p>元素指令  E </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;data-my-directive&gt;&lt;/ data-my-directive&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性指令   A </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div data-my-attr&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS class 指令 C</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;my-class&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释指令 M </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!– directive:my-comment -- &gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Directives的命名\"><a href=\"#Directives的命名\" class=\"headerlink\" title=\"Directives的命名\"></a>Directives的命名</h1><p>如果要符合HTML5的规范，可以在元素前面添加 x- 或者 data-的前缀。在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)现形式，然后再与注册过的指令进行匹配。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指令定义</span><br><span class=\"line\">app.directive(&apos;helloWorld&apos;, function() &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//指令应用</span><br><span class=\"line\">&lt;div data-hello-world&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然，如果不需要符合HTML5规范，不可以加x- 或者 data- 前缀，一样可以正常使用。</p>\n<h1 id=\"Directives初体验\"><a href=\"#Directives初体验\" class=\"headerlink\" title=\"Directives初体验\"></a>Directives初体验</h1><p>指令示例如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指令定义</span><br><span class=\"line\">angular.module(‘app‘,[])</span><br><span class=\"line\">.directive(&apos;helloWorld&apos;, function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">      restrict: &apos;AE&apos;,</span><br><span class=\"line\">      replace: &apos;true&apos;,</span><br><span class=\"line\">      template: &apos;&lt;h3&gt;Hello World!!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//指令应用</span><br><span class=\"line\">&lt;div hello-world&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Directive的基本属性说明：\"><a href=\"#Directive的基本属性说明：\" class=\"headerlink\" title=\"Directive的基本属性说明：\"></a>Directive的基本属性说明：</h2><ul>\n<li>restrict – 这个属性用来指定指令的类型，可用类型：A E C M。</li>\n<li>template – 这个属性规定了指令被Angular编译和链接后生成的HTML字符串。可以包含其他的指令，以及表达式({ { } })等。</li>\n<li>templateUrl—模板文件（template属性的HTML字符串保存成HTML文件）的URL地址，元素内容复杂的情况下推荐使用。</li>\n<li>replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。默认是false，templat内容直接插入到该元素里。</li>\n<li>transclude –说明指令是否复制原始标记中的内容。默认为false。注意：当前指令元素无子元素只有文本内容时，会自动添加span元素。<h2 id=\"Directive的属性——link：\"><a href=\"#Directive的属性——link：\" class=\"headerlink\" title=\"Directive的属性——link：\"></a>Directive的属性——link：</h2>如果我们要为DOM元素添加事件监听、监听模型属性变化、以及更新DOM等等行为时，就需要使用link属性。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">link: function(scope, element , attrs)  &#123;</span><br><span class=\"line\">        //dosomething</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>参数说明：</p>\n<ul>\n<li>scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。</li>\n<li>element – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行封装，可直接调用。 element .css(‘cursor’, ‘pointer’);</li>\n<li>attrs  一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性，那么可以在 link 函数中通过 attrs.attributename 来使用它。</li>\n</ul>\n<h2 id=\"Directive的属性——compile：\"><a href=\"#Directive的属性——compile：\" class=\"headerlink\" title=\"Directive的属性——compile：\"></a>Directive的属性——compile：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile: function(element, attrs) &#123;</span><br><span class=\"line\">    //dosomething</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>compile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：</p>\n<ul>\n<li>element – 指令所在的元素</li>\n<li>attrs– 元素上赋予的参数的标准化列表</li>\n</ul>\n<p>要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。</p>\n<p>大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的。</p>\n<h3 id=\"指令是如何被编译的？\"><a href=\"#指令是如何被编译的？\" class=\"headerlink\" title=\"指令是如何被编译的？\"></a>指令是如何被编译的？</h3><p>当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。</p>\n<h2 id=\"Directive的属性——scope：\"><a href=\"#Directive的属性——scope：\" class=\"headerlink\" title=\"Directive的属性——scope：\"></a>Directive的属性——scope：</h2><p>创建指令的作用范围，scope在指令中作为属性标签传递。scope 是创建可以复用指令的必要条件，每个指令（不论是处于嵌套指令的哪一级）都有其唯一的作用域，它不依赖于父scope。<br>scope与父scope的关系可以分为隔离和继承两种。</p>\n<ul>\n<li>继承（默认就是继承）： scope: true,</li>\n<li>完全隔离：scope :  {},</li>\n<li>部分隔离： scope :  {name=‘@userName’}</li>\n</ul>\n<p>非完全隔离场景下又存在如下3种继承关系：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scope: &#123;</span><br><span class=\"line\">    name : &apos;@&apos;,</span><br><span class=\"line\">    age : &apos;=&apos;,</span><br><span class=\"line\">    doUpdate : &apos;&amp;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>“@” 单向绑定，数值可以从父scope传递到子scope，反之则不行。</li>\n<li>“=” 双向绑定，数值可以在父scope，子scope之间互相传递</li>\n<li>“&amp;“  引用，类似函数指针，使得子scope可以直接调用父scope函数，从而修改父scope的变量。<br>上述举例中，是属性和scope成员变量名称一致的情况。如果不一致，需要在符号后添加原始属性名称。例如：name:’@enName’</li>\n</ul>\n<p>注意：指令应用时，继承的属性名称必须使用-连接单词，不能用驼峰命名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div my-directive do-update=&quot;doUpdate&quot;&gt;&lt;div&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Directives是什么？\"><a href=\"#Directives是什么？\" class=\"headerlink\" title=\"Directives是什么？\"></a>Directives是什么？</h1><p>AngularJS Directives是DOM元素(例如属性，元素名，注释或CSS类)上的标记，它告诉AngularJS的 html 编译器($compile) 把特定的操作连接到DOM元素或转化为DOM元素及其子元素，使元素拥有某些特定的行为。指令是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。</p>\n<h2 id=\"什么时候需要用Directives？\"><a href=\"#什么时候需要用Directives？\" class=\"headerlink\" title=\"什么时候需要用Directives？\"></a>什么时候需要用Directives？</h2><p>不要滥用Directives，如下一些场合需要考虑使用：</p>\n<ol>\n<li>当某些元素或者元素组合以及其行为，需要在多个页面或者位置重复使用时；</li>\n<li>引用其他jQuery组件，并且在加载数据后需要进行初始化时；</li>\n</ol>\n<p>##使用Directives的好处</p>\n<ol>\n<li>去除重复代码</li>\n<li>使得HTML更具可读性 例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//未使用指令时，无法知道该文本框的作用，需要查看JS代码。</span><br><span class=\"line\">&lt;input type=&quot;text&quot; /&gt;</span><br><span class=\"line\">//使用指令后，根据指令可得知是时间输入框。显然后者更清晰明了。</span><br><span class=\"line\">&lt;input type=&quot;text&quot; data-date-picker /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>注意：如果不涉及DOM定义，也可以考虑使用serivces</p>\n<h1 id=\"Directives有哪些形式？\"><a href=\"#Directives有哪些形式？\" class=\"headerlink\" title=\"Directives有哪些形式？\"></a>Directives有哪些形式？</h1><p>AngularJS中有四种类型的自定义指令：</p>\n<ol>\n<li><p>元素指令  E </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;data-my-directive&gt;&lt;/ data-my-directive&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性指令   A </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div data-my-attr&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS class 指令 C</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;my-class&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注释指令 M </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!– directive:my-comment -- &gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Directives的命名\"><a href=\"#Directives的命名\" class=\"headerlink\" title=\"Directives的命名\"></a>Directives的命名</h1><p>如果要符合HTML5的规范，可以在元素前面添加 x- 或者 data-的前缀。在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)现形式，然后再与注册过的指令进行匹配。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指令定义</span><br><span class=\"line\">app.directive(&apos;helloWorld&apos;, function() &#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//指令应用</span><br><span class=\"line\">&lt;div data-hello-world&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>当然，如果不需要符合HTML5规范，不可以加x- 或者 data- 前缀，一样可以正常使用。</p>\n<h1 id=\"Directives初体验\"><a href=\"#Directives初体验\" class=\"headerlink\" title=\"Directives初体验\"></a>Directives初体验</h1><p>指令示例如下，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//指令定义</span><br><span class=\"line\">angular.module(‘app‘,[])</span><br><span class=\"line\">.directive(&apos;helloWorld&apos;, function() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">      restrict: &apos;AE&apos;,</span><br><span class=\"line\">      replace: &apos;true&apos;,</span><br><span class=\"line\">      template: &apos;&lt;h3&gt;Hello World!!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//指令应用</span><br><span class=\"line\">&lt;div hello-world&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Directive的基本属性说明：\"><a href=\"#Directive的基本属性说明：\" class=\"headerlink\" title=\"Directive的基本属性说明：\"></a>Directive的基本属性说明：</h2><ul>\n<li>restrict – 这个属性用来指定指令的类型，可用类型：A E C M。</li>\n<li>template – 这个属性规定了指令被Angular编译和链接后生成的HTML字符串。可以包含其他的指令，以及表达式({ { } })等。</li>\n<li>templateUrl—模板文件（template属性的HTML字符串保存成HTML文件）的URL地址，元素内容复杂的情况下推荐使用。</li>\n<li>replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。默认是false，templat内容直接插入到该元素里。</li>\n<li>transclude –说明指令是否复制原始标记中的内容。默认为false。注意：当前指令元素无子元素只有文本内容时，会自动添加span元素。<h2 id=\"Directive的属性——link：\"><a href=\"#Directive的属性——link：\" class=\"headerlink\" title=\"Directive的属性——link：\"></a>Directive的属性——link：</h2>如果我们要为DOM元素添加事件监听、监听模型属性变化、以及更新DOM等等行为时，就需要使用link属性。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">link: function(scope, element , attrs)  &#123;</span><br><span class=\"line\">        //dosomething</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>参数说明：</p>\n<ul>\n<li>scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。</li>\n<li>element – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行封装，可直接调用。 element .css(‘cursor’, ‘pointer’);</li>\n<li>attrs  一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性，那么可以在 link 函数中通过 attrs.attributename 来使用它。</li>\n</ul>\n<h2 id=\"Directive的属性——compile：\"><a href=\"#Directive的属性——compile：\" class=\"headerlink\" title=\"Directive的属性——compile：\"></a>Directive的属性——compile：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile: function(element, attrs) &#123;</span><br><span class=\"line\">    //dosomething</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>compile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：</p>\n<ul>\n<li>element – 指令所在的元素</li>\n<li>attrs– 元素上赋予的参数的标准化列表</li>\n</ul>\n<p>要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。</p>\n<p>大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的。</p>\n<h3 id=\"指令是如何被编译的？\"><a href=\"#指令是如何被编译的？\" class=\"headerlink\" title=\"指令是如何被编译的？\"></a>指令是如何被编译的？</h3><p>当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。</p>\n<h2 id=\"Directive的属性——scope：\"><a href=\"#Directive的属性——scope：\" class=\"headerlink\" title=\"Directive的属性——scope：\"></a>Directive的属性——scope：</h2><p>创建指令的作用范围，scope在指令中作为属性标签传递。scope 是创建可以复用指令的必要条件，每个指令（不论是处于嵌套指令的哪一级）都有其唯一的作用域，它不依赖于父scope。<br>scope与父scope的关系可以分为隔离和继承两种。</p>\n<ul>\n<li>继承（默认就是继承）： scope: true,</li>\n<li>完全隔离：scope :  {},</li>\n<li>部分隔离： scope :  {name=‘@userName’}</li>\n</ul>\n<p>非完全隔离场景下又存在如下3种继承关系：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scope: &#123;</span><br><span class=\"line\">    name : &apos;@&apos;,</span><br><span class=\"line\">    age : &apos;=&apos;,</span><br><span class=\"line\">    doUpdate : &apos;&amp;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>“@” 单向绑定，数值可以从父scope传递到子scope，反之则不行。</li>\n<li>“=” 双向绑定，数值可以在父scope，子scope之间互相传递</li>\n<li>“&amp;“  引用，类似函数指针，使得子scope可以直接调用父scope函数，从而修改父scope的变量。<br>上述举例中，是属性和scope成员变量名称一致的情况。如果不一致，需要在符号后添加原始属性名称。例如：name:’@enName’</li>\n</ul>\n<p>注意：指令应用时，继承的属性名称必须使用-连接单词，不能用驼峰命名。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div my-directive do-update=&quot;doUpdate&quot;&gt;&lt;div&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"AngularJS学习--Resource","date":"2016-05-09T06:24:08.000Z","_content":"AngularJS提供了$resourceService来更方便地与RESTful服务进行交互，可以方便地定义一个REST资源，而不必手动声明CRUD方法。\n\n# 如何使用Resource？\n具体步骤如下：\n1. 引入angular-resource.min.js文件 \n2. 在模块中依赖ngResourece,\n3. 在服务中注入$resource\n\n示例代码如下：\n```\n//定义\nvar Topic = angular.module('Topic',['ngResource']);\nTopic.factory('topicResource',function($resource){\n  return $resource('/topic/:id',\n    {\n      id:'@id'\n    },\n    {\n      close:{\n        method:'POST',\n        params:{close:true},\n        isArray:false\n      }\n    }\n  );\n});\n\n//调用,对id为123的topic执行close操作\ntopicResource.close({id:123}, successFn, errorFn)\n```\n# $resource的参数说明\n$resource(url,{url参数},{自定义方法})\n1. url: 必填, 资源的基础url，url中带有':'项的是根据第二个参数来进行配置的。\n2. url参数: 选填，配置url中的带有':' 项的参数。例如: ('/card/user/:userID/:id', {userID:123,id:'@id'}), 那么userID会被配置为123.。另外,在调用$resource()的方法的时候(比如get,query...),可以传入参数覆盖这里对url参数的配置。\n3. 自定义方法: 选填，使用$resource获取到的资源,或者通过$resource实例化的资源,资源本身会具有一些方法,比如$save,第三个参数用于给资源添加自定义的方法。\n\n# $resource的方法\n$resource()默认有如下5个方法:\n1. get: {method:'GET'}  一般用于获取某个资源.\n2. query: {method:'GET',isArray:true},一般用于获取一整套的资源,isArray参数，用以设置返回数据格式，是否是数组。默认是true。\n3. save: {method:'POST'},一般用于保存某个资源,有可能是新建的资源,也有可能是更新现有的资源\n4. remove: {method:'DELETE'},一般用于删除某个资源\n5. delete:  {method:'DELETE'} , 一般用于删除某个资源\n\n# $resource的响应方法\n Resource.action([parameters], [success], [error])\n1. [parameters]: 可选. 一个json对象,用于配置url里的参数,比如这里写了{id:cardID},那么提交的请求url就是 '/card/user/123/cardID'. 可以不填,不填就直接按照$resource()里的url来提交,注意,不填的话,不需要给个空,可以直接写success回调,angular能够判断出它没有填第一个参数,而不是死板的按照顺序来解读参数.\n2. [success]:可选. 请求成功后的回调函数.回调接受2个参数(注意这里和$http有所不同)function(data, responseHeaders)\n3. [error]:可选. 请求失败后的回调.回调接受1个参数 function(httpResponse){   }\n注意：凡是通过$resource返回的对象,一定是json格式的,如果后台返回的数据不是json,$resource也会按照自己的方式处理成json格式.不能返回null,因为$resource必须返回json格式,所以要返回{}\n#响应转换\n有时基于既定的后台设计，无法提供完全RESTful的API，比如返回的是一个分页器对象，而非数组。此时，我们仍然可以使用$resource，但需要设置响应转换回调。例如：\n```\n/*\nAPI返回的是一个分页对象，需要读取其中的数组数据。\n{\n  currentPage : 1,\n  totalPage : 20,\n  pageSize : 2,\n  content : [\n    {\n      id : 1,\n      body : 'hello'\n    },\n    {\n      id : 2,\n      body : 'world'\n    }\n  ]\n}\n*/\n\n//定义\nvar Topics = $resouce('/topic/list/page/:pageid', null, { \n  page: {\n    method : 'GET',\n    transformResponse: function(data, headers){\n      var pager = JSON.parse(data);\n      return pager.content;\n    }    \n  }\n});\n\n//调用\nTopics.page(function(data){\n  //此时data已经是转换过的数组了\n});\n```\n当然上述转换，也可以在响应函数中进行相关的数据格式处理。\n\n类似响应重写，你还可以设置请求转换transformRequest。","source":"_posts/FE/ng/AngularJS学习--Resource.md","raw":"---\ntitle: AngularJS学习--Resource\ndate: 2016-05-09 14:24:08\ntags: [JS,AngularJS]\n---\nAngularJS提供了$resourceService来更方便地与RESTful服务进行交互，可以方便地定义一个REST资源，而不必手动声明CRUD方法。\n\n# 如何使用Resource？\n具体步骤如下：\n1. 引入angular-resource.min.js文件 \n2. 在模块中依赖ngResourece,\n3. 在服务中注入$resource\n\n示例代码如下：\n```\n//定义\nvar Topic = angular.module('Topic',['ngResource']);\nTopic.factory('topicResource',function($resource){\n  return $resource('/topic/:id',\n    {\n      id:'@id'\n    },\n    {\n      close:{\n        method:'POST',\n        params:{close:true},\n        isArray:false\n      }\n    }\n  );\n});\n\n//调用,对id为123的topic执行close操作\ntopicResource.close({id:123}, successFn, errorFn)\n```\n# $resource的参数说明\n$resource(url,{url参数},{自定义方法})\n1. url: 必填, 资源的基础url，url中带有':'项的是根据第二个参数来进行配置的。\n2. url参数: 选填，配置url中的带有':' 项的参数。例如: ('/card/user/:userID/:id', {userID:123,id:'@id'}), 那么userID会被配置为123.。另外,在调用$resource()的方法的时候(比如get,query...),可以传入参数覆盖这里对url参数的配置。\n3. 自定义方法: 选填，使用$resource获取到的资源,或者通过$resource实例化的资源,资源本身会具有一些方法,比如$save,第三个参数用于给资源添加自定义的方法。\n\n# $resource的方法\n$resource()默认有如下5个方法:\n1. get: {method:'GET'}  一般用于获取某个资源.\n2. query: {method:'GET',isArray:true},一般用于获取一整套的资源,isArray参数，用以设置返回数据格式，是否是数组。默认是true。\n3. save: {method:'POST'},一般用于保存某个资源,有可能是新建的资源,也有可能是更新现有的资源\n4. remove: {method:'DELETE'},一般用于删除某个资源\n5. delete:  {method:'DELETE'} , 一般用于删除某个资源\n\n# $resource的响应方法\n Resource.action([parameters], [success], [error])\n1. [parameters]: 可选. 一个json对象,用于配置url里的参数,比如这里写了{id:cardID},那么提交的请求url就是 '/card/user/123/cardID'. 可以不填,不填就直接按照$resource()里的url来提交,注意,不填的话,不需要给个空,可以直接写success回调,angular能够判断出它没有填第一个参数,而不是死板的按照顺序来解读参数.\n2. [success]:可选. 请求成功后的回调函数.回调接受2个参数(注意这里和$http有所不同)function(data, responseHeaders)\n3. [error]:可选. 请求失败后的回调.回调接受1个参数 function(httpResponse){   }\n注意：凡是通过$resource返回的对象,一定是json格式的,如果后台返回的数据不是json,$resource也会按照自己的方式处理成json格式.不能返回null,因为$resource必须返回json格式,所以要返回{}\n#响应转换\n有时基于既定的后台设计，无法提供完全RESTful的API，比如返回的是一个分页器对象，而非数组。此时，我们仍然可以使用$resource，但需要设置响应转换回调。例如：\n```\n/*\nAPI返回的是一个分页对象，需要读取其中的数组数据。\n{\n  currentPage : 1,\n  totalPage : 20,\n  pageSize : 2,\n  content : [\n    {\n      id : 1,\n      body : 'hello'\n    },\n    {\n      id : 2,\n      body : 'world'\n    }\n  ]\n}\n*/\n\n//定义\nvar Topics = $resouce('/topic/list/page/:pageid', null, { \n  page: {\n    method : 'GET',\n    transformResponse: function(data, headers){\n      var pager = JSON.parse(data);\n      return pager.content;\n    }    \n  }\n});\n\n//调用\nTopics.page(function(data){\n  //此时data已经是转换过的数组了\n});\n```\n当然上述转换，也可以在响应函数中进行相关的数据格式处理。\n\n类似响应重写，你还可以设置请求转换transformRequest。","slug":"FE/ng/AngularJS学习--Resource","published":1,"updated":"2018-03-11T06:19:32.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b0017tccmm38rmc7l","content":"<p>AngularJS提供了$resourceService来更方便地与RESTful服务进行交互，可以方便地定义一个REST资源，而不必手动声明CRUD方法。</p>\n<h1 id=\"如何使用Resource？\"><a href=\"#如何使用Resource？\" class=\"headerlink\" title=\"如何使用Resource？\"></a>如何使用Resource？</h1><p>具体步骤如下：</p>\n<ol>\n<li>引入angular-resource.min.js文件 </li>\n<li>在模块中依赖ngResourece,</li>\n<li>在服务中注入$resource</li>\n</ol>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">var Topic = angular.module(&apos;Topic&apos;,[&apos;ngResource&apos;]);</span><br><span class=\"line\">Topic.factory(&apos;topicResource&apos;,function($resource)&#123;</span><br><span class=\"line\">  return $resource(&apos;/topic/:id&apos;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id:&apos;@id&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      close:&#123;</span><br><span class=\"line\">        method:&apos;POST&apos;,</span><br><span class=\"line\">        params:&#123;close:true&#125;,</span><br><span class=\"line\">        isArray:false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//调用,对id为123的topic执行close操作</span><br><span class=\"line\">topicResource.close(&#123;id:123&#125;, successFn, errorFn)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"resource的参数说明\"><a href=\"#resource的参数说明\" class=\"headerlink\" title=\"$resource的参数说明\"></a>$resource的参数说明</h1><p>$resource(url,{url参数},{自定义方法})</p>\n<ol>\n<li>url: 必填, 资源的基础url，url中带有’:’项的是根据第二个参数来进行配置的。</li>\n<li>url参数: 选填，配置url中的带有’:’ 项的参数。例如: (‘/card/user/:userID/:id’, {userID:123,id:’@id’}), 那么userID会被配置为123.。另外,在调用$resource()的方法的时候(比如get,query…),可以传入参数覆盖这里对url参数的配置。</li>\n<li>自定义方法: 选填，使用$resource获取到的资源,或者通过$resource实例化的资源,资源本身会具有一些方法,比如$save,第三个参数用于给资源添加自定义的方法。</li>\n</ol>\n<h1 id=\"resource的方法\"><a href=\"#resource的方法\" class=\"headerlink\" title=\"$resource的方法\"></a>$resource的方法</h1><p>$resource()默认有如下5个方法:</p>\n<ol>\n<li>get: {method:’GET’}  一般用于获取某个资源.</li>\n<li>query: {method:’GET’,isArray:true},一般用于获取一整套的资源,isArray参数，用以设置返回数据格式，是否是数组。默认是true。</li>\n<li>save: {method:’POST’},一般用于保存某个资源,有可能是新建的资源,也有可能是更新现有的资源</li>\n<li>remove: {method:’DELETE’},一般用于删除某个资源</li>\n<li>delete:  {method:’DELETE’} , 一般用于删除某个资源</li>\n</ol>\n<h1 id=\"resource的响应方法\"><a href=\"#resource的响应方法\" class=\"headerlink\" title=\"$resource的响应方法\"></a>$resource的响应方法</h1><p> Resource.action([parameters], [success], [error])</p>\n<ol>\n<li>[parameters]: 可选. 一个json对象,用于配置url里的参数,比如这里写了{id:cardID},那么提交的请求url就是 ‘/card/user/123/cardID’. 可以不填,不填就直接按照$resource()里的url来提交,注意,不填的话,不需要给个空,可以直接写success回调,angular能够判断出它没有填第一个参数,而不是死板的按照顺序来解读参数.</li>\n<li>[success]:可选. 请求成功后的回调函数.回调接受2个参数(注意这里和$http有所不同)function(data, responseHeaders)</li>\n<li>[error]:可选. 请求失败后的回调.回调接受1个参数 function(httpResponse){   }<br>注意：凡是通过$resource返回的对象,一定是json格式的,如果后台返回的数据不是json,$resource也会按照自己的方式处理成json格式.不能返回null,因为$resource必须返回json格式,所以要返回{}<br>#响应转换<br>有时基于既定的后台设计，无法提供完全RESTful的API，比如返回的是一个分页器对象，而非数组。此时，我们仍然可以使用$resource，但需要设置响应转换回调。例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">API返回的是一个分页对象，需要读取其中的数组数据。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  currentPage : 1,</span><br><span class=\"line\">  totalPage : 20,</span><br><span class=\"line\">  pageSize : 2,</span><br><span class=\"line\">  content : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id : 1,</span><br><span class=\"line\">      body : &apos;hello&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id : 2,</span><br><span class=\"line\">      body : &apos;world&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">//定义</span><br><span class=\"line\">var Topics = $resouce(&apos;/topic/list/page/:pageid&apos;, null, &#123; </span><br><span class=\"line\">  page: &#123;</span><br><span class=\"line\">    method : &apos;GET&apos;,</span><br><span class=\"line\">    transformResponse: function(data, headers)&#123;</span><br><span class=\"line\">      var pager = JSON.parse(data);</span><br><span class=\"line\">      return pager.content;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//调用</span><br><span class=\"line\">Topics.page(function(data)&#123;</span><br><span class=\"line\">  //此时data已经是转换过的数组了</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当然上述转换，也可以在响应函数中进行相关的数据格式处理。</p>\n<p>类似响应重写，你还可以设置请求转换transformRequest。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AngularJS提供了$resourceService来更方便地与RESTful服务进行交互，可以方便地定义一个REST资源，而不必手动声明CRUD方法。</p>\n<h1 id=\"如何使用Resource？\"><a href=\"#如何使用Resource？\" class=\"headerlink\" title=\"如何使用Resource？\"></a>如何使用Resource？</h1><p>具体步骤如下：</p>\n<ol>\n<li>引入angular-resource.min.js文件 </li>\n<li>在模块中依赖ngResourece,</li>\n<li>在服务中注入$resource</li>\n</ol>\n<p>示例代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义</span><br><span class=\"line\">var Topic = angular.module(&apos;Topic&apos;,[&apos;ngResource&apos;]);</span><br><span class=\"line\">Topic.factory(&apos;topicResource&apos;,function($resource)&#123;</span><br><span class=\"line\">  return $resource(&apos;/topic/:id&apos;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id:&apos;@id&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      close:&#123;</span><br><span class=\"line\">        method:&apos;POST&apos;,</span><br><span class=\"line\">        params:&#123;close:true&#125;,</span><br><span class=\"line\">        isArray:false</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//调用,对id为123的topic执行close操作</span><br><span class=\"line\">topicResource.close(&#123;id:123&#125;, successFn, errorFn)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"resource的参数说明\"><a href=\"#resource的参数说明\" class=\"headerlink\" title=\"$resource的参数说明\"></a>$resource的参数说明</h1><p>$resource(url,{url参数},{自定义方法})</p>\n<ol>\n<li>url: 必填, 资源的基础url，url中带有’:’项的是根据第二个参数来进行配置的。</li>\n<li>url参数: 选填，配置url中的带有’:’ 项的参数。例如: (‘/card/user/:userID/:id’, {userID:123,id:’@id’}), 那么userID会被配置为123.。另外,在调用$resource()的方法的时候(比如get,query…),可以传入参数覆盖这里对url参数的配置。</li>\n<li>自定义方法: 选填，使用$resource获取到的资源,或者通过$resource实例化的资源,资源本身会具有一些方法,比如$save,第三个参数用于给资源添加自定义的方法。</li>\n</ol>\n<h1 id=\"resource的方法\"><a href=\"#resource的方法\" class=\"headerlink\" title=\"$resource的方法\"></a>$resource的方法</h1><p>$resource()默认有如下5个方法:</p>\n<ol>\n<li>get: {method:’GET’}  一般用于获取某个资源.</li>\n<li>query: {method:’GET’,isArray:true},一般用于获取一整套的资源,isArray参数，用以设置返回数据格式，是否是数组。默认是true。</li>\n<li>save: {method:’POST’},一般用于保存某个资源,有可能是新建的资源,也有可能是更新现有的资源</li>\n<li>remove: {method:’DELETE’},一般用于删除某个资源</li>\n<li>delete:  {method:’DELETE’} , 一般用于删除某个资源</li>\n</ol>\n<h1 id=\"resource的响应方法\"><a href=\"#resource的响应方法\" class=\"headerlink\" title=\"$resource的响应方法\"></a>$resource的响应方法</h1><p> Resource.action([parameters], [success], [error])</p>\n<ol>\n<li>[parameters]: 可选. 一个json对象,用于配置url里的参数,比如这里写了{id:cardID},那么提交的请求url就是 ‘/card/user/123/cardID’. 可以不填,不填就直接按照$resource()里的url来提交,注意,不填的话,不需要给个空,可以直接写success回调,angular能够判断出它没有填第一个参数,而不是死板的按照顺序来解读参数.</li>\n<li>[success]:可选. 请求成功后的回调函数.回调接受2个参数(注意这里和$http有所不同)function(data, responseHeaders)</li>\n<li>[error]:可选. 请求失败后的回调.回调接受1个参数 function(httpResponse){   }<br>注意：凡是通过$resource返回的对象,一定是json格式的,如果后台返回的数据不是json,$resource也会按照自己的方式处理成json格式.不能返回null,因为$resource必须返回json格式,所以要返回{}<br>#响应转换<br>有时基于既定的后台设计，无法提供完全RESTful的API，比如返回的是一个分页器对象，而非数组。此时，我们仍然可以使用$resource，但需要设置响应转换回调。例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\">API返回的是一个分页对象，需要读取其中的数组数据。</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  currentPage : 1,</span><br><span class=\"line\">  totalPage : 20,</span><br><span class=\"line\">  pageSize : 2,</span><br><span class=\"line\">  content : [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id : 1,</span><br><span class=\"line\">      body : &apos;hello&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      id : 2,</span><br><span class=\"line\">      body : &apos;world&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">//定义</span><br><span class=\"line\">var Topics = $resouce(&apos;/topic/list/page/:pageid&apos;, null, &#123; </span><br><span class=\"line\">  page: &#123;</span><br><span class=\"line\">    method : &apos;GET&apos;,</span><br><span class=\"line\">    transformResponse: function(data, headers)&#123;</span><br><span class=\"line\">      var pager = JSON.parse(data);</span><br><span class=\"line\">      return pager.content;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//调用</span><br><span class=\"line\">Topics.page(function(data)&#123;</span><br><span class=\"line\">  //此时data已经是转换过的数组了</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>当然上述转换，也可以在响应函数中进行相关的数据格式处理。</p>\n<p>类似响应重写，你还可以设置请求转换transformRequest。</p>\n"},{"title":"AngularJS学习--Services","date":"2016-04-02T04:24:08.000Z","_content":"# Services是什么？\nAngularJS里Services主要负责提供一个接口把特定功能的方法放在一起。类似封装好的类库供其他controller和directive调用。同时可以在应用中的不同作用域之间共享数据。Services作为单例对象在需要使用的时候被创建，只有在应用生命周期结束的时候（关闭浏览器）才会被清除。而controllers在不需要的时候就会被销毁。Service都是单例的，就是说在一个应用中，每一个Serice对象只会被实例化一次（用$injector服务)。\n\n# Services类型\nAngularJS带来了很多类型的Services定义方法。每个方法都会它自己不同的使用场景。下面我们会分别介绍。\n## 1、Constant\n```\napp.constant('myConfig', {\n    isLoad : true,\n    des : \"default config\"\n});\n```\nConstant就是常量，赋值后不能被修改，常用于对directive等做配置信息。所以当你想创建一个directive，并且你希望能够做一些配置信息，同时给些默认的配置，constant是个不错的的选择。常量可以是基础类型或object对象。\n## 2、Value\n```\napp.value('myConfig', {\n    isLoad : true,\n    des : \"default config\"\n});\n```\nValue和Constant很相似，唯一区别是其在赋值后还可以被改变。它也被常用于directive配置信息。也可以理解为全局变量。\n## 3、Factory\n```\napp.factory('myFactor', function() {\n\tvar name = \"myFactor\";\n\tfunction getName() {\n\t\treturn name;\n\t}\n\treturn {\n\t\tdes: \"This is factory service\",\n\t\tgetName: getName\n\t};\n});\n```\nFactory是我们最常用的service,会返回一个object对象。可以理解为工厂模式。Factory创建可以有多种方式，下面的代码就是另外一种创建方式。\n```\napp.factory('myFactor', function() {\n\tvar myInstance= {\n        var des = \"This is factory service\";\n\t    var name = \"myFactor\";\n\t    function getName() {\n            return name;\n        }\n    };\n\treturn myInstance;\n});\n```\n## 4、Service\n```\napp.service('myService', function() {\n    var name = \"myService\";\n    this.des = \"This is factory service\";\n    this.getName = function() {\n\treturn name;\n    };\n});\n```\nservice和factory工作原理一样，只是service接收的是一个构造函数，当第一次使用service的时候，angular会new MyService() 来初始化这个对象。后续使用的时候返回的都是同一个对象。下面是factory等价的写法：\n```\nfunction MyService() {\n\tvar name = \"myService\";\n\tthis.des = \"This is service\";\n\tthis.getName = function() {\n\t\treturn this.name;\n\t};\n}\napp.factory('myService', function() {\n\treturn new MyService();\n});\n```\n## 5、Provider\n```\napp.provider('myProvider', function() {\n        var name = \"myProvider\";\n        return {\n           //非$get返回内容，是唯一可以在config中访问的属性和方法\n            setName: function(newName) {\n                name = newName;\n            },\n            //$get返回内容，是唯一可以在控制器中访问的属性和方法\n            $get: function() {\n                function getName() {\n                    return name;\n                }\n \n                return {\n                    des: \"This is provider service\",\n                    getName: getName\n                };\n            }\n        };\n    })\n```\n\nprovider是唯一一种你可以传进 .config() 函数的service，factory和service都不可以。当你想要在 service 对象启用之前，先进行参数配置，那就应该用 provider。\n\n注意：config是传入参数为provider的名称后面加provider。\n\n```\n.config(function(myProviderProvider) {\n    myProviderProvider.setName('myProviderProvider');\n});\n```\n\n参考资料：\nhttp://www.tuicool.com/articles/rABfUvm\nhttp://www.cnblogs.com/whitewolf/p/angular-services.html","source":"_posts/FE/ng/AngularJS学习--Services.md","raw":"---\ntitle: AngularJS学习--Services\ndate: 2016-04-02 12:24:08\ntags: [JS,AngularJS]\n---\n# Services是什么？\nAngularJS里Services主要负责提供一个接口把特定功能的方法放在一起。类似封装好的类库供其他controller和directive调用。同时可以在应用中的不同作用域之间共享数据。Services作为单例对象在需要使用的时候被创建，只有在应用生命周期结束的时候（关闭浏览器）才会被清除。而controllers在不需要的时候就会被销毁。Service都是单例的，就是说在一个应用中，每一个Serice对象只会被实例化一次（用$injector服务)。\n\n# Services类型\nAngularJS带来了很多类型的Services定义方法。每个方法都会它自己不同的使用场景。下面我们会分别介绍。\n## 1、Constant\n```\napp.constant('myConfig', {\n    isLoad : true,\n    des : \"default config\"\n});\n```\nConstant就是常量，赋值后不能被修改，常用于对directive等做配置信息。所以当你想创建一个directive，并且你希望能够做一些配置信息，同时给些默认的配置，constant是个不错的的选择。常量可以是基础类型或object对象。\n## 2、Value\n```\napp.value('myConfig', {\n    isLoad : true,\n    des : \"default config\"\n});\n```\nValue和Constant很相似，唯一区别是其在赋值后还可以被改变。它也被常用于directive配置信息。也可以理解为全局变量。\n## 3、Factory\n```\napp.factory('myFactor', function() {\n\tvar name = \"myFactor\";\n\tfunction getName() {\n\t\treturn name;\n\t}\n\treturn {\n\t\tdes: \"This is factory service\",\n\t\tgetName: getName\n\t};\n});\n```\nFactory是我们最常用的service,会返回一个object对象。可以理解为工厂模式。Factory创建可以有多种方式，下面的代码就是另外一种创建方式。\n```\napp.factory('myFactor', function() {\n\tvar myInstance= {\n        var des = \"This is factory service\";\n\t    var name = \"myFactor\";\n\t    function getName() {\n            return name;\n        }\n    };\n\treturn myInstance;\n});\n```\n## 4、Service\n```\napp.service('myService', function() {\n    var name = \"myService\";\n    this.des = \"This is factory service\";\n    this.getName = function() {\n\treturn name;\n    };\n});\n```\nservice和factory工作原理一样，只是service接收的是一个构造函数，当第一次使用service的时候，angular会new MyService() 来初始化这个对象。后续使用的时候返回的都是同一个对象。下面是factory等价的写法：\n```\nfunction MyService() {\n\tvar name = \"myService\";\n\tthis.des = \"This is service\";\n\tthis.getName = function() {\n\t\treturn this.name;\n\t};\n}\napp.factory('myService', function() {\n\treturn new MyService();\n});\n```\n## 5、Provider\n```\napp.provider('myProvider', function() {\n        var name = \"myProvider\";\n        return {\n           //非$get返回内容，是唯一可以在config中访问的属性和方法\n            setName: function(newName) {\n                name = newName;\n            },\n            //$get返回内容，是唯一可以在控制器中访问的属性和方法\n            $get: function() {\n                function getName() {\n                    return name;\n                }\n \n                return {\n                    des: \"This is provider service\",\n                    getName: getName\n                };\n            }\n        };\n    })\n```\n\nprovider是唯一一种你可以传进 .config() 函数的service，factory和service都不可以。当你想要在 service 对象启用之前，先进行参数配置，那就应该用 provider。\n\n注意：config是传入参数为provider的名称后面加provider。\n\n```\n.config(function(myProviderProvider) {\n    myProviderProvider.setName('myProviderProvider');\n});\n```\n\n参考资料：\nhttp://www.tuicool.com/articles/rABfUvm\nhttp://www.cnblogs.com/whitewolf/p/angular-services.html","slug":"FE/ng/AngularJS学习--Services","published":1,"updated":"2018-03-10T07:41:11.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b001atccmyyf1akwl","content":"<h1 id=\"Services是什么？\"><a href=\"#Services是什么？\" class=\"headerlink\" title=\"Services是什么？\"></a>Services是什么？</h1><p>AngularJS里Services主要负责提供一个接口把特定功能的方法放在一起。类似封装好的类库供其他controller和directive调用。同时可以在应用中的不同作用域之间共享数据。Services作为单例对象在需要使用的时候被创建，只有在应用生命周期结束的时候（关闭浏览器）才会被清除。而controllers在不需要的时候就会被销毁。Service都是单例的，就是说在一个应用中，每一个Serice对象只会被实例化一次（用$injector服务)。</p>\n<h1 id=\"Services类型\"><a href=\"#Services类型\" class=\"headerlink\" title=\"Services类型\"></a>Services类型</h1><p>AngularJS带来了很多类型的Services定义方法。每个方法都会它自己不同的使用场景。下面我们会分别介绍。</p>\n<h2 id=\"1、Constant\"><a href=\"#1、Constant\" class=\"headerlink\" title=\"1、Constant\"></a>1、Constant</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.constant(&apos;myConfig&apos;, &#123;</span><br><span class=\"line\">    isLoad : true,</span><br><span class=\"line\">    des : &quot;default config&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Constant就是常量，赋值后不能被修改，常用于对directive等做配置信息。所以当你想创建一个directive，并且你希望能够做一些配置信息，同时给些默认的配置，constant是个不错的的选择。常量可以是基础类型或object对象。</p>\n<h2 id=\"2、Value\"><a href=\"#2、Value\" class=\"headerlink\" title=\"2、Value\"></a>2、Value</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.value(&apos;myConfig&apos;, &#123;</span><br><span class=\"line\">    isLoad : true,</span><br><span class=\"line\">    des : &quot;default config&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Value和Constant很相似，唯一区别是其在赋值后还可以被改变。它也被常用于directive配置信息。也可以理解为全局变量。</p>\n<h2 id=\"3、Factory\"><a href=\"#3、Factory\" class=\"headerlink\" title=\"3、Factory\"></a>3、Factory</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;myFactor&apos;, function() &#123;</span><br><span class=\"line\">\tvar name = &quot;myFactor&quot;;</span><br><span class=\"line\">\tfunction getName() &#123;</span><br><span class=\"line\">\t\treturn name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tdes: &quot;This is factory service&quot;,</span><br><span class=\"line\">\t\tgetName: getName</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Factory是我们最常用的service,会返回一个object对象。可以理解为工厂模式。Factory创建可以有多种方式，下面的代码就是另外一种创建方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;myFactor&apos;, function() &#123;</span><br><span class=\"line\">\tvar myInstance= &#123;</span><br><span class=\"line\">        var des = &quot;This is factory service&quot;;</span><br><span class=\"line\">\t    var name = &quot;myFactor&quot;;</span><br><span class=\"line\">\t    function getName() &#123;</span><br><span class=\"line\">            return name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">\treturn myInstance;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4、Service\"><a href=\"#4、Service\" class=\"headerlink\" title=\"4、Service\"></a>4、Service</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.service(&apos;myService&apos;, function() &#123;</span><br><span class=\"line\">    var name = &quot;myService&quot;;</span><br><span class=\"line\">    this.des = &quot;This is factory service&quot;;</span><br><span class=\"line\">    this.getName = function() &#123;</span><br><span class=\"line\">\treturn name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>service和factory工作原理一样，只是service接收的是一个构造函数，当第一次使用service的时候，angular会new MyService() 来初始化这个对象。后续使用的时候返回的都是同一个对象。下面是factory等价的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyService() &#123;</span><br><span class=\"line\">\tvar name = &quot;myService&quot;;</span><br><span class=\"line\">\tthis.des = &quot;This is service&quot;;</span><br><span class=\"line\">\tthis.getName = function() &#123;</span><br><span class=\"line\">\t\treturn this.name;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.factory(&apos;myService&apos;, function() &#123;</span><br><span class=\"line\">\treturn new MyService();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5、Provider\"><a href=\"#5、Provider\" class=\"headerlink\" title=\"5、Provider\"></a>5、Provider</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.provider(&apos;myProvider&apos;, function() &#123;</span><br><span class=\"line\">        var name = &quot;myProvider&quot;;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">           //非$get返回内容，是唯一可以在config中访问的属性和方法</span><br><span class=\"line\">            setName: function(newName) &#123;</span><br><span class=\"line\">                name = newName;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //$get返回内容，是唯一可以在控制器中访问的属性和方法</span><br><span class=\"line\">            $get: function() &#123;</span><br><span class=\"line\">                function getName() &#123;</span><br><span class=\"line\">                    return name;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    des: &quot;This is provider service&quot;,</span><br><span class=\"line\">                    getName: getName</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>provider是唯一一种你可以传进 .config() 函数的service，factory和service都不可以。当你想要在 service 对象启用之前，先进行参数配置，那就应该用 provider。</p>\n<p>注意：config是传入参数为provider的名称后面加provider。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.config(function(myProviderProvider) &#123;</span><br><span class=\"line\">    myProviderProvider.setName(&apos;myProviderProvider&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>参考资料：<br><a href=\"http://www.tuicool.com/articles/rABfUvm\" target=\"_blank\" rel=\"noopener\">http://www.tuicool.com/articles/rABfUvm</a><br><a href=\"http://www.cnblogs.com/whitewolf/p/angular-services.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/whitewolf/p/angular-services.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Services是什么？\"><a href=\"#Services是什么？\" class=\"headerlink\" title=\"Services是什么？\"></a>Services是什么？</h1><p>AngularJS里Services主要负责提供一个接口把特定功能的方法放在一起。类似封装好的类库供其他controller和directive调用。同时可以在应用中的不同作用域之间共享数据。Services作为单例对象在需要使用的时候被创建，只有在应用生命周期结束的时候（关闭浏览器）才会被清除。而controllers在不需要的时候就会被销毁。Service都是单例的，就是说在一个应用中，每一个Serice对象只会被实例化一次（用$injector服务)。</p>\n<h1 id=\"Services类型\"><a href=\"#Services类型\" class=\"headerlink\" title=\"Services类型\"></a>Services类型</h1><p>AngularJS带来了很多类型的Services定义方法。每个方法都会它自己不同的使用场景。下面我们会分别介绍。</p>\n<h2 id=\"1、Constant\"><a href=\"#1、Constant\" class=\"headerlink\" title=\"1、Constant\"></a>1、Constant</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.constant(&apos;myConfig&apos;, &#123;</span><br><span class=\"line\">    isLoad : true,</span><br><span class=\"line\">    des : &quot;default config&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Constant就是常量，赋值后不能被修改，常用于对directive等做配置信息。所以当你想创建一个directive，并且你希望能够做一些配置信息，同时给些默认的配置，constant是个不错的的选择。常量可以是基础类型或object对象。</p>\n<h2 id=\"2、Value\"><a href=\"#2、Value\" class=\"headerlink\" title=\"2、Value\"></a>2、Value</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.value(&apos;myConfig&apos;, &#123;</span><br><span class=\"line\">    isLoad : true,</span><br><span class=\"line\">    des : &quot;default config&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Value和Constant很相似，唯一区别是其在赋值后还可以被改变。它也被常用于directive配置信息。也可以理解为全局变量。</p>\n<h2 id=\"3、Factory\"><a href=\"#3、Factory\" class=\"headerlink\" title=\"3、Factory\"></a>3、Factory</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;myFactor&apos;, function() &#123;</span><br><span class=\"line\">\tvar name = &quot;myFactor&quot;;</span><br><span class=\"line\">\tfunction getName() &#123;</span><br><span class=\"line\">\t\treturn name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn &#123;</span><br><span class=\"line\">\t\tdes: &quot;This is factory service&quot;,</span><br><span class=\"line\">\t\tgetName: getName</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Factory是我们最常用的service,会返回一个object对象。可以理解为工厂模式。Factory创建可以有多种方式，下面的代码就是另外一种创建方式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;myFactor&apos;, function() &#123;</span><br><span class=\"line\">\tvar myInstance= &#123;</span><br><span class=\"line\">        var des = &quot;This is factory service&quot;;</span><br><span class=\"line\">\t    var name = &quot;myFactor&quot;;</span><br><span class=\"line\">\t    function getName() &#123;</span><br><span class=\"line\">            return name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">\treturn myInstance;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4、Service\"><a href=\"#4、Service\" class=\"headerlink\" title=\"4、Service\"></a>4、Service</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.service(&apos;myService&apos;, function() &#123;</span><br><span class=\"line\">    var name = &quot;myService&quot;;</span><br><span class=\"line\">    this.des = &quot;This is factory service&quot;;</span><br><span class=\"line\">    this.getName = function() &#123;</span><br><span class=\"line\">\treturn name;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>service和factory工作原理一样，只是service接收的是一个构造函数，当第一次使用service的时候，angular会new MyService() 来初始化这个对象。后续使用的时候返回的都是同一个对象。下面是factory等价的写法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyService() &#123;</span><br><span class=\"line\">\tvar name = &quot;myService&quot;;</span><br><span class=\"line\">\tthis.des = &quot;This is service&quot;;</span><br><span class=\"line\">\tthis.getName = function() &#123;</span><br><span class=\"line\">\t\treturn this.name;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">app.factory(&apos;myService&apos;, function() &#123;</span><br><span class=\"line\">\treturn new MyService();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5、Provider\"><a href=\"#5、Provider\" class=\"headerlink\" title=\"5、Provider\"></a>5、Provider</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.provider(&apos;myProvider&apos;, function() &#123;</span><br><span class=\"line\">        var name = &quot;myProvider&quot;;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">           //非$get返回内容，是唯一可以在config中访问的属性和方法</span><br><span class=\"line\">            setName: function(newName) &#123;</span><br><span class=\"line\">                name = newName;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //$get返回内容，是唯一可以在控制器中访问的属性和方法</span><br><span class=\"line\">            $get: function() &#123;</span><br><span class=\"line\">                function getName() &#123;</span><br><span class=\"line\">                    return name;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">                return &#123;</span><br><span class=\"line\">                    des: &quot;This is provider service&quot;,</span><br><span class=\"line\">                    getName: getName</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>provider是唯一一种你可以传进 .config() 函数的service，factory和service都不可以。当你想要在 service 对象启用之前，先进行参数配置，那就应该用 provider。</p>\n<p>注意：config是传入参数为provider的名称后面加provider。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.config(function(myProviderProvider) &#123;</span><br><span class=\"line\">    myProviderProvider.setName(&apos;myProviderProvider&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>参考资料：<br><a href=\"http://www.tuicool.com/articles/rABfUvm\" target=\"_blank\" rel=\"noopener\">http://www.tuicool.com/articles/rABfUvm</a><br><a href=\"http://www.cnblogs.com/whitewolf/p/angular-services.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/whitewolf/p/angular-services.html</a></p>\n"},{"title":"AngularJS学习--UI-Router","date":"2016-05-09T06:24:08.000Z","_content":"# 什么是UI-Router？\nAngularJS 是一种富客户端单页面应用框架，所以要在一个页面呈现不同的视图，路由起到了至关重要的作用。 UI-Router是Angular-UI提供的客户端路由框架，它解决了原生的ng-route的不足(视图不能嵌套，同一URL下不支持多个视图)。例如实际的单页面应用中，导航栏用一个视图，内容部分用另一个视图，就是比较常见的。\nUI-Router提出了$state的概念。一个$state是一个当前导航和UI的状态，每个$state需要绑定一个URL Pattern。 在控制器和模板中，通过改变$state来进行URL的跳转和路由。\n\n# 如何使用UI-Router\nUI-Router模块是一个可选的angularJS模块，如果需要使用，我们要单独引用js。具体应用示例如下：\n```\n<html>\n  <head>\n    <script src=\"lib/angular.js\"></script>\n    <script src=\"lib/angular-ui-router.js\"></script>\n    <script src=\"helloworld.js\"></script>\n    <style>.active { color: red; font-weight: bold; }</style>\n  </head>\n  <body ng-app=\"helloworld\">\n    <a ui-sref=\"hello\" ui-sref-active=\"active\">Hello</a>\n    <a ui-sref=\"about\" ui-sref-active=\"active\">About</a>\n    <ui-view></ui-view>\n  </body>\n</html>\n```\n```\nvar myApp = angular.module('helloworld', ['ui.router']);\n\nmyApp.config(function($stateProvider) {\n  var helloState = {\n    name: 'hello',\n    url: '/hello',\n    template: '<h3>hello world!</h3>'\n  }\n\n  var aboutState = {\n    name: 'about',\n    url: '/about',\n    template: '<h3>Its the UI-Router hello world app!</h3>'\n  }\n\n  $stateProvider.state(helloState);\n  $stateProvider.state(aboutState);\n});\n```\n## 路由加载的三种方法\n```\n//1、·调用$state.go方法   \n$state.go('detail', {id: 1});   \n$state.go('index');\n\n//2、点击包含ui-sref指令的链接\n<a ui-sref=\"contacts\">Contacts</a>\n<a ui-sref=\"contacts.detail({contactId: 42})\">Contact 42</a>\n \n//3、url跳转\n<a href=\"#/index\" >index</a>\n```\n\n## 视图嵌套\nui-router的视图可以嵌套，视图嵌套通常对应着$state的嵌套。 index.detail是index的子$state，index_detail.html也将作为index.html的子页面。ui-view可以配合$state进行任意层级的嵌套， 即index_detail.html中仍然可以包含一个ui-view，它的$state可能是index.detail.hobbies。\n\n## 视图命名\n在ui-router中，一个$state下可以有多个视图，它们有各自的模板和控制器。如上面的示例代码，hello和about就是两个独立的视图，有各自的末班和控制器。\n\n\n## 参数说明：\n- url：默认相对路径（以^开头的是绝对路径）\n- views：每个子视图可以包含自己的模板、控制器和预载入数据。 (后2项选填,控制器可以在view中绑定)\n- abstract：抽象模板不能被激活 \n- template: HTML字符串或者返回HTML字符串的函数\n- templateUrl: HTML模板的路径或者返回HTML模板路径的函数\n- templateProvider：返回HTML字符串的函数\n- controller、controllerProvider：指定任何已经被注册的控制器或者一个作为控制器的函数\n- resolve：在路由到达前预载入一系列依赖或者数据，然后注入到控制器中。 \n- data：数据不会被注入到控制器中，用途是从父状态传递数据到子状态。 \n- onEnter/onExit：进入或者离开当前状态的视图时会调用这两个函数.\n- resolve 为控制器提供可选的依赖注入项。是由 key/value 组成的键值对象。\n        key – {string}：注入控制器的依赖项名称。\n        value - {string|function}：\n            string：一个服务的别名\n            function：函数的返回值将作为依赖注入项，如果函数是一个耗时的操作，那么控制器必须等待该函数执行完成（be resolved）才会被实例化。\n            比如,视图都需要用户登录后才能访问,那么判断是否登录就可以做成一个控制器依赖\n            ```\n            resolve: {authentication:['topicAuth', '$q', function(topicAuth, $q){\n                    return $q.when().then(function(){\n                        return topicAuth.authentication();\n                    });\n                }]}\n            ```\n\n## 动态加载模板/内容\n在实际使用时往往需要根据参数动态加载不同模板/内容。此时可以通过如下两种方式实现。\n```\n//1、用参数作为文件名，拼接文件名加载\ntemplateUrl: function ($stateParams){\n    return '/topic/detail_' + $stateParams.type + '.html';\n}\n  \n//2、用参数赋值，修改内容\ntemplateProvider: function ($timeout, $stateParams) {\n    return $timeout(function () {\n        return '<h1>' + $stateParams.topicId + '</h1>'\n  }, 100);\n}\n```\n## 路由参数：\nui-router同样支持切换视图时传递参数。默认有如下两种方式传递参数：\n1. 通过$stateParams传递。传递的参数是一个object。传递的方法有：\n    - ui-sref=\"index.detail({id:22})“\n    - $state.go('index.detail', {id: 22});\n2. 通过$location来获取和设置URL。直接在controller里引入$stateParams 和$location即可。\n\n## state 为view controller提供自定义数据。\n```\n$stateProvider.state('blog.index', {\n        templateUrl: ’templates/blog_index.html',\n        data: {\n            currentPage: 1,\n            pageSize: 20\n        } \n    })\n```\n上面 data 对象就是自定义数据,里面定义了页面的当前页和显示内容条数。在视图对应的 controller 中我们就可以通过下面的方法来获取自定义数据.\n```\n    console.log($state.current.data.currentPage);  // 1\n    console.log($state.current.data.pageSize);  // 20\n```\n## 如何判断选中视图选中\n1. $state.includes \n    返回 true / false，查看当前状态是否在某父状态内，比如 $state.includes('contacts')\n    ```\n    <!-- 包含在 /contacts 状态内部，即其作为 parant state -->\n    <li ng-class=\"{active: $state.includes('contacts')}\">\n        <a ui-serif=\"contacts.list\">Contacts</a>\n    </li>\n    ```\n2. ui-sref-active \n    查看当前激活状态并设置 Class。例如\n    ```\n    <li ui-sref-active=\"active\"><a ui-sref=\"about\">About</a></li>\n    ```\n\n## 控制器引入的集中方法\n```\n$stateProvider.state('contacts', {//直接定义\n  template:'<h1>test</h1>',\n  controller: function($scope){\n    $scope.title = 'My Contacts';\n  }\n}).state('contacts1', {//直接名称引用\n  template:'<h1>test</h1>',\n  controller: 'ContactsCtrl'\n}).state('contacts2', {//直接定义并且定义别名\n  template:'<h1>test</h1>',\n  controller: function(){\n    this.title = 'My Contacts';\n  },\n  controllerAs: 'contact'\n}).state('contacts3', { //控制器名称并且定义别名\n  template:'<h1>test</h1>',\n  controller: 'ContactsCtrl as contact'\n}).state('contacts4', { //根据state动态加载\n  template:'<h1>test</h1>',\n  controllerProvider: function($stateParams) {\n      var ctrlName = $stateParams.type + \"Controller\";\n      return ctrlName;\n  }\n});\n```\n注意：如果未定义template，controller将不会被实例化\n更多说明：参考 https://github.com/angular-ui/ui-router/wiki","source":"_posts/FE/ng/AngularJS学习--UI-Route.md","raw":"---\ntitle: AngularJS学习--UI-Router\ndate: 2016-05-09 14:24:08\ntags: [JS,AngularJS]\n---\n# 什么是UI-Router？\nAngularJS 是一种富客户端单页面应用框架，所以要在一个页面呈现不同的视图，路由起到了至关重要的作用。 UI-Router是Angular-UI提供的客户端路由框架，它解决了原生的ng-route的不足(视图不能嵌套，同一URL下不支持多个视图)。例如实际的单页面应用中，导航栏用一个视图，内容部分用另一个视图，就是比较常见的。\nUI-Router提出了$state的概念。一个$state是一个当前导航和UI的状态，每个$state需要绑定一个URL Pattern。 在控制器和模板中，通过改变$state来进行URL的跳转和路由。\n\n# 如何使用UI-Router\nUI-Router模块是一个可选的angularJS模块，如果需要使用，我们要单独引用js。具体应用示例如下：\n```\n<html>\n  <head>\n    <script src=\"lib/angular.js\"></script>\n    <script src=\"lib/angular-ui-router.js\"></script>\n    <script src=\"helloworld.js\"></script>\n    <style>.active { color: red; font-weight: bold; }</style>\n  </head>\n  <body ng-app=\"helloworld\">\n    <a ui-sref=\"hello\" ui-sref-active=\"active\">Hello</a>\n    <a ui-sref=\"about\" ui-sref-active=\"active\">About</a>\n    <ui-view></ui-view>\n  </body>\n</html>\n```\n```\nvar myApp = angular.module('helloworld', ['ui.router']);\n\nmyApp.config(function($stateProvider) {\n  var helloState = {\n    name: 'hello',\n    url: '/hello',\n    template: '<h3>hello world!</h3>'\n  }\n\n  var aboutState = {\n    name: 'about',\n    url: '/about',\n    template: '<h3>Its the UI-Router hello world app!</h3>'\n  }\n\n  $stateProvider.state(helloState);\n  $stateProvider.state(aboutState);\n});\n```\n## 路由加载的三种方法\n```\n//1、·调用$state.go方法   \n$state.go('detail', {id: 1});   \n$state.go('index');\n\n//2、点击包含ui-sref指令的链接\n<a ui-sref=\"contacts\">Contacts</a>\n<a ui-sref=\"contacts.detail({contactId: 42})\">Contact 42</a>\n \n//3、url跳转\n<a href=\"#/index\" >index</a>\n```\n\n## 视图嵌套\nui-router的视图可以嵌套，视图嵌套通常对应着$state的嵌套。 index.detail是index的子$state，index_detail.html也将作为index.html的子页面。ui-view可以配合$state进行任意层级的嵌套， 即index_detail.html中仍然可以包含一个ui-view，它的$state可能是index.detail.hobbies。\n\n## 视图命名\n在ui-router中，一个$state下可以有多个视图，它们有各自的模板和控制器。如上面的示例代码，hello和about就是两个独立的视图，有各自的末班和控制器。\n\n\n## 参数说明：\n- url：默认相对路径（以^开头的是绝对路径）\n- views：每个子视图可以包含自己的模板、控制器和预载入数据。 (后2项选填,控制器可以在view中绑定)\n- abstract：抽象模板不能被激活 \n- template: HTML字符串或者返回HTML字符串的函数\n- templateUrl: HTML模板的路径或者返回HTML模板路径的函数\n- templateProvider：返回HTML字符串的函数\n- controller、controllerProvider：指定任何已经被注册的控制器或者一个作为控制器的函数\n- resolve：在路由到达前预载入一系列依赖或者数据，然后注入到控制器中。 \n- data：数据不会被注入到控制器中，用途是从父状态传递数据到子状态。 \n- onEnter/onExit：进入或者离开当前状态的视图时会调用这两个函数.\n- resolve 为控制器提供可选的依赖注入项。是由 key/value 组成的键值对象。\n        key – {string}：注入控制器的依赖项名称。\n        value - {string|function}：\n            string：一个服务的别名\n            function：函数的返回值将作为依赖注入项，如果函数是一个耗时的操作，那么控制器必须等待该函数执行完成（be resolved）才会被实例化。\n            比如,视图都需要用户登录后才能访问,那么判断是否登录就可以做成一个控制器依赖\n            ```\n            resolve: {authentication:['topicAuth', '$q', function(topicAuth, $q){\n                    return $q.when().then(function(){\n                        return topicAuth.authentication();\n                    });\n                }]}\n            ```\n\n## 动态加载模板/内容\n在实际使用时往往需要根据参数动态加载不同模板/内容。此时可以通过如下两种方式实现。\n```\n//1、用参数作为文件名，拼接文件名加载\ntemplateUrl: function ($stateParams){\n    return '/topic/detail_' + $stateParams.type + '.html';\n}\n  \n//2、用参数赋值，修改内容\ntemplateProvider: function ($timeout, $stateParams) {\n    return $timeout(function () {\n        return '<h1>' + $stateParams.topicId + '</h1>'\n  }, 100);\n}\n```\n## 路由参数：\nui-router同样支持切换视图时传递参数。默认有如下两种方式传递参数：\n1. 通过$stateParams传递。传递的参数是一个object。传递的方法有：\n    - ui-sref=\"index.detail({id:22})“\n    - $state.go('index.detail', {id: 22});\n2. 通过$location来获取和设置URL。直接在controller里引入$stateParams 和$location即可。\n\n## state 为view controller提供自定义数据。\n```\n$stateProvider.state('blog.index', {\n        templateUrl: ’templates/blog_index.html',\n        data: {\n            currentPage: 1,\n            pageSize: 20\n        } \n    })\n```\n上面 data 对象就是自定义数据,里面定义了页面的当前页和显示内容条数。在视图对应的 controller 中我们就可以通过下面的方法来获取自定义数据.\n```\n    console.log($state.current.data.currentPage);  // 1\n    console.log($state.current.data.pageSize);  // 20\n```\n## 如何判断选中视图选中\n1. $state.includes \n    返回 true / false，查看当前状态是否在某父状态内，比如 $state.includes('contacts')\n    ```\n    <!-- 包含在 /contacts 状态内部，即其作为 parant state -->\n    <li ng-class=\"{active: $state.includes('contacts')}\">\n        <a ui-serif=\"contacts.list\">Contacts</a>\n    </li>\n    ```\n2. ui-sref-active \n    查看当前激活状态并设置 Class。例如\n    ```\n    <li ui-sref-active=\"active\"><a ui-sref=\"about\">About</a></li>\n    ```\n\n## 控制器引入的集中方法\n```\n$stateProvider.state('contacts', {//直接定义\n  template:'<h1>test</h1>',\n  controller: function($scope){\n    $scope.title = 'My Contacts';\n  }\n}).state('contacts1', {//直接名称引用\n  template:'<h1>test</h1>',\n  controller: 'ContactsCtrl'\n}).state('contacts2', {//直接定义并且定义别名\n  template:'<h1>test</h1>',\n  controller: function(){\n    this.title = 'My Contacts';\n  },\n  controllerAs: 'contact'\n}).state('contacts3', { //控制器名称并且定义别名\n  template:'<h1>test</h1>',\n  controller: 'ContactsCtrl as contact'\n}).state('contacts4', { //根据state动态加载\n  template:'<h1>test</h1>',\n  controllerProvider: function($stateParams) {\n      var ctrlName = $stateParams.type + \"Controller\";\n      return ctrlName;\n  }\n});\n```\n注意：如果未定义template，controller将不会被实例化\n更多说明：参考 https://github.com/angular-ui/ui-router/wiki","slug":"FE/ng/AngularJS学习--UI-Route","published":1,"updated":"2018-03-11T06:56:28.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjemvlw0b001btccmrcdgybxw","content":"<h1 id=\"什么是UI-Router？\"><a href=\"#什么是UI-Router？\" class=\"headerlink\" title=\"什么是UI-Router？\"></a>什么是UI-Router？</h1><p>AngularJS 是一种富客户端单页面应用框架，所以要在一个页面呈现不同的视图，路由起到了至关重要的作用。 UI-Router是Angular-UI提供的客户端路由框架，它解决了原生的ng-route的不足(视图不能嵌套，同一URL下不支持多个视图)。例如实际的单页面应用中，导航栏用一个视图，内容部分用另一个视图，就是比较常见的。<br>UI-Router提出了$state的概念。一个$state是一个当前导航和UI的状态，每个$state需要绑定一个URL Pattern。 在控制器和模板中，通过改变$state来进行URL的跳转和路由。</p>\n<h1 id=\"如何使用UI-Router\"><a href=\"#如何使用UI-Router\" class=\"headerlink\" title=\"如何使用UI-Router\"></a>如何使用UI-Router</h1><p>UI-Router模块是一个可选的angularJS模块，如果需要使用，我们要单独引用js。具体应用示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;script src=&quot;lib/angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;lib/angular-ui-router.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;helloworld.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;style&gt;.active &#123; color: red; font-weight: bold; &#125;&lt;/style&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body ng-app=&quot;helloworld&quot;&gt;</span><br><span class=\"line\">    &lt;a ui-sref=&quot;hello&quot; ui-sref-active=&quot;active&quot;&gt;Hello&lt;/a&gt;</span><br><span class=\"line\">    &lt;a ui-sref=&quot;about&quot; ui-sref-active=&quot;active&quot;&gt;About&lt;/a&gt;</span><br><span class=\"line\">    &lt;ui-view&gt;&lt;/ui-view&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myApp = angular.module(&apos;helloworld&apos;, [&apos;ui.router&apos;]);</span><br><span class=\"line\"></span><br><span class=\"line\">myApp.config(function($stateProvider) &#123;</span><br><span class=\"line\">  var helloState = &#123;</span><br><span class=\"line\">    name: &apos;hello&apos;,</span><br><span class=\"line\">    url: &apos;/hello&apos;,</span><br><span class=\"line\">    template: &apos;&lt;h3&gt;hello world!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var aboutState = &#123;</span><br><span class=\"line\">    name: &apos;about&apos;,</span><br><span class=\"line\">    url: &apos;/about&apos;,</span><br><span class=\"line\">    template: &apos;&lt;h3&gt;Its the UI-Router hello world app!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  $stateProvider.state(helloState);</span><br><span class=\"line\">  $stateProvider.state(aboutState);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由加载的三种方法\"><a href=\"#路由加载的三种方法\" class=\"headerlink\" title=\"路由加载的三种方法\"></a>路由加载的三种方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、·调用$state.go方法   </span><br><span class=\"line\">$state.go(&apos;detail&apos;, &#123;id: 1&#125;);   </span><br><span class=\"line\">$state.go(&apos;index&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、点击包含ui-sref指令的链接</span><br><span class=\"line\">&lt;a ui-sref=&quot;contacts&quot;&gt;Contacts&lt;/a&gt;</span><br><span class=\"line\">&lt;a ui-sref=&quot;contacts.detail(&#123;contactId: 42&#125;)&quot;&gt;Contact 42&lt;/a&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">//3、url跳转</span><br><span class=\"line\">&lt;a href=&quot;#/index&quot; &gt;index&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图嵌套\"><a href=\"#视图嵌套\" class=\"headerlink\" title=\"视图嵌套\"></a>视图嵌套</h2><p>ui-router的视图可以嵌套，视图嵌套通常对应着$state的嵌套。 index.detail是index的子$state，index_detail.html也将作为index.html的子页面。ui-view可以配合$state进行任意层级的嵌套， 即index_detail.html中仍然可以包含一个ui-view，它的$state可能是index.detail.hobbies。</p>\n<h2 id=\"视图命名\"><a href=\"#视图命名\" class=\"headerlink\" title=\"视图命名\"></a>视图命名</h2><p>在ui-router中，一个$state下可以有多个视图，它们有各自的模板和控制器。如上面的示例代码，hello和about就是两个独立的视图，有各自的末班和控制器。</p>\n<h2 id=\"参数说明：\"><a href=\"#参数说明：\" class=\"headerlink\" title=\"参数说明：\"></a>参数说明：</h2><ul>\n<li>url：默认相对路径（以^开头的是绝对路径）</li>\n<li>views：每个子视图可以包含自己的模板、控制器和预载入数据。 (后2项选填,控制器可以在view中绑定)</li>\n<li>abstract：抽象模板不能被激活 </li>\n<li>template: HTML字符串或者返回HTML字符串的函数</li>\n<li>templateUrl: HTML模板的路径或者返回HTML模板路径的函数</li>\n<li>templateProvider：返回HTML字符串的函数</li>\n<li>controller、controllerProvider：指定任何已经被注册的控制器或者一个作为控制器的函数</li>\n<li>resolve：在路由到达前预载入一系列依赖或者数据，然后注入到控制器中。 </li>\n<li>data：数据不会被注入到控制器中，用途是从父状态传递数据到子状态。 </li>\n<li>onEnter/onExit：进入或者离开当前状态的视图时会调用这两个函数.</li>\n<li>resolve 为控制器提供可选的依赖注入项。是由 key/value 组成的键值对象。<pre><code>key – {string}：注入控制器的依赖项名称。\nvalue - {string|function}：\n    string：一个服务的别名\n    function：函数的返回值将作为依赖注入项，如果函数是一个耗时的操作，那么控制器必须等待该函数执行完成（be resolved）才会被实例化。\n    比如,视图都需要用户登录后才能访问,那么判断是否登录就可以做成一个控制器依赖\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;authentication:[&apos;topicAuth&apos;, &apos;$q&apos;, function(topicAuth, $q)&#123;</span><br><span class=\"line\">        return $q.when().then(function()&#123;</span><br><span class=\"line\">            return topicAuth.authentication();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;]&#125;</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n<h2 id=\"动态加载模板-内容\"><a href=\"#动态加载模板-内容\" class=\"headerlink\" title=\"动态加载模板/内容\"></a>动态加载模板/内容</h2><p>在实际使用时往往需要根据参数动态加载不同模板/内容。此时可以通过如下两种方式实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、用参数作为文件名，拼接文件名加载</span><br><span class=\"line\">templateUrl: function ($stateParams)&#123;</span><br><span class=\"line\">    return &apos;/topic/detail_&apos; + $stateParams.type + &apos;.html&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">//2、用参数赋值，修改内容</span><br><span class=\"line\">templateProvider: function ($timeout, $stateParams) &#123;</span><br><span class=\"line\">    return $timeout(function () &#123;</span><br><span class=\"line\">        return &apos;&lt;h1&gt;&apos; + $stateParams.topicId + &apos;&lt;/h1&gt;&apos;</span><br><span class=\"line\">  &#125;, 100);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"路由参数：\"><a href=\"#路由参数：\" class=\"headerlink\" title=\"路由参数：\"></a>路由参数：</h2><p>ui-router同样支持切换视图时传递参数。默认有如下两种方式传递参数：</p>\n<ol>\n<li>通过$stateParams传递。传递的参数是一个object。传递的方法有：<ul>\n<li>ui-sref=”index.detail({id:22})“</li>\n<li>$state.go(‘index.detail’, {id: 22});</li>\n</ul>\n</li>\n<li>通过$location来获取和设置URL。直接在controller里引入$stateParams 和$location即可。</li>\n</ol>\n<h2 id=\"state-为view-controller提供自定义数据。\"><a href=\"#state-为view-controller提供自定义数据。\" class=\"headerlink\" title=\"state 为view controller提供自定义数据。\"></a>state 为view controller提供自定义数据。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;blog.index&apos;, &#123;</span><br><span class=\"line\">        templateUrl: ’templates/blog_index.html&apos;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            currentPage: 1,</span><br><span class=\"line\">            pageSize: 20</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>上面 data 对象就是自定义数据,里面定义了页面的当前页和显示内容条数。在视图对应的 controller 中我们就可以通过下面的方法来获取自定义数据.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log($state.current.data.currentPage);  // 1</span><br><span class=\"line\">console.log($state.current.data.pageSize);  // 20</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如何判断选中视图选中\"><a href=\"#如何判断选中视图选中\" class=\"headerlink\" title=\"如何判断选中视图选中\"></a>如何判断选中视图选中</h2><ol>\n<li><p>$state.includes<br> 返回 true / false，查看当前状态是否在某父状态内，比如 $state.includes(‘contacts’)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 包含在 /contacts 状态内部，即其作为 parant state --&gt;</span><br><span class=\"line\">&lt;li ng-class=&quot;&#123;active: $state.includes(&apos;contacts&apos;)&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;a ui-serif=&quot;contacts.list&quot;&gt;Contacts&lt;/a&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ui-sref-active<br> 查看当前激活状态并设置 Class。例如</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"控制器引入的集中方法\"><a href=\"#控制器引入的集中方法\" class=\"headerlink\" title=\"控制器引入的集中方法\"></a>控制器引入的集中方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;//直接定义</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: function($scope)&#123;</span><br><span class=\"line\">    $scope.title = &apos;My Contacts&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).state(&apos;contacts1&apos;, &#123;//直接名称引用</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: &apos;ContactsCtrl&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts2&apos;, &#123;//直接定义并且定义别名</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: function()&#123;</span><br><span class=\"line\">    this.title = &apos;My Contacts&apos;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  controllerAs: &apos;contact&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts3&apos;, &#123; //控制器名称并且定义别名</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: &apos;ContactsCtrl as contact&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts4&apos;, &#123; //根据state动态加载</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controllerProvider: function($stateParams) &#123;</span><br><span class=\"line\">      var ctrlName = $stateParams.type + &quot;Controller&quot;;</span><br><span class=\"line\">      return ctrlName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：如果未定义template，controller将不会被实例化<br>更多说明：参考 <a href=\"https://github.com/angular-ui/ui-router/wiki\" target=\"_blank\" rel=\"noopener\">https://github.com/angular-ui/ui-router/wiki</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是UI-Router？\"><a href=\"#什么是UI-Router？\" class=\"headerlink\" title=\"什么是UI-Router？\"></a>什么是UI-Router？</h1><p>AngularJS 是一种富客户端单页面应用框架，所以要在一个页面呈现不同的视图，路由起到了至关重要的作用。 UI-Router是Angular-UI提供的客户端路由框架，它解决了原生的ng-route的不足(视图不能嵌套，同一URL下不支持多个视图)。例如实际的单页面应用中，导航栏用一个视图，内容部分用另一个视图，就是比较常见的。<br>UI-Router提出了$state的概念。一个$state是一个当前导航和UI的状态，每个$state需要绑定一个URL Pattern。 在控制器和模板中，通过改变$state来进行URL的跳转和路由。</p>\n<h1 id=\"如何使用UI-Router\"><a href=\"#如何使用UI-Router\" class=\"headerlink\" title=\"如何使用UI-Router\"></a>如何使用UI-Router</h1><p>UI-Router模块是一个可选的angularJS模块，如果需要使用，我们要单独引用js。具体应用示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;head&gt;</span><br><span class=\"line\">    &lt;script src=&quot;lib/angular.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;lib/angular-ui-router.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=&quot;helloworld.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;style&gt;.active &#123; color: red; font-weight: bold; &#125;&lt;/style&gt;</span><br><span class=\"line\">  &lt;/head&gt;</span><br><span class=\"line\">  &lt;body ng-app=&quot;helloworld&quot;&gt;</span><br><span class=\"line\">    &lt;a ui-sref=&quot;hello&quot; ui-sref-active=&quot;active&quot;&gt;Hello&lt;/a&gt;</span><br><span class=\"line\">    &lt;a ui-sref=&quot;about&quot; ui-sref-active=&quot;active&quot;&gt;About&lt;/a&gt;</span><br><span class=\"line\">    &lt;ui-view&gt;&lt;/ui-view&gt;</span><br><span class=\"line\">  &lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myApp = angular.module(&apos;helloworld&apos;, [&apos;ui.router&apos;]);</span><br><span class=\"line\"></span><br><span class=\"line\">myApp.config(function($stateProvider) &#123;</span><br><span class=\"line\">  var helloState = &#123;</span><br><span class=\"line\">    name: &apos;hello&apos;,</span><br><span class=\"line\">    url: &apos;/hello&apos;,</span><br><span class=\"line\">    template: &apos;&lt;h3&gt;hello world!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  var aboutState = &#123;</span><br><span class=\"line\">    name: &apos;about&apos;,</span><br><span class=\"line\">    url: &apos;/about&apos;,</span><br><span class=\"line\">    template: &apos;&lt;h3&gt;Its the UI-Router hello world app!&lt;/h3&gt;&apos;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  $stateProvider.state(helloState);</span><br><span class=\"line\">  $stateProvider.state(aboutState);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由加载的三种方法\"><a href=\"#路由加载的三种方法\" class=\"headerlink\" title=\"路由加载的三种方法\"></a>路由加载的三种方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、·调用$state.go方法   </span><br><span class=\"line\">$state.go(&apos;detail&apos;, &#123;id: 1&#125;);   </span><br><span class=\"line\">$state.go(&apos;index&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、点击包含ui-sref指令的链接</span><br><span class=\"line\">&lt;a ui-sref=&quot;contacts&quot;&gt;Contacts&lt;/a&gt;</span><br><span class=\"line\">&lt;a ui-sref=&quot;contacts.detail(&#123;contactId: 42&#125;)&quot;&gt;Contact 42&lt;/a&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">//3、url跳转</span><br><span class=\"line\">&lt;a href=&quot;#/index&quot; &gt;index&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图嵌套\"><a href=\"#视图嵌套\" class=\"headerlink\" title=\"视图嵌套\"></a>视图嵌套</h2><p>ui-router的视图可以嵌套，视图嵌套通常对应着$state的嵌套。 index.detail是index的子$state，index_detail.html也将作为index.html的子页面。ui-view可以配合$state进行任意层级的嵌套， 即index_detail.html中仍然可以包含一个ui-view，它的$state可能是index.detail.hobbies。</p>\n<h2 id=\"视图命名\"><a href=\"#视图命名\" class=\"headerlink\" title=\"视图命名\"></a>视图命名</h2><p>在ui-router中，一个$state下可以有多个视图，它们有各自的模板和控制器。如上面的示例代码，hello和about就是两个独立的视图，有各自的末班和控制器。</p>\n<h2 id=\"参数说明：\"><a href=\"#参数说明：\" class=\"headerlink\" title=\"参数说明：\"></a>参数说明：</h2><ul>\n<li>url：默认相对路径（以^开头的是绝对路径）</li>\n<li>views：每个子视图可以包含自己的模板、控制器和预载入数据。 (后2项选填,控制器可以在view中绑定)</li>\n<li>abstract：抽象模板不能被激活 </li>\n<li>template: HTML字符串或者返回HTML字符串的函数</li>\n<li>templateUrl: HTML模板的路径或者返回HTML模板路径的函数</li>\n<li>templateProvider：返回HTML字符串的函数</li>\n<li>controller、controllerProvider：指定任何已经被注册的控制器或者一个作为控制器的函数</li>\n<li>resolve：在路由到达前预载入一系列依赖或者数据，然后注入到控制器中。 </li>\n<li>data：数据不会被注入到控制器中，用途是从父状态传递数据到子状态。 </li>\n<li>onEnter/onExit：进入或者离开当前状态的视图时会调用这两个函数.</li>\n<li>resolve 为控制器提供可选的依赖注入项。是由 key/value 组成的键值对象。<pre><code>key – {string}：注入控制器的依赖项名称。\nvalue - {string|function}：\n    string：一个服务的别名\n    function：函数的返回值将作为依赖注入项，如果函数是一个耗时的操作，那么控制器必须等待该函数执行完成（be resolved）才会被实例化。\n    比如,视图都需要用户登录后才能访问,那么判断是否登录就可以做成一个控制器依赖\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;authentication:[&apos;topicAuth&apos;, &apos;$q&apos;, function(topicAuth, $q)&#123;</span><br><span class=\"line\">        return $q.when().then(function()&#123;</span><br><span class=\"line\">            return topicAuth.authentication();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;]&#125;</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ul>\n<h2 id=\"动态加载模板-内容\"><a href=\"#动态加载模板-内容\" class=\"headerlink\" title=\"动态加载模板/内容\"></a>动态加载模板/内容</h2><p>在实际使用时往往需要根据参数动态加载不同模板/内容。此时可以通过如下两种方式实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、用参数作为文件名，拼接文件名加载</span><br><span class=\"line\">templateUrl: function ($stateParams)&#123;</span><br><span class=\"line\">    return &apos;/topic/detail_&apos; + $stateParams.type + &apos;.html&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">//2、用参数赋值，修改内容</span><br><span class=\"line\">templateProvider: function ($timeout, $stateParams) &#123;</span><br><span class=\"line\">    return $timeout(function () &#123;</span><br><span class=\"line\">        return &apos;&lt;h1&gt;&apos; + $stateParams.topicId + &apos;&lt;/h1&gt;&apos;</span><br><span class=\"line\">  &#125;, 100);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"路由参数：\"><a href=\"#路由参数：\" class=\"headerlink\" title=\"路由参数：\"></a>路由参数：</h2><p>ui-router同样支持切换视图时传递参数。默认有如下两种方式传递参数：</p>\n<ol>\n<li>通过$stateParams传递。传递的参数是一个object。传递的方法有：<ul>\n<li>ui-sref=”index.detail({id:22})“</li>\n<li>$state.go(‘index.detail’, {id: 22});</li>\n</ul>\n</li>\n<li>通过$location来获取和设置URL。直接在controller里引入$stateParams 和$location即可。</li>\n</ol>\n<h2 id=\"state-为view-controller提供自定义数据。\"><a href=\"#state-为view-controller提供自定义数据。\" class=\"headerlink\" title=\"state 为view controller提供自定义数据。\"></a>state 为view controller提供自定义数据。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;blog.index&apos;, &#123;</span><br><span class=\"line\">        templateUrl: ’templates/blog_index.html&apos;,</span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\">            currentPage: 1,</span><br><span class=\"line\">            pageSize: 20</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>上面 data 对象就是自定义数据,里面定义了页面的当前页和显示内容条数。在视图对应的 controller 中我们就可以通过下面的方法来获取自定义数据.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log($state.current.data.currentPage);  // 1</span><br><span class=\"line\">console.log($state.current.data.pageSize);  // 20</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如何判断选中视图选中\"><a href=\"#如何判断选中视图选中\" class=\"headerlink\" title=\"如何判断选中视图选中\"></a>如何判断选中视图选中</h2><ol>\n<li><p>$state.includes<br> 返回 true / false，查看当前状态是否在某父状态内，比如 $state.includes(‘contacts’)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 包含在 /contacts 状态内部，即其作为 parant state --&gt;</span><br><span class=\"line\">&lt;li ng-class=&quot;&#123;active: $state.includes(&apos;contacts&apos;)&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;a ui-serif=&quot;contacts.list&quot;&gt;Contacts&lt;/a&gt;</span><br><span class=\"line\">&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ui-sref-active<br> 查看当前激活状态并设置 Class。例如</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li ui-sref-active=&quot;active&quot;&gt;&lt;a ui-sref=&quot;about&quot;&gt;About&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"控制器引入的集中方法\"><a href=\"#控制器引入的集中方法\" class=\"headerlink\" title=\"控制器引入的集中方法\"></a>控制器引入的集中方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$stateProvider.state(&apos;contacts&apos;, &#123;//直接定义</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: function($scope)&#123;</span><br><span class=\"line\">    $scope.title = &apos;My Contacts&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;).state(&apos;contacts1&apos;, &#123;//直接名称引用</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: &apos;ContactsCtrl&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts2&apos;, &#123;//直接定义并且定义别名</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: function()&#123;</span><br><span class=\"line\">    this.title = &apos;My Contacts&apos;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  controllerAs: &apos;contact&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts3&apos;, &#123; //控制器名称并且定义别名</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controller: &apos;ContactsCtrl as contact&apos;</span><br><span class=\"line\">&#125;).state(&apos;contacts4&apos;, &#123; //根据state动态加载</span><br><span class=\"line\">  template:&apos;&lt;h1&gt;test&lt;/h1&gt;&apos;,</span><br><span class=\"line\">  controllerProvider: function($stateParams) &#123;</span><br><span class=\"line\">      var ctrlName = $stateParams.type + &quot;Controller&quot;;</span><br><span class=\"line\">      return ctrlName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意：如果未定义template，controller将不会被实例化<br>更多说明：参考 <a href=\"https://github.com/angular-ui/ui-router/wiki\" target=\"_blank\" rel=\"noopener\">https://github.com/angular-ui/ui-router/wiki</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjc95ci3a000180cmuseh0lp6","tag_id":"cjc95ci3e000380cmd5h9qdx2","_id":"cjc95ci3q000b80cmu1wum1cc"},{"post_id":"cjc95ci3a000180cmuseh0lp6","tag_id":"cjc95ci3m000780cm149sk76w","_id":"cjc95ci3q000c80cmkr87gvwe"},{"post_id":"cjc95ci3e000280cmed7lx2df","tag_id":"cjc95ci3q000a80cmd4vxanug","_id":"cjc95ci3u000e80cmy7ly6dwx"},{"post_id":"cjc95ci3i000480cm4oq5rapj","tag_id":"cjc95ci3q000a80cmd4vxanug","_id":"cjc95ci3u000g80cmha6lh9na"},{"post_id":"cjc95ci3i000580cmls7naqjk","tag_id":"cjc95ci3q000a80cmd4vxanug","_id":"cjc95ci3u000i80cmvyanjj4h"},{"post_id":"cjc95ci3m000680cmurao82ya","tag_id":"cjc95ci3u000h80cmafyy0exf","_id":"cjc95ci3y000k80cmsj6m54er"},{"post_id":"cjc95ci3q000980cm2db34uje","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjc95ci3y000l80cmcoannrll"},{"post_id":"cjc95ci42000m80cm8gmyfauf","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjc95ci4i000u80cmhdawawge"},{"post_id":"cjc95ci42000m80cm8gmyfauf","tag_id":"cjc95ci4e000s80cm0kx19ipj","_id":"cjc95ci4i000v80cm9rm6gzsz"},{"post_id":"cjc95ci46000n80cmtelmgdly","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjc95ci4i000y80cmj9pguvi2"},{"post_id":"cjc95ci46000n80cmtelmgdly","tag_id":"cjc95ci4e000s80cm0kx19ipj","_id":"cjc95ci4m000z80cmpvnszprk"},{"post_id":"cjc95ci4a000p80cmkp2j2yir","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjc95ci4m001280cmztbom64z"},{"post_id":"cjc95ci4a000p80cmkp2j2yir","tag_id":"cjc95ci4e000s80cm0kx19ipj","_id":"cjc95ci4m001380cmvcb6wd39"},{"post_id":"cjc95ci4e000q80cm97orzr7v","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjc95ci4m001680cmfk578eig"},{"post_id":"cjc95ci4e000q80cm97orzr7v","tag_id":"cjc95ci4m001180cmxnpuefdd","_id":"cjc95ci4m001780cmku931xsn"},{"post_id":"cjc95ci4e000q80cm97orzr7v","tag_id":"cjc95ci4m001480cm126yuvib","_id":"cjc95ci4q001980cmxvnny9k0"},{"post_id":"cjc95ci4e000q80cm97orzr7v","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjc95ci4q001a80cmjxmf0fnc"},{"post_id":"cjc95ci4e000r80cm915rhvhc","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjc95ci4q001b80cm4ka2h8j3"},{"post_id":"cjc95ci4e000r80cm915rhvhc","tag_id":"cjc95ci4m001180cmxnpuefdd","_id":"cjc95ci4q001c80cm4lkw2coh"},{"post_id":"cjc95ci4e000r80cm915rhvhc","tag_id":"cjc95ci4m001480cm126yuvib","_id":"cjc95ci4q001d80cm396rpjpe"},{"post_id":"cjc95ci4e000r80cm915rhvhc","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjc95ci4q001e80cm7n0ygro0"},{"post_id":"cjemvlvxp0000tccml2nsc0dh","tag_id":"cjemvlvxp0001tccm2awmefe1","_id":"cjemvlvy50002tccmxo8ecj0z"},{"post_id":"cjemvlvyl0007tccmiko9u08a","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvyl000atccmp6xy3ovq"},{"post_id":"cjemvlvy50003tccmu9l1somi","tag_id":"cjemvlvyl0005tccmuyzf4zst","_id":"cjemvlvyl000ctccm571i3ybq"},{"post_id":"cjemvlvy50003tccmu9l1somi","tag_id":"cjc95ci3q000a80cmd4vxanug","_id":"cjemvlvyl000ftccmu7nquj1z"},{"post_id":"cjemvlvyl0008tccm6545ts65","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvyl000htccmscw44s03"},{"post_id":"cjemvlvyl0004tccmipsgh3kz","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz0000ktccmx72x8gp6"},{"post_id":"cjemvlvyl0004tccmipsgh3kz","tag_id":"cjemvlvyl0009tccm70pokxw0","_id":"cjemvlvz0000mtccmdr8mdu32"},{"post_id":"cjemvlvyl000gtccmyrmv3vta","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz0000otccmz4ueevsg"},{"post_id":"cjemvlvyl0006tccmhd3trs51","tag_id":"cjemvlvyl000etccmy9bsst1n","_id":"cjemvlvz0000rtccmazjvz2sh"},{"post_id":"cjemvlvyl0006tccmhd3trs51","tag_id":"cjc95ci3q000a80cmd4vxanug","_id":"cjemvlvz0000ttccmlgmo7fvt"},{"post_id":"cjemvlvyl000btccmn0cp28o6","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz0000vtccm9xi2zsbb"},{"post_id":"cjemvlvyl000btccmn0cp28o6","tag_id":"cjemvlvyl000jtccm2ckehj62","_id":"cjemvlvz0000wtccm4gy151q1"},{"post_id":"cjemvlvz0000stccmn1m7qtxt","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz0000xtccmbk4bzw9k"},{"post_id":"cjemvlvyl000dtccmag4vhotg","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz0000ytccmp6qdlwrg"},{"post_id":"cjemvlvyl000dtccmag4vhotg","tag_id":"cjemvlvz0000ptccm1ifmjc9q","_id":"cjemvlvz0000ztccm8g9lpf6q"},{"post_id":"cjemvlvyl000itccmj24dldld","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlvz00010tccmytdf4711"},{"post_id":"cjemvlvyl000itccmj24dldld","tag_id":"cjemvlvz0000utccmdnlt6n8c","_id":"cjemvlvz00011tccmaqre52tz"},{"post_id":"cjemvlw0b0012tccm75m9ugn4","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvlw0b0014tccmpvv9jyzd"},{"post_id":"cjemvlw0b0013tccmoqompymz","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjemvlw0b0016tccmi0ui8ccl"},{"post_id":"cjemvlw0b0013tccmoqompymz","tag_id":"cjc95ci4e000s80cm0kx19ipj","_id":"cjemvlw0b0019tccmvcnfsfzi"},{"post_id":"cjemvlw0b001btccmrcdgybxw","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjemvlw0r001dtccmkoknbkjf"},{"post_id":"cjemvlw0b001btccmrcdgybxw","tag_id":"cjemvlw0b0018tccm4vdnvhst","_id":"cjemvlw0r001etccm0077ors5"},{"post_id":"cjemvlw0b0015tccm92waqadi","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjemvlw0r001gtccmzph9j1yl"},{"post_id":"cjemvlw0b0015tccm92waqadi","tag_id":"cjemvlw0b0018tccm4vdnvhst","_id":"cjemvlw0r001htccmch1zwmau"},{"post_id":"cjemvlw0b0017tccmm38rmc7l","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjemvlw0r001itccme63890oj"},{"post_id":"cjemvlw0b0017tccmm38rmc7l","tag_id":"cjemvlw0b0018tccm4vdnvhst","_id":"cjemvlw0r001jtccmedz4sm39"},{"post_id":"cjemvlw0b001atccmyyf1akwl","tag_id":"cjc95ci4a000o80cm8qa60ytm","_id":"cjemvlw0r001ktccmq5hri8ij"},{"post_id":"cjemvlw0b001atccmyyf1akwl","tag_id":"cjemvlw0b0018tccm4vdnvhst","_id":"cjemvlw0r001ltccmrg03gx71"},{"post_id":"cjemvlvz0000ltccmplzxmhit","tag_id":"cjc95ci3y000j80cmvvlakbmu","_id":"cjemvr6os0000bscmlracsn5l"}],"Tag":[{"name":"db","_id":"cjc95ci3e000380cmd5h9qdx2"},{"name":"mongodb","_id":"cjc95ci3m000780cm149sk76w"},{"name":"java","_id":"cjc95ci3q000a80cmd4vxanug"},{"name":"敏捷","_id":"cjc95ci3u000h80cmafyy0exf"},{"name":"工具","_id":"cjc95ci3y000j80cmvvlakbmu"},{"name":"JS","_id":"cjc95ci4a000o80cm8qa60ytm"},{"name":"性能","_id":"cjc95ci4e000s80cm0kx19ipj"},{"name":"自动化","_id":"cjc95ci4m001180cmxnpuefdd"},{"name":"测试","_id":"cjc95ci4m001480cm126yuvib"},{"name":"前端","_id":"cjemvlvxp0001tccm2awmefe1"},{"name":"spring","_id":"cjemvlvyl0005tccmuyzf4zst"},{"name":"MySQL","_id":"cjemvlvyl0009tccm70pokxw0"},{"name":"zuul","_id":"cjemvlvyl000etccmy9bsst1n"},{"name":"linux","_id":"cjemvlvyl000jtccm2ckehj62"},{"name":"linux，java","_id":"cjemvlvz0000ptccm1ifmjc9q"},{"name":"gerrit","_id":"cjemvlvz0000utccmdnlt6n8c"},{"name":"AngularJS","_id":"cjemvlw0b0018tccm4vdnvhst"}]}}